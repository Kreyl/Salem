
SalemBox.elf:     file format elf32-littlearm
SalemBox.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x080008e1

Program Header:
    LOAD off    0x00008000 vaddr 0x08000000 paddr 0x08000000 align 2**15
         filesz 0x00002adc memsz 0x00002ae0 flags rwx
    LOAD off    0x00010800 vaddr 0x20000800 paddr 0x08002ae0 align 2**15
         filesz 0x00000000 memsz 0x00000fd0 flags rw-
    LOAD off    0x00010000 vaddr 0x20000000 paddr 0x20000000 align 2**15
         filesz 0x00000000 memsz 0x00000800 flags rw-
private flags = 5000002: [Version5 EABI] [has entry point]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 startup       000000f4  08000000  08000000  00008000  2**4  CONTENTS, ALLOC, LOAD, DATA
  1 constructors  00000008  080000f4  080000f4  000080f4  2**2  CONTENTS, ALLOC, LOAD, DATA
  2 .text         000029dc  08000100  08000100  00008100  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .textalign    00000004  08002adc  08002adc  0000aadc  2**0  ALLOC
  4 .stacks       00000800  20000000  20000000  00010000  2**0  ALLOC
  5 .bss          00000fd0  20000800  08002ae0  00010800  2**3  ALLOC
  6 .debug_info   000126fc  00000000  00000000  0000aadc  2**0  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003c90  00000000  00000000  0001d1d8  2**0  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000434c  00000000  00000000  00020e68  2**0  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000730  00000000  00000000  000251b4  2**0  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000cd8  00000000  00000000  000258e4  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000032c5  00000000  00000000  000265bc  2**0  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000039cb  00000000  00000000  00029881  2**0  CONTENTS, READONLY, DEBUGGING
 13 .comment      00000070  00000000  00000000  0002d24c  2**0  CONTENTS, READONLY
 14 .ARM.attributes 00000033  00000000  00000000  0002d2bc  2**0  CONTENTS, READONLY
 15 .debug_frame  0000108c  00000000  00000000  0002d2f0  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
08000000 l    d  startup	00000000 startup
080000f4 l    d  constructors	00000000 constructors
08000100 l    d  .text	00000000 .text
08002adc l    d  .textalign	00000000 .textalign
20000000 l    d  .stacks	00000000 .stacks
20000800 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 vectors.c
00000000 l    df *ABS*	00000000 keys.cpp
08001000 l     F .text	0000003c TimeElapsed(unsigned long*, unsigned long)
08000100 l     F .text	00000014 _GLOBAL__sub_I_Keys
00000000 l    df *ABS*	00000000 main.cpp
08001de0 l     F .text	00000016 GeneralSequencerTmrCallback(void*)
08000230 l     F .text	0000006c _GLOBAL__sub_I_App
08002a30 l     O .text	00000038 bsqBeepBeep
08002ab0 l     O .text	0000000c lsqFadeIn
08002ac0 l     O .text	0000001c bsqButton
00000000 l    df *ABS*	00000000 chevents.c
00000000 l    df *ABS*	00000000 chschd.c
08000380 l     F .text	00000034 wakeup
00000000 l    df *ABS*	00000000 chsys.c
20000800 l     O .bss	00000028 mainthread.4583
00000000 l    df *ABS*	00000000 chthreads.c
00000000 l    df *ABS*	00000000 chvt.c
00000000 l    df *ABS*	00000000 chcore_v7m.c
08000794 l       .text	00000000 _port_exit_from_isr
00000000 l    df *ABS*	00000000 crt0.c
00000000 l    df *ABS*	00000000 hal.c
00000000 l    df *ABS*	00000000 hal_lld.cpp
00000000 l    df *ABS*	00000000 nvic.c
00000000 l    df *ABS*	00000000 stm32_dma.c
20000828 l     O .bss	00000038 dma_isr_redir
20000860 l     O .bss	00000004 dma_streams_mask
00000000 l    df *ABS*	00000000 SimpleSensors.cpp
08000e80 l     F .text	0000001c SensorsThread(void*)
08002360 l     O .text	00000018 SnsGroupMSns
080023a0 l     O .text	00000010 MSnsGroupData
20000864 l     O .bss	00000002 SnsMSnsWasHi
08002380 l     O .text	00000018 SnsGroupKey
080023c0 l     O .text	00000020 SnsKeyGroupData
20000978 l     O .bss	00000004 SnsKeysWasHi
20000868 l     O .bss	00000110 waSensorsThread
00000000 l    df *ABS*	00000000 clocking_L1xx.cpp
00000000 l    df *ABS*	00000000 kl_lib_L15x.cpp
08001210 l     F .text	0000005c PinClockEnable(GPIO_TypeDef*)
08001270 l     F .text	0000001c CmdUart_t::PrintNow(char const*) [clone .isra.12]
08001290 l     F .text	0000008a PinSetupAlterFunc(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinAF_t, PinSpeed_t) [clone .constprop.13]
00000000 l    df *ABS*	00000000 kl_sprintf.c
08001660 l     F .text	00000072 IPutUint.4105
00000000 l    df *ABS*	00000000 uart.cpp
08001860 l     F .text	0000000c FPutChar(char)
00000000 l    df *ABS*	00000000 lcd1200.cpp
08001a80 l     F .text	0000005c PinSetupOut(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinSpeed_t) [clone .constprop.13]
08001b80 l     F .text	00000010 FLcdPutChar(char)
080023f0 l     O .text	00000600 Font_6x8_Data
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 chregistry.c
00000000 l    df *ABS*	00000000 
200017d0 l       .bss	00000000 __heap_base__
08002ae0 l       .textalign	00000000 _etext
20004000 l       *ABS*	00000000 __heap_end__
00004000 l       *ABS*	00000000 __ram_size__
00000000 l       startup	00000000 _text
20000000 l       startup	00000000 __ram_start__
20004000 l       *ABS*	00000000 __ram_end__
200017d0 l       .bss	00000000 _end
00000400 l       *ABS*	00000000 __main_stack_size__
00000400 l       *ABS*	00000000 __process_stack_size__
08000cc0  w    F .text	00000002 Vector58
08000cc0  w    F .text	00000002 VectorE8
08000cc0  w    F .text	00000002 Vector9C
08000a20 g     F .text	00000046 nvicEnableVector
08000fc0 g     F .text	00000034 SetupVCore(VCore_t)
08000cc0  w    F .text	00000002 VectorAC
080006d0 g     F .text	0000000a chThdExit
08000570 g     F .text	00000050 chSysTimerHandlerI
080003e0 g     F .text	0000003c chSchGoSleepTimeoutS
08000e20 g     F .text	00000038 Sensors_t::Init()
08001e40  w    F .text	00000070 BaseSequencer_t<BeepChunk_t>::IProcessSequenceI()
08000cc0  w    F .text	00000002 Vector5C
08001b30 g     F .text	00000048 Lcd_t::DrawChar(unsigned char, Invert_t)
08000cc0  w    F .text	00000002 NMIVector
08000bf0 g     F .text	00000038 dmaInit
08000cc0  w    F .text	00000002 Vector8C
08000cd0  w    F .text	00000094 SnsGroup_t::Init() const
08001320 g     F .text	000000b4 Timer_t::InitClock(TIM_TypeDef*)
08000cc0  w    F .text	00000002 VectorDC
080013e0 g     F .text	000000c4 Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)
08000000 g     O startup	000000f4 _vectors
080003c0 g     F .text	00000020 chSchGoSleepS
08001870 g     F .text	0000003c CmdUart_t::ISendViaDMA()
08001e10  w    F .text	00000024 Beeper_t::ISetup()
08001070 g     F .text	00000034 Keys_t::AddEvtToQueue(KeyEvtInfo_t)
080005f0 g     F .text	00000048 chThdCreateI
08000cc0  w    F .text	00000002 VectorC8
08000420 g     F .text	00000038 chSchWakeupS
08000320 g     F .text	00000014 _scheduler_init
08000640 g     F .text	00000028 chThdCreateStatic
08000cc0  w    F .text	00000002 Vector94
200016fc g     O .bss	00000008 App
08000cc0  w    F .text	00000002 VectorA8
08000cc0  w    F .text	00000002 VectorB4
08000340 g     F .text	00000038 chSchReadyI
080014b0 g     F .text	0000015c PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)
08001ec0  w    F .text	0000000c LedSmooth_t::ISwitchOff()
080000fc g       constructors	00000000 __fini_array_end
20000800 g       .stacks	00000000 __main_thread_stack_end__
080006e0 g     F .text	00000018 _vt_init
08000b00 g     F .text	0000002c Vector74
080009a0 g     F .text	00000004 halInit
08000cc0  w    F .text	00000002 VectorEC
20000800 g       .bss	00000000 _bss_start
08000460 g     F .text	00000030 chSchDoRescheduleBehind
08000cc0  w    F .text	00000002 UsageFaultVector
08000cc0  w    F .text	00000002 DebugMonitorVector
08001200 g     F .text	00000010 ProcessKeyState(void*)
080010b0 g     F .text	00000038 Keys_t::AddEvtToQueue(KeyEvt_t, unsigned char)
08000cc0  w    F .text	00000002 Vector40
080008e0 g     F .text	000000c0 ResetHandler
08000cc0  w    F .text	00000002 VectorBC
08001ef0  w    F .text	0000006e LedSmooth_t::ISetup()
080007c0 g     F .text	00000034 _port_init
080009b0 g     F .text	00000064 hal_lld_init
08001bd0 g     F .text	00000012 Lcd_t::Cls()
080006a0 g     F .text	00000030 chThdExitS
080018b0 g     F .text	0000003c CmdUart_t::IPrintf(char const*, std::__va_list)
08000cc0  w    F .text	00000002 PendSVVector
08000700 g     F .text	0000004c chVTSetI
08000cc0  w    F .text	00000002 Vector64
200017d0 g       .bss	00000000 _bss_end
080008d0  w    F .text	00000002 _default_exit
08001a00 g     F .text	0000006c CmdUart_t::IRQDmaTxHandler()
08000cc0  w    F .text	00000002 VectorCC
08000cc0  w    F .text	00000002 Vector54
08001fc0  w    F .text	0000001a BaseSequencer_t<BeepChunk_t>::StartSequence(BeepChunk_t const*)
08000cc0  w    F .text	00000002 Vector98
08000cc0  w    F .text	00000002 VectorD8
08000cc0  w    F .text	00000002 Vector24
080004d0 g     F .text	00000014 chSchDoReschedule
08000510 g     F .text	00000058 chSysInit
08001e00  w    F .text	00000008 Beeper_t::ISwitchOff()
08000670 g     F .text	00000028 chThdSleep
08002300 g     O .text	00000054 _stm32_dma_streams
08000bc0 g     F .text	0000002c Vector84
08000870 g     F .text	0000001a SysTickVector
200009dc g     O .bss	000005f0 Uart
08000cc0  w    F .text	00000002 BusFaultVector
08001b90 g     F .text	00000038 Lcd_t::Printf(unsigned char, unsigned char, char const*, ...)
08000cc0  w    F .text	00000002 VectorD0
08000ea0 g     F .text	00000114 Clk_t::UpdateFreqValues()
080029f0  w    O .text	00000014 vtable for Beeper_t
2000169c g     O .bss	0000002c Beeper
08000cc0  w    F .text	00000002 VectorE4
08000cc0  w    F .text	00000002 VectorC0
08000890 g     F .text	00000010 _port_switch
080007a0 g     F .text	00000012 SVCallVector
080008c0  w    F .text	00000002 __late_init
08001630 g     F .text	0000002c chDbgPanic
200017c0 g     O .bss	00000010 vtlist
08000cc0  w    F .text	00000002 HardFaultVector
08000800 g     F .text	00000068 _port_irq_epilogue
20000fcc g     O .bss	000006d0 Lcd
08001920 g     F .text	000000d4 CmdUart_t::Init(unsigned long)
08000cc0  w    F .text	00000002 VectorF0
080010f0 g     F .text	00000104 Keys_t::ProcessKeysState(bool*)
20000980 g     O .bss	0000000c Clk
2000098c g     O .bss	00000050 Keys
08002ae0 g       .textalign	00000000 _textdata
08000cc0  w    F .text	00000002 VectorE0
08000cc0  w    F .text	00000002 MemManageVector
080000fc g       constructors	00000000 __fini_array_start
08002070 g     F .text	00000094 memset
08000120 g     F .text	00000104 main
08000aa0 g     F .text	00000028 Vector6C
08000d70  w    F .text	000000a8 SnsGroup_t::Check() const
20001704 g     O .bss	0000001c rlist
08000cc0  w    F .text	00000002 VectorA0
2000097c g     O .bss	00000001 Sensors
080000fc g       constructors	00000000 __init_array_end
08000cc0  w    F .text	00000002 VectorC4
08000b60 g     F .text	0000002c Vector7C
08000e60 g     F .text	00000020 Sensors_t::ITask()
080004f0 g     F .text	00000014 _idle_thread
08000cc0  w    F .text	00000002 VectorB0
080021d0 g     O .text	00000016 ch_debug
08000cc0  w    F .text	00000002 Vector90
080002a0 g     F .text	00000040 chEvtSignalI
080018f0 g     F .text	00000026 CmdUart_t::Printf(char const*, ...)
080008a0 g     F .text	00000010 _port_thread_start
08000cc0  w    F .text	00000002 Vector60
08000cc0  w    F .text	00000002 Vector1C
08000490 g     F .text	00000038 chSchDoRescheduleAhead
08000cc0  w    F .text	00000002 Vector48
20000400 g       .stacks	00000000 __process_stack_base__
08001ae0 g     F .text	0000004c Lcd_t::WriteCmd(unsigned char)
2000097d g     O .bss	00000001 VCore
08000ad0 g     F .text	00000028 Vector70
08000cc0  w    F .text	00000002 VectorD4
08000a70 g     F .text	00000026 nvicSetSystemHandlerPriority
080016e0 g     F .text	00000160 kl_vsprintf
20001720 g     O .bss	000000a0 _idle_thread_wa
20000800 g       .bss	00000000 _data
08001a70 g     F .text	0000000c CmdUartTxIrq
08000cc0  w    F .text	00000002 Vector4C
08000b90 g     F .text	0000002c Vector80
08000790 g     F .text	00000006 _port_switch_from_isr
08000cc0  w    F .text	00000002 Vector68
20000400 g       .stacks	00000000 __main_stack_end__
08000b30 g     F .text	0000002c Vector78
20000800 g       .bss	00000000 _edata
08001610 g     F .text	0000001a PwmPin_t::SetFreqHz(unsigned long)
080002e0 g     F .text	00000034 chEvtWaitAny
08000750 g     F .text	00000040 chVTResetI
08000cc0 g     F .text	00000002 _unhandled_exception
08001040  w    F .text	0000002e CircBuf_t<KeyEvtInfo_t, 7ul>::Put(KeyEvtInfo_t*)
08000cc0  w    F .text	00000002 Vector88
08001eb0  w    F .text	0000000c LedChnlTmr_t<255ul, (Inverted_t)1>::Set(unsigned char) const
20000400 g       .stacks	00000000 __main_thread_stack_base__
08001ed0  w    F .text	00000020 BaseSequencer_t<LedSmoothChunk_t>::SetupDelay(unsigned long)
080000f4 g       constructors	00000000 __init_array_start
080005c0 g     F .text	00000024 _thread_init
08000cc0  w    F .text	00000002 Vector50
08000c30 g     F .text	00000088 dmaStreamAllocate
08002a10  w    O .text	00000014 vtable for LedSmooth_t
20000000 g       .stacks	00000000 __main_stack_base__
08000cc0  w    F .text	00000002 Vector44
08000cc0  w    F .text	00000002 Vector28
08000cc0  w    F .text	00000002 VectorB8
200016c8 g     O .bss	00000034 Led
08001840 g     F .text	0000001e CmdUart_t::IPutChar(char)
08001fe0 g     F .text	00000088 App_t::ITask()
20000800 g       .stacks	00000000 __process_stack_end__
08000cc0  w    F .text	00000002 Vector34
080008b0  w    F .text	00000002 __early_init
08000cc0  w    F .text	00000002 VectorA4
08001f60  w    F .text	00000054 BaseSequencer_t<LedSmoothChunk_t>::IProcessSequenceI()
08001bf0 g     F .text	000001e4 Lcd_t::Init()
08000cc0  w    F .text	00000002 Vector20



Disassembly of section .text:

08000100 <_GLOBAL__sub_I_Keys>:
CircBuf_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:27
    uint32_t Length;
};

// =========================== Circular buffer =================================
template <typename T, uint32_t Sz>
class CircBuf_t {
 8000100:	4b03      	ldr	r3, [pc, #12]	; (8000110 <_GLOBAL__sub_I_Keys+0x10>)
 8000102:	2200      	movs	r2, #0
 8000104:	619a      	str	r2, [r3, #24]
 8000106:	f103 021c 	add.w	r2, r3, #28
 800010a:	649a      	str	r2, [r3, #72]	; 0x48
 800010c:	64da      	str	r2, [r3, #76]	; 0x4c
 800010e:	4770      	bx	lr
 8000110:	2000098c 	.word	0x2000098c
	...

08000120 <main>:
main():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:25

#if 1 // ============================ Timers ===================================

#endif

int main(void) {
 8000120:	b51f      	push	{r0, r1, r2, r3, r4, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:28
    // ==== Init Vcore & clock system ====
    SetupVCore(vcore1V5);
    Clk.UpdateFreqValues();
 8000122:	4c33      	ldr	r4, [pc, #204]	; (80001f0 <main+0xd0>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:35
    // ==== Init OS ====
    halInit();
    chSysInit();

    // ==== Init Hard & Soft ====
    Uart.Init(115200);
 8000124:	4d33      	ldr	r5, [pc, #204]	; (80001f4 <main+0xd4>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:27

#endif

int main(void) {
    // ==== Init Vcore & clock system ====
    SetupVCore(vcore1V5);
 8000126:	2002      	movs	r0, #2
 8000128:	f000 ff4a 	bl	8000fc0 <SetupVCore(VCore_t)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:28
    Clk.UpdateFreqValues();
 800012c:	4620      	mov	r0, r4
 800012e:	f000 feb7 	bl	8000ea0 <Clk_t::UpdateFreqValues()>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:31

    // ==== Init OS ====
    halInit();
 8000132:	f000 fc35 	bl	80009a0 <halInit>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:32
    chSysInit();
 8000136:	f000 f9eb 	bl	8000510 <chSysInit>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:35

    // ==== Init Hard & Soft ====
    Uart.Init(115200);
 800013a:	4628      	mov	r0, r5
 800013c:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
 8000140:	f001 fbee 	bl	8001920 <CmdUart_t::Init(unsigned long)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:36
    Uart.Printf("\rSalemBox AHB=%u", Clk.AHBFreqHz);
 8000144:	4628      	mov	r0, r5
 8000146:	492c      	ldr	r1, [pc, #176]	; (80001f8 <main+0xd8>)
 8000148:	6822      	ldr	r2, [r4, #0]
 800014a:	f001 fbd1 	bl	80018f0 <CmdUart_t::Printf(char const*, ...)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:38

    App.PThread = chThdSelf();
 800014e:	4b2b      	ldr	r3, [pc, #172]	; (80001fc <main+0xdc>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:40

    Lcd.Init();
 8000150:	4c2b      	ldr	r4, [pc, #172]	; (8000200 <main+0xe0>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:38

    // ==== Init Hard & Soft ====
    Uart.Init(115200);
    Uart.Printf("\rSalemBox AHB=%u", Clk.AHBFreqHz);

    App.PThread = chThdSelf();
 8000152:	699a      	ldr	r2, [r3, #24]
 8000154:	4b2b      	ldr	r3, [pc, #172]	; (8000204 <main+0xe4>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:40

    Lcd.Init();
 8000156:	4620      	mov	r0, r4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:38

    // ==== Init Hard & Soft ====
    Uart.Init(115200);
    Uart.Printf("\rSalemBox AHB=%u", Clk.AHBFreqHz);

    App.PThread = chThdSelf();
 8000158:	605a      	str	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:40

    Lcd.Init();
 800015a:	f001 fd49 	bl	8001bf0 <Lcd_t::Init()>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.h:81
    void GotoXY(uint8_t x, uint8_t y) { CurrentPosition =  x + y*96; }
public:
    uint16_t Brightness;
    void Init();
    void Shutdown();
    void Backlight(uint8_t ABrightness)  { BckLt.Set(ABrightness); }
 800015e:	68a3      	ldr	r3, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:42
    Lcd.Backlight(50);
    Lcd.Printf(1,1,"Aiya Feanaro!");
 8000160:	2101      	movs	r1, #1
_ZN8PwmPin_t3SetEt():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:271
    TIM_TypeDef* Tim;
public:
    __IO uint32_t *PCCR;    // Made public to allow DMA
    void SetFreqHz(uint32_t FreqHz);
    void Init(GPIO_TypeDef *GPIO, uint16_t N, TIM_TypeDef* PTim, uint8_t Chnl, uint16_t TopValue, bool Inverted=false);
    void Set(uint16_t Value) { *PCCR = Value; }
 8000162:	2232      	movs	r2, #50	; 0x32
 8000164:	601a      	str	r2, [r3, #0]
main():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:42
 8000166:	4620      	mov	r0, r4
 8000168:	460a      	mov	r2, r1
 800016a:	4b27      	ldr	r3, [pc, #156]	; (8000208 <main+0xe8>)
 800016c:	f001 fd10 	bl	8001b90 <Lcd_t::Printf(unsigned char, unsigned char, char const*, ...)>
_ZN8Beeper_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:27
        IPCurrentChunk++;   // Always goto next
        return sltProceed;  // Always proceed
    }
public:
    Beeper_t() : BaseSequencer_t(), IPin() {}
    void Init() { IPin.Init(GPIOB, 3, TIM2, 2, BEEP_TOP_VALUE); }
 8000170:	4c26      	ldr	r4, [pc, #152]	; (800020c <main+0xec>)
main():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:44

    Sensors.Init();
 8000172:	4827      	ldr	r0, [pc, #156]	; (8000210 <main+0xf0>)
 8000174:	f000 fe54 	bl	8000e20 <Sensors_t::Init()>
_ZN8Beeper_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:27
 8000178:	2500      	movs	r5, #0
 800017a:	2202      	movs	r2, #2
 800017c:	2316      	movs	r3, #22
 800017e:	e88d 002c 	stmia.w	sp, {r2, r3, r5}
 8000182:	f104 0020 	add.w	r0, r4, #32
 8000186:	2203      	movs	r2, #3
 8000188:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800018c:	4921      	ldr	r1, [pc, #132]	; (8000214 <main+0xf4>)
 800018e:	f001 f98f 	bl	80014b0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)>
main():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:46
    Beeper.Init();
    Beeper.StartSequence(bsqBeepBeep);
 8000192:	4620      	mov	r0, r4
_ZNK12LedChnlTmr_tILm255EL10Inverted_t1EE4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:41
    uint32_t TmrChnl;
    void Set(const uint8_t AValue) const { *TMR_PCCR(PTimer, TmrChnl) = AValue; }    // CCR[N] = AValue
    void Enable()  const { TMR_ENABLE (PTimer); }
    void Disable() const { TMR_DISABLE(PTimer); }
    void Init() const {
        Timer_t::InitClock(PTimer);
 8000194:	4c20      	ldr	r4, [pc, #128]	; (8000218 <main+0xf8>)
main():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:46
 8000196:	4921      	ldr	r1, [pc, #132]	; (800021c <main+0xfc>)
 8000198:	f001 ff12 	bl	8001fc0 <BaseSequencer_t<BeepChunk_t>::StartSequence(BeepChunk_t const*)>
_ZNK12LedChnlTmr_tILm255EL10Inverted_t1EE4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:41
 800019c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800019e:	f001 f8bf 	bl	8001320 <Timer_t::InitClock(TIM_TypeDef*)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:42
        Timer_t::InitPwm(PTimer, PGpio, Pin, TmrChnl, TopValue, Inverted);
 80001a2:	20ff      	movs	r0, #255	; 0xff
 80001a4:	2101      	movs	r1, #1
 80001a6:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
 80001a8:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80001ac:	e88d 0003 	stmia.w	sp, {r0, r1}
 80001b0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80001b2:	6a21      	ldr	r1, [r4, #32]
 80001b4:	f001 f914 	bl	80013e0 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)>
main():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:40
    TIM_TypeDef *PTimer;
    uint32_t TmrChnl;
    void Set(const uint8_t AValue) const { *TMR_PCCR(PTimer, TmrChnl) = AValue; }    // CCR[N] = AValue
    void Enable()  const { TMR_ENABLE (PTimer); }
    void Disable() const { TMR_DISABLE(PTimer); }
    void Init() const {
 80001b8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
_ZN11LedSmooth_t13SetBrightnessEh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:178
        BaseSequencer_t(), IChnl(AChnl), ICurrentBrightness(0) {}
    void Init() {
        IChnl.Init();
        SetBrightness(0);
    }
    void SetBrightness(uint8_t ABrightness) { IChnl.Set(ABrightness); }
 80001ba:	f104 0020 	add.w	r0, r4, #32
_ZNK12LedChnlTmr_tILm255EL10Inverted_t1EE6EnableEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:38
class LedChnlTmr_t : public LedChnl_t {
public:
    TIM_TypeDef *PTimer;
    uint32_t TmrChnl;
    void Set(const uint8_t AValue) const { *TMR_PCCR(PTimer, TmrChnl) = AValue; }    // CCR[N] = AValue
    void Enable()  const { TMR_ENABLE (PTimer); }
 80001be:	881a      	ldrh	r2, [r3, #0]
_ZN11LedSmooth_t13SetBrightnessEh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:178
        BaseSequencer_t(), IChnl(AChnl), ICurrentBrightness(0) {}
    void Init() {
        IChnl.Init();
        SetBrightness(0);
    }
    void SetBrightness(uint8_t ABrightness) { IChnl.Set(ABrightness); }
 80001c0:	4629      	mov	r1, r5
_ZNK12LedChnlTmr_tILm255EL10Inverted_t1EE6EnableEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:38
class LedChnlTmr_t : public LedChnl_t {
public:
    TIM_TypeDef *PTimer;
    uint32_t TmrChnl;
    void Set(const uint8_t AValue) const { *TMR_PCCR(PTimer, TmrChnl) = AValue; }    // CCR[N] = AValue
    void Enable()  const { TMR_ENABLE (PTimer); }
 80001c2:	b292      	uxth	r2, r2
 80001c4:	f042 0201 	orr.w	r2, r2, #1
 80001c8:	801a      	strh	r2, [r3, #0]
_ZN11LedSmooth_t13SetBrightnessEh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:178
        BaseSequencer_t(), IChnl(AChnl), ICurrentBrightness(0) {}
    void Init() {
        IChnl.Init();
        SetBrightness(0);
    }
    void SetBrightness(uint8_t ABrightness) { IChnl.Set(ABrightness); }
 80001ca:	f001 fe71 	bl	8001eb0 <LedChnlTmr_t<255ul, (Inverted_t)1>::Set(unsigned char) const>
_ZN15BaseSequencer_tI16LedSmoothChunk_tE13StartSequenceEPKS0_():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:75
    const TChunk *IPStartChunk, *IPCurrentChunk;
    BaseSequencer_t() : IPStartChunk(nullptr), IPCurrentChunk(nullptr) {}
    void SetupDelay(uint32_t ms) { chVTSetI(&ITmr, MS2ST(ms), GeneralSequencerTmrCallback, this); }
public:
    void StartSequence(const TChunk *PLedChunk) {
        chSysLock();
 80001ce:	2320      	movs	r3, #32
 80001d0:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:76
        IPStartChunk = PLedChunk;   // Save first chunk
 80001d4:	4b12      	ldr	r3, [pc, #72]	; (8000220 <main+0x100>)
 80001d6:	4620      	mov	r0, r4
 80001d8:	61a3      	str	r3, [r4, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:77
        IPCurrentChunk = PLedChunk;
 80001da:	61e3      	str	r3, [r4, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:78
        IProcessSequenceI();
 80001dc:	6823      	ldr	r3, [r4, #0]
 80001de:	689b      	ldr	r3, [r3, #8]
 80001e0:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:79
        chSysUnlock();
 80001e2:	2300      	movs	r3, #0
 80001e4:	f383 8811 	msr	BASEPRI, r3
main():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:52

    Led.Init();
    Led.StartSequence(lsqFadeIn);

    // Main cycle
    App.ITask();
 80001e8:	4806      	ldr	r0, [pc, #24]	; (8000204 <main+0xe4>)
 80001ea:	f001 fef9 	bl	8001fe0 <App_t::ITask()>
 80001ee:	bf00      	nop
 80001f0:	20000980 	.word	0x20000980
 80001f4:	200009dc 	.word	0x200009dc
 80001f8:	08002a83 	.word	0x08002a83
 80001fc:	20001704 	.word	0x20001704
 8000200:	20000fcc 	.word	0x20000fcc
 8000204:	200016fc 	.word	0x200016fc
 8000208:	08002a94 	.word	0x08002a94
 800020c:	2000169c 	.word	0x2000169c
 8000210:	2000097c 	.word	0x2000097c
 8000214:	40020400 	.word	0x40020400
 8000218:	200016c8 	.word	0x200016c8
 800021c:	08002a30 	.word	0x08002a30
 8000220:	08002ab0 	.word	0x08002ab0
	...

08000230 <_GLOBAL__sub_I_App>:
App_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.h:32
        chEvtSignalI(PThread, Evt);
        chSysUnlock();
    }
    // Inner use
    void ITask();
    App_t(): State(bsIdle), PThread(nullptr) {}
 8000230:	4b13      	ldr	r3, [pc, #76]	; (8000280 <_GLOBAL__sub_I_App+0x50>)
_GLOBAL__sub_I_App():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:91
        if(EvtMsk & EVTMSK_MSNS_OFF) {

        }
#endif
    } // while true
}
 8000232:	b5f0      	push	{r4, r5, r6, r7, lr}
App_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.h:32
 8000234:	2400      	movs	r4, #0
 8000236:	701c      	strb	r4, [r3, #0]
 8000238:	605c      	str	r4, [r3, #4]
Beeper_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:26
        IPin.Set(IPCurrentChunk->Volume);
        IPCurrentChunk++;   // Always goto next
        return sltProceed;  // Always proceed
    }
public:
    Beeper_t() : BaseSequencer_t(), IPin() {}
 800023a:	4a12      	ldr	r2, [pc, #72]	; (8000284 <_GLOBAL__sub_I_App+0x54>)
BaseSequencer_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:71
class BaseSequencer_t : public BaseSequenceProcess_t {
private:
    VirtualTimer ITmr;
protected:
    const TChunk *IPStartChunk, *IPCurrentChunk;
    BaseSequencer_t() : IPStartChunk(nullptr), IPCurrentChunk(nullptr) {}
 800023c:	4b12      	ldr	r3, [pc, #72]	; (8000288 <_GLOBAL__sub_I_App+0x58>)
 800023e:	4e13      	ldr	r6, [pc, #76]	; (800028c <_GLOBAL__sub_I_App+0x5c>)
Beeper_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:26
 8000240:	601a      	str	r2, [r3, #0]
BaseSequencer_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:71
 8000242:	619c      	str	r4, [r3, #24]
 8000244:	61dc      	str	r4, [r3, #28]
Beeper_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:26
 8000246:	621c      	str	r4, [r3, #32]
 8000248:	625c      	str	r4, [r3, #36]	; 0x24
 800024a:	629c      	str	r4, [r3, #40]	; 0x28
LedSmooth_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:173
        else IPCurrentChunk++; // Color is the same, goto next chunk
        return sltProceed;
    }
public:
    LedSmooth_t(const LedChnlTmr_t<LED_TOP_VALUE, LED_INVERTED_PWM> AChnl) :
        BaseSequencer_t(), IChnl(AChnl), ICurrentBrightness(0) {}
 800024c:	4b10      	ldr	r3, [pc, #64]	; (8000290 <_GLOBAL__sub_I_App+0x60>)
 800024e:	4635      	mov	r5, r6
 8000250:	f845 3b20 	str.w	r3, [r5], #32
 8000254:	4b0f      	ldr	r3, [pc, #60]	; (8000294 <_GLOBAL__sub_I_App+0x64>)
_GLOBAL__sub_I_App():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:91
 8000256:	b085      	sub	sp, #20
LedSmooth_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:173
 8000258:	9300      	str	r3, [sp, #0]
 800025a:	2304      	movs	r3, #4
 800025c:	f8ad 3004 	strh.w	r3, [sp, #4]
 8000260:	4b0d      	ldr	r3, [pc, #52]	; (8000298 <_GLOBAL__sub_I_App+0x68>)
 8000262:	af04      	add	r7, sp, #16
 8000264:	9302      	str	r3, [sp, #8]
 8000266:	2301      	movs	r3, #1
 8000268:	9303      	str	r3, [sp, #12]
 800026a:	e917 000f 	ldmdb	r7, {r0, r1, r2, r3}
BaseSequencer_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:71
 800026e:	61b4      	str	r4, [r6, #24]
 8000270:	61f4      	str	r4, [r6, #28]
LedSmooth_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:173
 8000272:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
 8000276:	f886 4030 	strb.w	r4, [r6, #48]	; 0x30
_GLOBAL__sub_I_App():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:91
 800027a:	b005      	add	sp, #20
 800027c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800027e:	bf00      	nop
 8000280:	200016fc 	.word	0x200016fc
 8000284:	080029f8 	.word	0x080029f8
 8000288:	2000169c 	.word	0x2000169c
 800028c:	200016c8 	.word	0x200016c8
 8000290:	08002a18 	.word	0x08002a18
 8000294:	40020400 	.word	0x40020400
 8000298:	40000400 	.word	0x40000400
$d():
 800029c:	00000000 	.word	0x00000000

080002a0 <chEvtSignalI>:
chEvtSignalI():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:251
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(Thread *tp, eventmask_t mask) {
 80002a0:	b538      	push	{r3, r4, r5, lr}
 80002a2:	460d      	mov	r5, r1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:254

  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");
 80002a4:	4604      	mov	r4, r0
 80002a6:	b910      	cbnz	r0, 80002ae <chEvtSignalI+0xe>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:254 (discriminator 1)
 80002a8:	480c      	ldr	r0, [pc, #48]	; (80002dc <chEvtSignalI+0x3c>)
 80002aa:	f001 f9c1 	bl	8001630 <chDbgPanic>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:256

  tp->p_epending |= mask;
 80002ae:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80002b0:	ea45 0103 	orr.w	r1, r5, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:258
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
 80002b4:	7f23      	ldrb	r3, [r4, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:256
void chEvtSignalI(Thread *tp, eventmask_t mask) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
 80002b6:	6261      	str	r1, [r4, #36]	; 0x24
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:258
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
 80002b8:	2b08      	cmp	r3, #8
 80002ba:	d103      	bne.n	80002c4 <chEvtSignalI+0x24>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:259 (discriminator 1)
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 80002bc:	6a23      	ldr	r3, [r4, #32]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:258 (discriminator 1)
  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
 80002be:	4219      	tst	r1, r3
 80002c0:	d106      	bne.n	80002d0 <chEvtSignalI+0x30>
 80002c2:	bd38      	pop	{r3, r4, r5, pc}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:259
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 80002c4:	2b09      	cmp	r3, #9
 80002c6:	d108      	bne.n	80002da <chEvtSignalI+0x3a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:261
      ((tp->p_state == THD_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
 80002c8:	6a23      	ldr	r3, [r4, #32]
 80002ca:	4019      	ands	r1, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:260

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == THD_STATE_WTANDEVT) &&
 80002cc:	4299      	cmp	r1, r3
 80002ce:	d104      	bne.n	80002da <chEvtSignalI+0x3a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:262
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    chSchReadyI(tp)->p_u.rdymsg = RDY_OK;
 80002d0:	4620      	mov	r0, r4
 80002d2:	f000 f835 	bl	8000340 <chSchReadyI>
 80002d6:	2300      	movs	r3, #0
 80002d8:	6203      	str	r3, [r0, #32]
 80002da:	bd38      	pop	{r3, r4, r5, pc}
 80002dc:	0800216a 	.word	0x0800216a

080002e0 <chEvtWaitAny>:
chEvtWaitAny():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:379
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t mask) {
 80002e0:	b538      	push	{r3, r4, r5, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:380
  Thread *ctp = currp;
 80002e2:	4b0b      	ldr	r3, [pc, #44]	; (8000310 <chEvtWaitAny+0x30>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:379
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t mask) {
 80002e4:	4605      	mov	r5, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:380
  Thread *ctp = currp;
 80002e6:	699c      	ldr	r4, [r3, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:383
  eventmask_t m;

  chSysLock();
 80002e8:	2320      	movs	r3, #32
 80002ea:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:385

  if ((m = (ctp->p_epending & mask)) == 0) {
 80002ee:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80002f0:	4028      	ands	r0, r5
 80002f2:	d105      	bne.n	8000300 <chEvtWaitAny+0x20>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:387
    ctp->p_u.ewmask = mask;
    chSchGoSleepS(THD_STATE_WTOREVT);
 80002f4:	2008      	movs	r0, #8
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:386
  eventmask_t m;

  chSysLock();

  if ((m = (ctp->p_epending & mask)) == 0) {
    ctp->p_u.ewmask = mask;
 80002f6:	6225      	str	r5, [r4, #32]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:387
    chSchGoSleepS(THD_STATE_WTOREVT);
 80002f8:	f000 f862 	bl	80003c0 <chSchGoSleepS>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:388
    m = ctp->p_epending & mask;
 80002fc:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80002fe:	4028      	ands	r0, r5
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:390
  }
  ctp->p_epending &= ~m;
 8000300:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000302:	ea23 0300 	bic.w	r3, r3, r0
 8000306:	6263      	str	r3, [r4, #36]	; 0x24
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:392

  chSysUnlock();
 8000308:	2300      	movs	r3, #0
 800030a:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chevents.c:394
  return m;
}
 800030e:	bd38      	pop	{r3, r4, r5, pc}
 8000310:	20001704 	.word	0x20001704
	...

08000320 <_scheduler_init>:
_scheduler_init():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:57
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
 8000320:	4b03      	ldr	r3, [pc, #12]	; (8000330 <_scheduler_init+0x10>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:58
  rlist.r_prio = NOPRIO;
 8000322:	2200      	movs	r2, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:57
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
 8000324:	605b      	str	r3, [r3, #4]
 8000326:	601b      	str	r3, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:58
  rlist.r_prio = NOPRIO;
 8000328:	609a      	str	r2, [r3, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:60
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
 800032a:	615b      	str	r3, [r3, #20]
 800032c:	611b      	str	r3, [r3, #16]
 800032e:	4770      	bx	lr
 8000330:	20001704 	.word	0x20001704
	...

08000340 <chSchReadyI>:
chSchReadyI():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:81
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
 8000340:	b510      	push	{r4, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:87
  Thread *cp;

  chDbgCheckClassI();

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
 8000342:	7f03      	ldrb	r3, [r0, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:81
 * @return              The thread pointer.
 *
 * @iclass
 */
#if !defined(PORT_OPTIMIZED_READYI) || defined(__DOXYGEN__)
Thread *chSchReadyI(Thread *tp) {
 8000344:	4604      	mov	r4, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:87
  Thread *cp;

  chDbgCheckClassI();

  /* Integrity checks.*/
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
 8000346:	b10b      	cbz	r3, 800034c <chSchReadyI+0xc>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:87 (discriminator 2)
 8000348:	2b0e      	cmp	r3, #14
 800034a:	d102      	bne.n	8000352 <chSchReadyI+0x12>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:87 (discriminator 1)
 800034c:	4808      	ldr	r0, [pc, #32]	; (8000370 <chSchReadyI+0x30>)
 800034e:	f001 f96f 	bl	8001630 <chDbgPanic>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:92
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
 8000352:	2300      	movs	r3, #0
 8000354:	7723      	strb	r3, [r4, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:96
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 8000356:	68a1      	ldr	r1, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:93
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
  cp = (Thread *)&rlist.r_queue;
 8000358:	4b06      	ldr	r3, [pc, #24]	; (8000374 <chSchReadyI+0x34>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:95 (discriminator 1)
  do {
    cp = cp->p_next;
 800035a:	681b      	ldr	r3, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:96 (discriminator 1)
  } while (cp->p_prio >= tp->p_prio);
 800035c:	689a      	ldr	r2, [r3, #8]
 800035e:	428a      	cmp	r2, r1
 8000360:	d2fb      	bcs.n	800035a <chSchReadyI+0x1a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:99
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000362:	685a      	ldr	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:98
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000364:	6023      	str	r3, [r4, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:99
  tp->p_prev = cp->p_prev;
 8000366:	6062      	str	r2, [r4, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:102
  tp->p_prev->p_next = cp->p_prev = tp;
  return tp;
}
 8000368:	4620      	mov	r0, r4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:100
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 800036a:	605c      	str	r4, [r3, #4]
 800036c:	6014      	str	r4, [r2, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:102
  return tp;
}
 800036e:	bd10      	pop	{r4, pc}
 8000370:	080021f0 	.word	0x080021f0
 8000374:	20001704 	.word	0x20001704
	...

08000380 <wakeup>:
wakeup():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:136

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000380:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:139
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
 8000382:	2320      	movs	r3, #32
 8000384:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:140
  switch (tp->p_state) {
 8000388:	7f03      	ldrb	r3, [r0, #28]
 800038a:	b183      	cbz	r3, 80003ae <wakeup+0x2e>
 800038c:	2b03      	cmp	r3, #3
 800038e:	d108      	bne.n	80003a2 <wakeup+0x22>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:150
    return;
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
 8000390:	6a03      	ldr	r3, [r0, #32]
 8000392:	689a      	ldr	r2, [r3, #8]
 8000394:	3201      	adds	r2, #1
 8000396:	609a      	str	r2, [r3, #8]
dequeue():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/include/chinline.h:75
  return tp;
}

static INLINE Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000398:	e890 000c 	ldmia.w	r0, {r2, r3}
 800039c:	601a      	str	r2, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/include/chinline.h:76
  tp->p_next->p_prev = tp->p_prev;
 800039e:	6802      	ldr	r2, [r0, #0]
 80003a0:	6053      	str	r3, [r2, #4]
wakeup():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:163
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
 80003a2:	f04f 33ff 	mov.w	r3, #4294967295
 80003a6:	6203      	str	r3, [r0, #32]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:164
  chSchReadyI(tp);
 80003a8:	f7ff ffca 	bl	8000340 <chSchReadyI>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:165
  chSysUnlockFromIsr();
 80003ac:	2300      	movs	r3, #0
 80003ae:	f383 8811 	msr	BASEPRI, r3
 80003b2:	bd08      	pop	{r3, pc}
	...

080003c0 <chSchGoSleepS>:
chSchGoSleepS():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:120
void chSchGoSleepS(tstate_t newstate) {
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 80003c0:	4b06      	ldr	r3, [pc, #24]	; (80003dc <chSchGoSleepS+0x1c>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:124
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
 80003c2:	2214      	movs	r2, #20
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:120
void chSchGoSleepS(tstate_t newstate) {
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 80003c4:	6999      	ldr	r1, [r3, #24]
 80003c6:	7708      	strb	r0, [r1, #28]
fifo_remove():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 80003c8:	6818      	ldr	r0, [r3, #0]
chSchGoSleepS():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:124
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
 80003ca:	778a      	strb	r2, [r1, #30]
fifo_remove():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 80003cc:	6802      	ldr	r2, [r0, #0]
 80003ce:	6053      	str	r3, [r2, #4]
 80003d0:	601a      	str	r2, [r3, #0]
chSchGoSleepS():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:126
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
 80003d2:	6198      	str	r0, [r3, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:127
  currp->p_state = THD_STATE_CURRENT;
 80003d4:	2301      	movs	r3, #1
 80003d6:	7703      	strb	r3, [r0, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:128
  chSysSwitch(currp, otp);
 80003d8:	f000 ba5a 	b.w	8000890 <_port_switch>
 80003dc:	20001704 	.word	0x20001704

080003e0 <chSchGoSleepTimeoutS>:
chSchGoSleepTimeoutS():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:189
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80003e0:	b530      	push	{r4, r5, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:193

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80003e2:	1c4b      	adds	r3, r1, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:189
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80003e4:	b087      	sub	sp, #28
 80003e6:	4605      	mov	r5, r0
 80003e8:	4c0a      	ldr	r4, [pc, #40]	; (8000414 <chSchGoSleepTimeoutS+0x34>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:193

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80003ea:	d00d      	beq.n	8000408 <chSchGoSleepTimeoutS+0x28>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:196
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
 80003ec:	69a3      	ldr	r3, [r4, #24]
 80003ee:	a801      	add	r0, sp, #4
 80003f0:	4a09      	ldr	r2, [pc, #36]	; (8000418 <chSchGoSleepTimeoutS+0x38>)
 80003f2:	f000 f985 	bl	8000700 <chVTSetI>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:197
    chSchGoSleepS(newstate);
 80003f6:	4628      	mov	r0, r5
 80003f8:	f7ff ffe2 	bl	80003c0 <chSchGoSleepS>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:198
    if (chVTIsArmedI(&vt))
 80003fc:	9b04      	ldr	r3, [sp, #16]
 80003fe:	b12b      	cbz	r3, 800040c <chSchGoSleepTimeoutS+0x2c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:199
      chVTResetI(&vt);
 8000400:	a801      	add	r0, sp, #4
 8000402:	f000 f9a5 	bl	8000750 <chVTResetI>
 8000406:	e001      	b.n	800040c <chSchGoSleepTimeoutS+0x2c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:202
  }
  else
    chSchGoSleepS(newstate);
 8000408:	f7ff ffda 	bl	80003c0 <chSchGoSleepS>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:203
  return currp->p_u.rdymsg;
 800040c:	69a3      	ldr	r3, [r4, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:204
}
 800040e:	6a18      	ldr	r0, [r3, #32]
 8000410:	b007      	add	sp, #28
 8000412:	bd30      	pop	{r4, r5, pc}
 8000414:	20001704 	.word	0x20001704
 8000418:	08000381 	.word	0x08000381
$d():
 800041c:	00000000 	.word	0x00000000

08000420 <chSchWakeupS>:
chSchWakeupS():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:225
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
 8000420:	b538      	push	{r3, r4, r5, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:234
  ntp->p_u.rdymsg = msg;
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 8000422:	4d0c      	ldr	r5, [pc, #48]	; (8000454 <chSchWakeupS+0x34>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:229
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
 8000424:	6201      	str	r1, [r0, #32]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:234
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 8000426:	69ab      	ldr	r3, [r5, #24]
 8000428:	6881      	ldr	r1, [r0, #8]
 800042a:	689a      	ldr	r2, [r3, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:225
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
 800042c:	4604      	mov	r4, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:234
  ntp->p_u.rdymsg = msg;
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 800042e:	4291      	cmp	r1, r2
 8000430:	d803      	bhi.n	800043a <chSchWakeupS+0x1a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:242
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 8000432:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:235
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
 8000436:	f7ff bf83 	b.w	8000340 <chSchReadyI>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:237
  else {
    Thread *otp = chSchReadyI(currp);
 800043a:	4618      	mov	r0, r3
 800043c:	f7ff ff80 	bl	8000340 <chSchReadyI>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:239
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
 8000440:	2301      	movs	r3, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:237
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
 8000442:	4601      	mov	r1, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:238
    setcurrp(ntp);
 8000444:	61ac      	str	r4, [r5, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:239
    ntp->p_state = THD_STATE_CURRENT;
 8000446:	7723      	strb	r3, [r4, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:240
    chSysSwitch(ntp, otp);
 8000448:	4620      	mov	r0, r4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:242
  }
}
 800044a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:240
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 800044e:	f000 ba1f 	b.w	8000890 <_port_switch>
 8000452:	bf00      	nop
 8000454:	20001704 	.word	0x20001704
	...

08000460 <chSchDoRescheduleBehind>:
chSchDoRescheduleBehind():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:304
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
 8000460:	b538      	push	{r3, r4, r5, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:307
  Thread *otp;

  otp = currp;
 8000462:	4c0a      	ldr	r4, [pc, #40]	; (800048c <chSchDoRescheduleBehind+0x2c>)
fifo_remove():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 8000464:	6823      	ldr	r3, [r4, #0]
chSchDoRescheduleBehind():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:307
 8000466:	69a5      	ldr	r5, [r4, #24]
fifo_remove():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 8000468:	681a      	ldr	r2, [r3, #0]
chSchDoRescheduleBehind():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:314
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
 800046a:	4628      	mov	r0, r5
fifo_remove():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/include/chinline.h:62
 800046c:	6054      	str	r4, [r2, #4]
 800046e:	6022      	str	r2, [r4, #0]
chSchDoRescheduleBehind():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:310
  Thread *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
 8000470:	2201      	movs	r2, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:309
void chSchDoRescheduleBehind(void) {
  Thread *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 8000472:	61a3      	str	r3, [r4, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:310
  currp->p_state = THD_STATE_CURRENT;
 8000474:	771a      	strb	r2, [r3, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:312
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
 8000476:	2314      	movs	r3, #20
 8000478:	77ab      	strb	r3, [r5, #30]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:314
#endif
  chSchReadyI(otp);
 800047a:	f7ff ff61 	bl	8000340 <chSchReadyI>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:315
  chSysSwitch(currp, otp);
 800047e:	69a0      	ldr	r0, [r4, #24]
 8000480:	4629      	mov	r1, r5
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:316
}
 8000482:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:315
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
 8000486:	f000 ba03 	b.w	8000890 <_port_switch>
 800048a:	bf00      	nop
 800048c:	20001704 	.word	0x20001704

08000490 <chSchDoRescheduleAhead>:
chSchDoRescheduleAhead():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:332
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
  Thread *otp, *cp;

  otp = currp;
 8000490:	4b0c      	ldr	r3, [pc, #48]	; (80004c4 <chSchDoRescheduleAhead+0x34>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:329
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
 8000492:	b510      	push	{r4, lr}
fifo_remove():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/include/chinline.h:60
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static INLINE Thread *fifo_remove(ThreadsQueue *tqp) {
  Thread *tp = tqp->p_next;
 8000494:	6818      	ldr	r0, [r3, #0]
chSchDoRescheduleAhead():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:332
  Thread *otp, *cp;

  otp = currp;
 8000496:	6999      	ldr	r1, [r3, #24]
fifo_remove():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/include/chinline.h:62

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 8000498:	6802      	ldr	r2, [r0, #0]
chSchDoRescheduleAhead():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:341

  otp->p_state = THD_STATE_READY;
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 800049a:	688c      	ldr	r4, [r1, #8]
fifo_remove():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/include/chinline.h:62
 800049c:	6053      	str	r3, [r2, #4]
 800049e:	601a      	str	r2, [r3, #0]
chSchDoRescheduleAhead():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:335
  Thread *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
  currp->p_state = THD_STATE_CURRENT;
 80004a0:	2201      	movs	r2, #1
 80004a2:	7702      	strb	r2, [r0, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:337

  otp->p_state = THD_STATE_READY;
 80004a4:	2200      	movs	r2, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:334
void chSchDoRescheduleAhead(void) {
  Thread *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 80004a6:	6198      	str	r0, [r3, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:337
  currp->p_state = THD_STATE_CURRENT;

  otp->p_state = THD_STATE_READY;
 80004a8:	770a      	strb	r2, [r1, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:340 (discriminator 1)
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
 80004aa:	681b      	ldr	r3, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:341 (discriminator 1)
  } while (cp->p_prio > otp->p_prio);
 80004ac:	689a      	ldr	r2, [r3, #8]
 80004ae:	42a2      	cmp	r2, r4
 80004b0:	d8fb      	bhi.n	80004aa <chSchDoRescheduleAhead+0x1a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:344
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 80004b2:	685a      	ldr	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:343
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 80004b4:	600b      	str	r3, [r1, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:344
  otp->p_prev = cp->p_prev;
 80004b6:	604a      	str	r2, [r1, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:348
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
}
 80004b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:345
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;
 80004bc:	6059      	str	r1, [r3, #4]
 80004be:	6011      	str	r1, [r2, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:347

  chSysSwitch(currp, otp);
 80004c0:	f000 b9e6 	b.w	8000890 <_port_switch>
 80004c4:	20001704 	.word	0x20001704
	...

080004d0 <chSchDoReschedule>:
chSchDoReschedule():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:367
void chSchDoReschedule(void) {

#if CH_TIME_QUANTUM > 0
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
 80004d0:	4b03      	ldr	r3, [pc, #12]	; (80004e0 <chSchDoReschedule+0x10>)
 80004d2:	699b      	ldr	r3, [r3, #24]
 80004d4:	7f9b      	ldrb	r3, [r3, #30]
 80004d6:	b90b      	cbnz	r3, 80004dc <chSchDoReschedule+0xc>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:370
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
 80004d8:	f7ff bfc2 	b.w	8000460 <chSchDoRescheduleBehind>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chschd.c:375
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
 80004dc:	f7ff bfd8 	b.w	8000490 <chSchDoRescheduleAhead>
 80004e0:	20001704 	.word	0x20001704
	...

080004f0 <_idle_thread>:
_idle_thread():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:64
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
 80004f0:	4b02      	ldr	r3, [pc, #8]	; (80004fc <_idle_thread+0xc>)
 80004f2:	4a03      	ldr	r2, [pc, #12]	; (8000500 <_idle_thread+0x10>)
 80004f4:	699b      	ldr	r3, [r3, #24]
 80004f6:	619a      	str	r2, [r3, #24]
 80004f8:	e7fe      	b.n	80004f8 <_idle_thread+0x8>
 80004fa:	bf00      	nop
 80004fc:	20001704 	.word	0x20001704
 8000500:	08002210 	.word	0x08002210
	...

08000510 <chSysInit>:
chSysInit():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:84
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
 8000510:	b507      	push	{r0, r1, r2, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:90
  static Thread mainthread;
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 8000512:	f000 f955 	bl	80007c0 <_port_init>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:91
  _scheduler_init();
 8000516:	f7ff ff03 	bl	8000320 <_scheduler_init>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:92
  _vt_init();
 800051a:	f000 f8e1 	bl	80006e0 <_vt_init>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:104
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
 800051e:	2140      	movs	r1, #64	; 0x40
 8000520:	480c      	ldr	r0, [pc, #48]	; (8000554 <chSysInit+0x44>)
 8000522:	f000 f84d 	bl	80005c0 <_thread_init>
 8000526:	4b0c      	ldr	r3, [pc, #48]	; (8000558 <chSysInit+0x48>)
 8000528:	6198      	str	r0, [r3, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:105
  currp->p_state = THD_STATE_CURRENT;
 800052a:	2301      	movs	r3, #1
 800052c:	7703      	strb	r3, [r0, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:111
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
 800052e:	2300      	movs	r3, #0
 8000530:	f383 8811 	msr	BASEPRI, r3
 8000534:	b662      	cpsie	i
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:115

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 8000536:	4b08      	ldr	r3, [pc, #32]	; (8000558 <chSysInit+0x48>)
 8000538:	4a08      	ldr	r2, [pc, #32]	; (800055c <chSysInit+0x4c>)
 800053a:	699b      	ldr	r3, [r3, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:121

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
 800053c:	21a0      	movs	r1, #160	; 0xa0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:115
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 800053e:	619a      	str	r2, [r3, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:121

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
 8000540:	2300      	movs	r3, #0
 8000542:	9300      	str	r3, [sp, #0]
 8000544:	2201      	movs	r2, #1
 8000546:	4b06      	ldr	r3, [pc, #24]	; (8000560 <chSysInit+0x50>)
 8000548:	4806      	ldr	r0, [pc, #24]	; (8000564 <chSysInit+0x54>)
 800054a:	f000 f879 	bl	8000640 <chThdCreateStatic>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:124
                    (tfunc_t)_idle_thread, NULL);
#endif
}
 800054e:	b003      	add	sp, #12
 8000550:	f85d fb04 	ldr.w	pc, [sp], #4
 8000554:	20000800 	.word	0x20000800
 8000558:	20001704 	.word	0x20001704
 800055c:	080021d0 	.word	0x080021d0
 8000560:	080004f1 	.word	0x080004f1
 8000564:	20001720 	.word	0x20001720
	...

08000570 <chSysTimerHandlerI>:
chSysTimerHandlerI():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:137
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000570:	b538      	push	{r3, r4, r5, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:143

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
 8000572:	4b11      	ldr	r3, [pc, #68]	; (80005b8 <chSysTimerHandlerI+0x48>)
 8000574:	699b      	ldr	r3, [r3, #24]
 8000576:	7f9a      	ldrb	r2, [r3, #30]
 8000578:	b10a      	cbz	r2, 800057e <chSysTimerHandlerI+0xe>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:145
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 800057a:	3a01      	subs	r2, #1
 800057c:	779a      	strb	r2, [r3, #30]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:150
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
#endif
  chVTDoTickI();
 800057e:	4b0f      	ldr	r3, [pc, #60]	; (80005bc <chSysTimerHandlerI+0x4c>)
 8000580:	68da      	ldr	r2, [r3, #12]
 8000582:	461c      	mov	r4, r3
 8000584:	3201      	adds	r2, #1
 8000586:	60da      	str	r2, [r3, #12]
 8000588:	681a      	ldr	r2, [r3, #0]
 800058a:	429a      	cmp	r2, r3
 800058c:	d013      	beq.n	80005b6 <chSysTimerHandlerI+0x46>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:150 (discriminator 1)
 800058e:	6891      	ldr	r1, [r2, #8]
 8000590:	3901      	subs	r1, #1
 8000592:	6091      	str	r1, [r2, #8]
 8000594:	6822      	ldr	r2, [r4, #0]
 8000596:	4909      	ldr	r1, [pc, #36]	; (80005bc <chSysTimerHandlerI+0x4c>)
 8000598:	6893      	ldr	r3, [r2, #8]
 800059a:	b963      	cbnz	r3, 80005b6 <chSysTimerHandlerI+0x46>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chsys.c:150 (discriminator 2)
 800059c:	6810      	ldr	r0, [r2, #0]
 800059e:	68d5      	ldr	r5, [r2, #12]
 80005a0:	6008      	str	r0, [r1, #0]
 80005a2:	60d3      	str	r3, [r2, #12]
 80005a4:	6041      	str	r1, [r0, #4]
 80005a6:	f383 8811 	msr	BASEPRI, r3
 80005aa:	6910      	ldr	r0, [r2, #16]
 80005ac:	47a8      	blx	r5
 80005ae:	2320      	movs	r3, #32
 80005b0:	f383 8811 	msr	BASEPRI, r3
 80005b4:	e7ee      	b.n	8000594 <chSysTimerHandlerI+0x24>
 80005b6:	bd38      	pop	{r3, r4, r5, pc}
 80005b8:	20001704 	.word	0x20001704
 80005bc:	200017c0 	.word	0x200017c0

080005c0 <_thread_init>:
_thread_init():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:79
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = THD_STATE_SUSPENDED;
 80005c0:	2202      	movs	r2, #2
 80005c2:	7702      	strb	r2, [r0, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:80
  tp->p_flags = THD_MEM_MODE_STATIC;
 80005c4:	2200      	movs	r2, #0
 80005c6:	7742      	strb	r2, [r0, #29]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:89
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
 80005c8:	6242      	str	r2, [r0, #36]	; 0x24
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:98
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
 80005ca:	6182      	str	r2, [r0, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:99
  REG_INSERT(tp);
 80005cc:	4a04      	ldr	r2, [pc, #16]	; (80005e0 <_thread_init+0x20>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:78
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
 80005ce:	6081      	str	r1, [r0, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:82
  tp->p_state = THD_STATE_SUSPENDED;
  tp->p_flags = THD_MEM_MODE_STATIC;
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
 80005d0:	2114      	movs	r1, #20
 80005d2:	7781      	strb	r1, [r0, #30]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:99
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80005d4:	6951      	ldr	r1, [r2, #20]
 80005d6:	6102      	str	r2, [r0, #16]
 80005d8:	6141      	str	r1, [r0, #20]
 80005da:	6150      	str	r0, [r2, #20]
 80005dc:	6108      	str	r0, [r1, #16]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:114
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
}
 80005de:	4770      	bx	lr
 80005e0:	20001704 	.word	0x20001704
	...

080005f0 <chThdCreateI>:
chThdCreateI():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:158
 *                      the thread into the working space area.
 *
 * @iclass
 */
Thread *chThdCreateI(void *wsp, size_t size,
                     tprio_t prio, tfunc_t pf, void *arg) {
 80005f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80005f4:	f8dd 8018 	ldr.w	r8, [sp, #24]
 80005f8:	460d      	mov	r5, r1
 80005fa:	4616      	mov	r6, r2
 80005fc:	461f      	mov	r7, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:164
  /* Thread structure is laid out in the lower part of the thread workspace.*/
  Thread *tp = wsp;

  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
 80005fe:	4604      	mov	r4, r0
 8000600:	b120      	cbz	r0, 800060c <chThdCreateI+0x1c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:164 (discriminator 2)
 8000602:	298f      	cmp	r1, #143	; 0x8f
 8000604:	d902      	bls.n	800060c <chThdCreateI+0x1c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:164 (discriminator 1)
 8000606:	2a7f      	cmp	r2, #127	; 0x7f
 8000608:	d800      	bhi.n	800060c <chThdCreateI+0x1c>
 800060a:	b913      	cbnz	r3, 8000612 <chThdCreateI+0x22>
 800060c:	4808      	ldr	r0, [pc, #32]	; (8000630 <chThdCreateI+0x40>)
 800060e:	f001 f80f 	bl	8001630 <chDbgPanic>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:167
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
 8000612:	3d24      	subs	r5, #36	; 0x24
 8000614:	4b07      	ldr	r3, [pc, #28]	; (8000634 <chThdCreateI+0x44>)
 8000616:	1960      	adds	r0, r4, r5
 8000618:	60e0      	str	r0, [r4, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:168
  return _thread_init(tp, prio);
 800061a:	4631      	mov	r1, r6
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:167
  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
 800061c:	5167      	str	r7, [r4, r5]
 800061e:	f8c0 8004 	str.w	r8, [r0, #4]
 8000622:	6203      	str	r3, [r0, #32]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:168
  return _thread_init(tp, prio);
 8000624:	4620      	mov	r0, r4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:169
}
 8000626:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:168

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
  return _thread_init(tp, prio);
 800062a:	f7ff bfc9 	b.w	80005c0 <_thread_init>
 800062e:	bf00      	nop
 8000630:	08002220 	.word	0x08002220
 8000634:	080008a1 	.word	0x080008a1
	...

08000640 <chThdCreateStatic>:
chThdCreateStatic():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:188
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
 8000640:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8000642:	461d      	mov	r5, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:199
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
 8000644:	2320      	movs	r3, #32
 8000646:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:200
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
 800064a:	9c06      	ldr	r4, [sp, #24]
 800064c:	462b      	mov	r3, r5
 800064e:	9400      	str	r4, [sp, #0]
 8000650:	f7ff ffce 	bl	80005f0 <chThdCreateI>
 8000654:	2100      	movs	r1, #0
 8000656:	4604      	mov	r4, r0
 8000658:	f7ff fee2 	bl	8000420 <chSchWakeupS>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:201
  chSysUnlock();
 800065c:	2300      	movs	r3, #0
 800065e:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:203
  return tp;
}
 8000662:	4620      	mov	r0, r4
 8000664:	b003      	add	sp, #12
 8000666:	bd30      	pop	{r4, r5, pc}
	...

08000670 <chThdSleep>:
chThdSleep():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:292
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000670:	b510      	push	{r4, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:294

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");
 8000672:	4604      	mov	r4, r0
 8000674:	b910      	cbnz	r0, 800067c <chThdSleep+0xc>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:294 (discriminator 1)
 8000676:	4807      	ldr	r0, [pc, #28]	; (8000694 <chThdSleep+0x24>)
 8000678:	f000 ffda 	bl	8001630 <chDbgPanic>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:296

  chSysLock();
 800067c:	2320      	movs	r3, #32
 800067e:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:297
  chThdSleepS(time);
 8000682:	2006      	movs	r0, #6
 8000684:	4621      	mov	r1, r4
 8000686:	f7ff feab 	bl	80003e0 <chSchGoSleepTimeoutS>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:298
  chSysUnlock();
 800068a:	2300      	movs	r3, #0
 800068c:	f383 8811 	msr	BASEPRI, r3
 8000690:	bd10      	pop	{r4, pc}
 8000692:	bf00      	nop
 8000694:	08002258 	.word	0x08002258
	...

080006a0 <chThdExitS>:
chThdExitS():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:366
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 80006a0:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:367
  Thread *tp = currp;
 80006a2:	4b09      	ldr	r3, [pc, #36]	; (80006c8 <chThdExitS+0x28>)
 80006a4:	699b      	ldr	r3, [r3, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:380
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
 80006a6:	7f5a      	ldrb	r2, [r3, #29]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:369
 * @sclass
 */
void chThdExitS(msg_t msg) {
  Thread *tp = currp;

  tp->p_u.exitcode = msg;
 80006a8:	6218      	str	r0, [r3, #32]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:380
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
 80006aa:	0792      	lsls	r2, r2, #30
 80006ac:	d104      	bne.n	80006b8 <chThdExitS+0x18>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:381
    REG_REMOVE(tp);
 80006ae:	695a      	ldr	r2, [r3, #20]
 80006b0:	6919      	ldr	r1, [r3, #16]
 80006b2:	6111      	str	r1, [r2, #16]
 80006b4:	691b      	ldr	r3, [r3, #16]
 80006b6:	615a      	str	r2, [r3, #20]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:383
#endif
  chSchGoSleepS(THD_STATE_FINAL);
 80006b8:	200e      	movs	r0, #14
 80006ba:	f7ff fe81 	bl	80003c0 <chSchGoSleepS>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:386
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
 80006be:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:385
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
    REG_REMOVE(tp);
#endif
  chSchGoSleepS(THD_STATE_FINAL);
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
 80006c2:	4802      	ldr	r0, [pc, #8]	; (80006cc <chThdExitS+0x2c>)
 80006c4:	f000 bfb4 	b.w	8001630 <chDbgPanic>
 80006c8:	20001704 	.word	0x20001704
 80006cc:	08002267 	.word	0x08002267

080006d0 <chThdExit>:
chThdExit():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:347
 *
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
 80006d0:	2320      	movs	r3, #32
 80006d2:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chthreads.c:348
  chThdExitS(msg);
 80006d6:	f7ff bfe3 	b.w	80006a0 <chThdExitS>
 80006da:	0000      	movs	r0, r0
 80006dc:	0000      	movs	r0, r0
	...

080006e0 <_vt_init>:
_vt_init():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:52
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
 80006e0:	4b04      	ldr	r3, [pc, #16]	; (80006f4 <_vt_init+0x14>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:53
  vtlist.vt_time = (systime_t)-1;
 80006e2:	f04f 32ff 	mov.w	r2, #4294967295
 80006e6:	609a      	str	r2, [r3, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:54
  vtlist.vt_systime = 0;
 80006e8:	2200      	movs	r2, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:52
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
 80006ea:	605b      	str	r3, [r3, #4]
 80006ec:	601b      	str	r3, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:54
  vtlist.vt_time = (systime_t)-1;
  vtlist.vt_systime = 0;
 80006ee:	60da      	str	r2, [r3, #12]
 80006f0:	4770      	bx	lr
 80006f2:	bf00      	nop
 80006f4:	200017c0 	.word	0x200017c0
	...

08000700 <chVTSetI>:
chVTSetI():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:76
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
 8000700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000702:	460d      	mov	r5, r1
 8000704:	4616      	mov	r6, r2
 8000706:	461f      	mov	r7, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:80
  VirtualTimer *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
 8000708:	4604      	mov	r4, r0
 800070a:	b108      	cbz	r0, 8000710 <chVTSetI+0x10>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:80 (discriminator 2)
 800070c:	b102      	cbz	r2, 8000710 <chVTSetI+0x10>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:80 (discriminator 1)
 800070e:	b911      	cbnz	r1, 8000716 <chVTSetI+0x16>
 8000710:	480c      	ldr	r0, [pc, #48]	; (8000744 <chVTSetI+0x44>)
 8000712:	f000 ff8d 	bl	8001630 <chDbgPanic>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:85
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
 8000716:	4a0c      	ldr	r2, [pc, #48]	; (8000748 <chVTSetI+0x48>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:83

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
 8000718:	6127      	str	r7, [r4, #16]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:85
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
 800071a:	6813      	ldr	r3, [r2, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:84
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 800071c:	60e6      	str	r6, [r4, #12]
 800071e:	4611      	mov	r1, r2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:86 (discriminator 1)
  p = vtlist.vt_next;
  while (p->vt_time < time) {
 8000720:	689a      	ldr	r2, [r3, #8]
 8000722:	42aa      	cmp	r2, r5
 8000724:	d202      	bcs.n	800072c <chVTSetI+0x2c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:87
    time -= p->vt_time;
 8000726:	1aad      	subs	r5, r5, r2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:88
    p = p->vt_next;
 8000728:	681b      	ldr	r3, [r3, #0]
 800072a:	e7f9      	b.n	8000720 <chVTSetI+0x20>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:91
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 800072c:	685a      	ldr	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:94
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
  vtp->vt_time = time;
  if (p != (void *)&vtlist)
 800072e:	428b      	cmp	r3, r1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:91
  while (p->vt_time < time) {
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 8000730:	6023      	str	r3, [r4, #0]
 8000732:	6062      	str	r2, [r4, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:92
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
 8000734:	605c      	str	r4, [r3, #4]
 8000736:	6014      	str	r4, [r2, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:93
  vtp->vt_time = time;
 8000738:	60a5      	str	r5, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:94
  if (p != (void *)&vtlist)
 800073a:	d002      	beq.n	8000742 <chVTSetI+0x42>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:95
    p->vt_time -= time;
 800073c:	689a      	ldr	r2, [r3, #8]
 800073e:	1b55      	subs	r5, r2, r5
 8000740:	609d      	str	r5, [r3, #8]
 8000742:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000744:	08002280 	.word	0x08002280
 8000748:	200017c0 	.word	0x200017c0
$d():
 800074c:	00000000 	.word	0x00000000

08000750 <chVTResetI>:
chVTResetI():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:106
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
 8000750:	b510      	push	{r4, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:109

  chDbgCheckClassI();
  chDbgCheck(vtp != NULL, "chVTResetI");
 8000752:	4604      	mov	r4, r0
 8000754:	b910      	cbnz	r0, 800075c <chVTResetI+0xc>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:109 (discriminator 1)
 8000756:	480b      	ldr	r0, [pc, #44]	; (8000784 <chVTResetI+0x34>)
 8000758:	f000 ff6a 	bl	8001630 <chDbgPanic>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:110
  chDbgAssert(vtp->vt_func != NULL,
 800075c:	68e3      	ldr	r3, [r4, #12]
 800075e:	b913      	cbnz	r3, 8000766 <chVTResetI+0x16>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:110 (discriminator 1)
 8000760:	4809      	ldr	r0, [pc, #36]	; (8000788 <chVTResetI+0x38>)
 8000762:	f000 ff65 	bl	8001630 <chDbgPanic>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:114
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
 8000766:	6823      	ldr	r3, [r4, #0]
 8000768:	4a08      	ldr	r2, [pc, #32]	; (800078c <chVTResetI+0x3c>)
 800076a:	4293      	cmp	r3, r2
 800076c:	d003      	beq.n	8000776 <chVTResetI+0x26>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:115
    vtp->vt_next->vt_time += vtp->vt_time;
 800076e:	6899      	ldr	r1, [r3, #8]
 8000770:	68a2      	ldr	r2, [r4, #8]
 8000772:	440a      	add	r2, r1
 8000774:	609a      	str	r2, [r3, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:116
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000776:	6862      	ldr	r2, [r4, #4]
 8000778:	6013      	str	r3, [r2, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:117
  vtp->vt_next->vt_prev = vtp->vt_prev;
 800077a:	6823      	ldr	r3, [r4, #0]
 800077c:	605a      	str	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/kernel/src/chvt.c:118
  vtp->vt_func = (vtfunc_t)NULL;
 800077e:	2300      	movs	r3, #0
 8000780:	60e3      	str	r3, [r4, #12]
 8000782:	bd10      	pop	{r4, pc}
 8000784:	0800228d 	.word	0x0800228d
 8000788:	0800229c 	.word	0x0800229c
 800078c:	200017c0 	.word	0x200017c0

08000790 <_port_switch_from_isr>:
_port_switch_from_isr():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:210
__attribute__((naked))
#endif
void _port_switch_from_isr(void) {

  dbg_check_lock();
  chSchDoReschedule();
 8000790:	f7ff fe9e 	bl	80004d0 <chSchDoReschedule>

08000794 <_port_exit_from_isr>:
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:214
  dbg_check_unlock();
  asm volatile ("_port_exit_from_isr:" : : : "memory");
#if !CORTEX_SIMPLIFIED_PRIORITY || defined(__DOXYGEN__)
  asm volatile ("svc     #0");
 8000794:	df00      	svc	0
	...

080007a0 <SVCallVector>:
SVCallVector():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:69
 */
void SVCallVector(void) {
  struct extctx *ctxp;

  /* Current PSP value.*/
  asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
 80007a0:	f3ef 8309 	mrs	r3, PSP
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:73

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80007a4:	3320      	adds	r3, #32
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:80
#if CORTEX_USE_FPU
  /* Restoring the special register SCB_FPCCR.*/
  SCB_FPCCR = (uint32_t)ctxp->fpccr;
  SCB_FPCAR = SCB_FPCAR + sizeof (struct extctx);
#endif
  asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
 80007a6:	f383 8809 	msr	PSP, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:81
  port_unlock_from_isr();
 80007aa:	2300      	movs	r3, #0
 80007ac:	f383 8811 	msr	BASEPRI, r3
 80007b0:	4770      	bx	lr
	...

080007c0 <_port_init>:
_port_init():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:118
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
void _port_init(void) {
 80007c0:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:121

  /* Initialization of the vector table and priority related settings.*/
  SCB_VTOR = CORTEX_VTOR_INIT;
 80007c2:	4b0a      	ldr	r3, [pc, #40]	; (80007ec <_port_init+0x2c>)
 80007c4:	2200      	movs	r2, #0
 80007c6:	609a      	str	r2, [r3, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:122
  SCB_AIRCR = AIRCR_VECTKEY | AIRCR_PRIGROUP(CORTEX_PRIGROUP_INIT);
 80007c8:	4a09      	ldr	r2, [pc, #36]	; (80007f0 <_port_init+0x30>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:125

  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
 80007ca:	2007      	movs	r0, #7
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:122
 */
void _port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB_VTOR = CORTEX_VTOR_INIT;
  SCB_AIRCR = AIRCR_VECTKEY | AIRCR_PRIGROUP(CORTEX_PRIGROUP_INIT);
 80007cc:	60da      	str	r2, [r3, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:125

  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
 80007ce:	2110      	movs	r1, #16
 80007d0:	f000 f94e 	bl	8000a70 <nvicSetSystemHandlerPriority>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:127
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SVCALL));
  nvicSetSystemHandlerPriority(HANDLER_PENDSV,
 80007d4:	200a      	movs	r0, #10
 80007d6:	f44f 7100 	mov.w	r1, #512	; 0x200
 80007da:	f000 f949 	bl	8000a70 <nvicSetSystemHandlerPriority>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:131
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_PENDSV));
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SYSTICK));
}
 80007de:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:129
  /* Initialization of the system vectors used by the port.*/
  nvicSetSystemHandlerPriority(HANDLER_SVCALL,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_SVCALL));
  nvicSetSystemHandlerPriority(HANDLER_PENDSV,
    CORTEX_PRIORITY_MASK(CORTEX_PRIORITY_PENDSV));
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK,
 80007e2:	200b      	movs	r0, #11
 80007e4:	2180      	movs	r1, #128	; 0x80
 80007e6:	f000 b943 	b.w	8000a70 <nvicSetSystemHandlerPriority>
 80007ea:	bf00      	nop
 80007ec:	e000ed00 	.word	0xe000ed00
 80007f0:	05fa0300 	.word	0x05fa0300
	...

08000800 <_port_irq_epilogue>:
_port_irq_epilogue():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:150
/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
 8000800:	2320      	movs	r3, #32
 8000802:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:151
  if ((SCB_ICSR & ICSR_RETTOBASE) != 0) {
 8000806:	4b14      	ldr	r3, [pc, #80]	; (8000858 <_port_irq_epilogue+0x58>)
 8000808:	685b      	ldr	r3, [r3, #4]
 800080a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800080e:	d020      	beq.n	8000852 <_port_irq_epilogue+0x52>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:155
    struct extctx *ctxp;

    /* Current PSP value.*/
    asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
 8000810:	f3ef 8309 	mrs	r3, PSP
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:159

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000814:	f1a3 0220 	sub.w	r2, r3, #32
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:160
    asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
 8000818:	f382 8809 	msr	PSP, r2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:161
    ctxp->xpsr = (regarm_t)0x01000000;
 800081c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000820:	f843 2c04 	str.w	r2, [r3, #-4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:165

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000824:	4a0d      	ldr	r2, [pc, #52]	; (800085c <_port_irq_epilogue+0x5c>)
 8000826:	6991      	ldr	r1, [r2, #24]
 8000828:	6812      	ldr	r2, [r2, #0]
 800082a:	7f88      	ldrb	r0, [r1, #30]
 800082c:	6892      	ldr	r2, [r2, #8]
 800082e:	6889      	ldr	r1, [r1, #8]
 8000830:	b120      	cbz	r0, 800083c <_port_irq_epilogue+0x3c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:165 (discriminator 1)
 8000832:	428a      	cmp	r2, r1
 8000834:	bf94      	ite	ls
 8000836:	2200      	movls	r2, #0
 8000838:	2201      	movhi	r2, #1
 800083a:	e003      	b.n	8000844 <_port_irq_epilogue+0x44>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:165 (discriminator 2)
 800083c:	428a      	cmp	r2, r1
 800083e:	bf34      	ite	cc
 8000840:	2200      	movcc	r2, #0
 8000842:	2201      	movcs	r2, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:165 (discriminator 3)
 8000844:	b10a      	cbz	r2, 800084a <_port_irq_epilogue+0x4a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:167
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (void *)_port_switch_from_isr;
 8000846:	4a06      	ldr	r2, [pc, #24]	; (8000860 <_port_irq_epilogue+0x60>)
 8000848:	e000      	b.n	800084c <_port_irq_epilogue+0x4c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:176
#endif
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (void *)_port_exit_from_isr;
 800084a:	4a06      	ldr	r2, [pc, #24]	; (8000864 <_port_irq_epilogue+0x64>)
 800084c:	f843 2c08 	str.w	r2, [r3, #-8]
 8000850:	4770      	bx	lr
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:197

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 8000852:	f383 8811 	msr	BASEPRI, r3
 8000856:	4770      	bx	lr
 8000858:	e000ed00 	.word	0xe000ed00
 800085c:	20001704 	.word	0x20001704
 8000860:	08000791 	.word	0x08000791
 8000864:	08000794 	.word	0x08000794
	...

08000870 <SysTickVector>:
SysTickVector():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:47
/**
 * @brief   System Timer vector.
 * @details This interrupt is used as system tick.
 * @note    The timer must be initialized in the startup code.
 */
CH_IRQ_HANDLER(SysTickVector) {
 8000870:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:51

  CH_IRQ_PROLOGUE();

  chSysLockFromIsr();
 8000872:	2320      	movs	r3, #32
 8000874:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:52
  chSysTimerHandlerI();
 8000878:	f7ff fe7a 	bl	8000570 <chSysTimerHandlerI>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:53
  chSysUnlockFromIsr();
 800087c:	2300      	movs	r3, #0
 800087e:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:56

  CH_IRQ_EPILOGUE();
}
 8000882:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:55

  chSysLockFromIsr();
  chSysTimerHandlerI();
  chSysUnlockFromIsr();

  CH_IRQ_EPILOGUE();
 8000886:	f7ff bfbb 	b.w	8000800 <_port_irq_epilogue>
 800088a:	0000      	movs	r0, r0
 800088c:	0000      	movs	r0, r0
	...

08000890 <_port_switch>:
_port_switch():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:238
#if !defined(__DOXYGEN__)
__attribute__((naked))
#endif
void _port_switch(Thread *ntp, Thread *otp) {

  asm volatile ("push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}"
 8000890:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:244
                : : : "memory");
#if CORTEX_USE_FPU
  asm volatile ("vpush   {s16-s31}" : : : "memory");
#endif

  asm volatile ("str     sp, [%1, #12]                          \n\t"
 8000894:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000898:	f8d0 d00c 	ldr.w	sp, [r0, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:250
                "ldr     sp, [%0, #12]" : : "r" (ntp), "r" (otp));

#if CORTEX_USE_FPU
  asm volatile ("vpop    {s16-s31}" : : : "memory");
#endif
  asm volatile ("pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}"
 800089c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080008a0 <_port_thread_start>:
_port_thread_start():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:261
 * @details If the work function returns @p chThdExit() is automatically
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
 80008a0:	2300      	movs	r3, #0
 80008a2:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/chcore_v7m.c:262
  asm volatile ("mov     r0, r5                                 \n\t"
 80008a6:	4628      	mov	r0, r5
 80008a8:	47a0      	blx	r4
 80008aa:	f7ff ff11 	bl	80006d0 <chThdExit>
 80008ae:	4770      	bx	lr

080008b0 <__early_init>:
__early_init():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:234
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __early_init(void) {}
 80008b0:	4770      	bx	lr
	...

080008c0 <__late_init>:
__late_init():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:246
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __late_init(void) {}
 80008c0:	4770      	bx	lr
	...

080008d0 <_default_exit>:
_default_exit():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:257
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak, naked))
#endif
void _default_exit(void) {
 80008d0:	e7fe      	b.n	80008d0 <_default_exit>
	...

080008e0 <ResetHandler>:
ResetHandler():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:274
  uint32_t psp, reg;

  /* Process Stack initialization, it is allocated starting from the
     symbol __process_stack_end__ and its lower limit is the symbol
     __process_stack_base__.*/
  asm volatile ("cpsid   i");
 80008e0:	b672      	cpsid	i
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:276
  psp = SYMVAL(__process_stack_end__);
  asm volatile ("msr     PSP, %0" : : "r" (psp));
 80008e2:	4b22      	ldr	r3, [pc, #136]	; (800096c <ResetHandler+0x8c>)
 80008e4:	f383 8809 	msr	PSP, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:296
  reg = CRT0_CONTROL_INIT | 4;
#else
  /* CPU mode initialization.*/
  reg = CRT0_CONTROL_INIT;
#endif
  asm volatile ("msr     CONTROL, %0" : : "r" (reg));
 80008e8:	2302      	movs	r3, #2
 80008ea:	f383 8814 	msr	CONTROL, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:297
  asm volatile ("isb");
 80008ee:	f3bf 8f6f 	isb	sy
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:301

#if CRT0_INIT_STACKS
  /* Main and Process stacks initialization.*/
  fill32(&__main_stack_base__,
 80008f2:	4b1f      	ldr	r3, [pc, #124]	; (8000970 <ResetHandler+0x90>)
 80008f4:	4a1d      	ldr	r2, [pc, #116]	; (800096c <ResetHandler+0x8c>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:301 (discriminator 1)
 80008f6:	491f      	ldr	r1, [pc, #124]	; (8000974 <ResetHandler+0x94>)
 80008f8:	428b      	cmp	r3, r1
 80008fa:	d204      	bcs.n	8000906 <ResetHandler+0x26>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:301 (discriminator 2)
 80008fc:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 8000900:	f843 1b04 	str.w	r1, [r3], #4
 8000904:	e7f7      	b.n	80008f6 <ResetHandler+0x16>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:301
 8000906:	4b1c      	ldr	r3, [pc, #112]	; (8000978 <ResetHandler+0x98>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:304 (discriminator 1)
         &__main_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
  fill32(&__process_stack_base__,
 8000908:	4293      	cmp	r3, r2
 800090a:	d204      	bcs.n	8000916 <ResetHandler+0x36>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:304 (discriminator 2)
 800090c:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 8000910:	f843 1b04 	str.w	r1, [r3], #4
 8000914:	e7f8      	b.n	8000908 <ResetHandler+0x28>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:310
         &__process_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
#endif

  /* Early initialization hook invocation.*/
  __early_init();
 8000916:	f7ff ffcb 	bl	80008b0 <__early_init>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:319
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 800091a:	2300      	movs	r3, #0
 800091c:	4a17      	ldr	r2, [pc, #92]	; (800097c <ResetHandler+0x9c>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:319 (discriminator 1)
 800091e:	4918      	ldr	r1, [pc, #96]	; (8000980 <ResetHandler+0xa0>)
 8000920:	1898      	adds	r0, r3, r2
 8000922:	4288      	cmp	r0, r1
 8000924:	d204      	bcs.n	8000930 <ResetHandler+0x50>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:320
      *dp++ = *tp++;
 8000926:	4917      	ldr	r1, [pc, #92]	; (8000984 <ResetHandler+0xa4>)
 8000928:	5859      	ldr	r1, [r3, r1]
 800092a:	5099      	str	r1, [r3, r2]
 800092c:	3304      	adds	r3, #4
 800092e:	e7f5      	b.n	800091c <ResetHandler+0x3c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:319
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000930:	4b15      	ldr	r3, [pc, #84]	; (8000988 <ResetHandler+0xa8>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:326 (discriminator 1)
  }
#endif

#if CRT0_INIT_BSS
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
 8000932:	4a16      	ldr	r2, [pc, #88]	; (800098c <ResetHandler+0xac>)
 8000934:	4293      	cmp	r3, r2
 8000936:	d203      	bcs.n	8000940 <ResetHandler+0x60>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:326 (discriminator 2)
 8000938:	2200      	movs	r2, #0
 800093a:	f843 2b04 	str.w	r2, [r3], #4
 800093e:	e7f8      	b.n	8000932 <ResetHandler+0x52>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:330
#endif

  /* Late initialization hook invocation.*/
  __late_init();
 8000940:	f7ff ffbe 	bl	80008c0 <__late_init>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:335

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
 8000944:	4c12      	ldr	r4, [pc, #72]	; (8000990 <ResetHandler+0xb0>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:336 (discriminator 1)
    while (fpp < &__init_array_end) {
 8000946:	4b13      	ldr	r3, [pc, #76]	; (8000994 <ResetHandler+0xb4>)
 8000948:	429c      	cmp	r4, r3
 800094a:	d203      	bcs.n	8000954 <ResetHandler+0x74>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:337
      (*fpp)();
 800094c:	f854 3b04 	ldr.w	r3, [r4], #4
 8000950:	4798      	blx	r3
 8000952:	e7f8      	b.n	8000946 <ResetHandler+0x66>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:344
    }
  }
#endif

  /* Invoking application main() function.*/
  main();
 8000954:	f7ff fbe4 	bl	8000120 <main>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:349

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
 8000958:	4c0f      	ldr	r4, [pc, #60]	; (8000998 <ResetHandler+0xb8>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:350 (discriminator 1)
    while (fpp < &__fini_array_end) {
 800095a:	4b10      	ldr	r3, [pc, #64]	; (800099c <ResetHandler+0xbc>)
 800095c:	429c      	cmp	r4, r3
 800095e:	d203      	bcs.n	8000968 <ResetHandler+0x88>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:351
      (*fpp)();
 8000960:	f854 3b04 	ldr.w	r3, [r4], #4
 8000964:	4798      	blx	r3
 8000966:	e7f8      	b.n	800095a <ResetHandler+0x7a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/crt0.c:358
    }
  }
#endif

  /* Invoking the exit handler.*/
  _default_exit();
 8000968:	f7ff ffb2 	bl	80008d0 <_default_exit>
 800096c:	20000800 	.word	0x20000800
 8000970:	20000000 	.word	0x20000000
 8000974:	20000400 	.word	0x20000400
 8000978:	20000400 	.word	0x20000400
 800097c:	20000800 	.word	0x20000800
 8000980:	20000800 	.word	0x20000800
 8000984:	08002ae0 	.word	0x08002ae0
 8000988:	20000800 	.word	0x20000800
 800098c:	200017d0 	.word	0x200017d0
 8000990:	080000f4 	.word	0x080000f4
 8000994:	080000fc 	.word	0x080000fc
 8000998:	080000fc 	.word	0x080000fc
 800099c:	080000fc 	.word	0x080000fc

080009a0 <halInit>:
halInit():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/hal.c:70
 *
 * @init
 */
void halInit(void) {

  hal_lld_init();
 80009a0:	f000 b806 	b.w	80009b0 <hal_lld_init>
	...

080009b0 <hal_lld_init>:
hal_lld_init():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/hal_lld.cpp:96
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(~RCC_AHBRSTR_FLITFRST);
 80009b0:	4b15      	ldr	r3, [pc, #84]	; (8000a08 <hal_lld_init+0x58>)
 80009b2:	691a      	ldr	r2, [r3, #16]
 80009b4:	f462 4200 	orn	r2, r2, #32768	; 0x8000
 80009b8:	611a      	str	r2, [r3, #16]
 80009ba:	2200      	movs	r2, #0
 80009bc:	611a      	str	r2, [r3, #16]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/hal_lld.cpp:97
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80009be:	6999      	ldr	r1, [r3, #24]
 80009c0:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
 80009c4:	6199      	str	r1, [r3, #24]
 80009c6:	619a      	str	r2, [r3, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/hal_lld.cpp:98
  rccResetAPB2(~0);
 80009c8:	6959      	ldr	r1, [r3, #20]
 80009ca:	f04f 31ff 	mov.w	r1, #4294967295
 80009ce:	6159      	str	r1, [r3, #20]
 80009d0:	615a      	str	r2, [r3, #20]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/hal_lld.cpp:100

  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80009d2:	6a19      	ldr	r1, [r3, #32]
 80009d4:	f041 0101 	orr.w	r1, r1, #1
 80009d8:	6219      	str	r1, [r3, #32]
 80009da:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80009dc:	f041 0101 	orr.w	r1, r1, #1
 80009e0:	62d9      	str	r1, [r3, #44]	; 0x2c
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/hal_lld.cpp:103

  /* SysTick initialization using the system clock.*/
  SysTick->LOAD = Clk.AHBFreqHz / CH_FREQUENCY - 1;
 80009e2:	490a      	ldr	r1, [pc, #40]	; (8000a0c <hal_lld_init+0x5c>)
 80009e4:	6808      	ldr	r0, [r1, #0]
 80009e6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80009ea:	fbb0 f0f1 	udiv	r0, r0, r1
 80009ee:	4908      	ldr	r1, [pc, #32]	; (8000a10 <hal_lld_init+0x60>)
 80009f0:	3801      	subs	r0, #1
 80009f2:	6048      	str	r0, [r1, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/hal_lld.cpp:104
  SysTick->VAL = 0;
 80009f4:	608a      	str	r2, [r1, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/hal_lld.cpp:107
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;
 80009f6:	2207      	movs	r2, #7
 80009f8:	600a      	str	r2, [r1, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/hal_lld.cpp:114
  /* DWT cycle counter enable.*/
//  SCS_DEMCR |= SCS_DEMCR_TRCENA;
//  DWT_CTRL  |= DWT_CTRL_CYCCNTENA;

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80009fa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80009fc:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000a00:	625a      	str	r2, [r3, #36]	; 0x24
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/hal_lld.cpp:120

  /* Initializes the backup domain.*/
//  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8000a02:	f000 b8f5 	b.w	8000bf0 <dmaInit>
 8000a06:	bf00      	nop
 8000a08:	40023800 	.word	0x40023800
 8000a0c:	20000980 	.word	0x20000980
 8000a10:	e000e010 	.word	0xe000e010
	...

08000a20 <nvicEnableVector>:
nvicEnableVector():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:47
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  unsigned sh = (n & 3) << 3;
 8000a20:	f000 0203 	and.w	r2, r0, #3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:46
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000a24:	b530      	push	{r4, r5, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:47
  unsigned sh = (n & 3) << 3;
 8000a26:	00d2      	lsls	r2, r2, #3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:49

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 8000a28:	24ff      	movs	r4, #255	; 0xff
 8000a2a:	4094      	lsls	r4, r2
 8000a2c:	4091      	lsls	r1, r2
 8000a2e:	f020 0303 	bic.w	r3, r0, #3
 8000a32:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8000a36:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 8000a3a:	f8d3 5300 	ldr.w	r5, [r3, #768]	; 0x300
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:50
  NVIC_ICPR(n >> 5) = 1 << (n & 0x1F);
 8000a3e:	2201      	movs	r2, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:49
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  unsigned sh = (n & 3) << 3;

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 8000a40:	ea25 0404 	bic.w	r4, r5, r4
 8000a44:	430c      	orrs	r4, r1
 8000a46:	f8c3 4300 	str.w	r4, [r3, #768]	; 0x300
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:50
  NVIC_ICPR(n >> 5) = 1 << (n & 0x1F);
 8000a4a:	f000 031f 	and.w	r3, r0, #31
 8000a4e:	fa02 f303 	lsl.w	r3, r2, r3
 8000a52:	0940      	lsrs	r0, r0, #5
 8000a54:	0080      	lsls	r0, r0, #2
 8000a56:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000a5a:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000a5e:	f8c0 3180 	str.w	r3, [r0, #384]	; 0x180
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:51
  NVIC_ISER(n >> 5) = 1 << (n & 0x1F);
 8000a62:	6003      	str	r3, [r0, #0]
 8000a64:	bd30      	pop	{r4, r5, pc}
	...

08000a70 <nvicSetSystemHandlerPriority>:
nvicSetSystemHandlerPriority():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:74
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 8000a70:	f020 0303 	bic.w	r3, r0, #3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:75
  unsigned sh = (handler & 3) * 8;
 8000a74:	f000 0003 	and.w	r0, r0, #3
 8000a78:	00c0      	lsls	r0, r0, #3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:78

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
                           ~(0xFF << sh)) | (prio << sh);
 8000a7a:	22ff      	movs	r2, #255	; 0xff
 8000a7c:	4082      	lsls	r2, r0
 8000a7e:	4081      	lsls	r1, r0
 8000a80:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:74
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 8000a84:	b510      	push	{r4, lr}
 8000a86:	f503 436d 	add.w	r3, r3, #60672	; 0xed00
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:77
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 8000a8a:	699c      	ldr	r4, [r3, #24]
 8000a8c:	ea24 0202 	bic.w	r2, r4, r2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:78
                           ~(0xFF << sh)) | (prio << sh);
 8000a90:	430a      	orrs	r2, r1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/nvic.c:77
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 8000a92:	619a      	str	r2, [r3, #24]
 8000a94:	bd10      	pop	{r4, pc}
	...

08000aa0 <Vector6C>:
Vector6C():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:114
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
 8000aa0:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:119
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 8000aa2:	4b07      	ldr	r3, [pc, #28]	; (8000ac0 <Vector6C+0x20>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:120
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
 8000aa4:	220f      	movs	r2, #15
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:119
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 8000aa6:	6819      	ldr	r1, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:120
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
 8000aa8:	605a      	str	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:121
  if (dma_isr_redir[0].dma_func)
 8000aaa:	4a06      	ldr	r2, [pc, #24]	; (8000ac4 <Vector6C+0x24>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:119
CH_IRQ_HANDLER(DMA1_Ch1_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 8000aac:	f001 010f 	and.w	r1, r1, #15
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:121
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
  if (dma_isr_redir[0].dma_func)
 8000ab0:	6813      	ldr	r3, [r2, #0]
 8000ab2:	b10b      	cbz	r3, 8000ab8 <Vector6C+0x18>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:122
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8000ab4:	6850      	ldr	r0, [r2, #4]
 8000ab6:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:125

  CH_IRQ_EPILOGUE();
}
 8000ab8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:124
  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 0;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000abc:	f7ff bea0 	b.w	8000800 <_port_irq_epilogue>
 8000ac0:	40026000 	.word	0x40026000
 8000ac4:	20000828 	.word	0x20000828
	...

08000ad0 <Vector70>:
Vector70():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:132
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
 8000ad0:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:137
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 8000ad2:	4b07      	ldr	r3, [pc, #28]	; (8000af0 <Vector70+0x20>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:138
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
 8000ad4:	22f0      	movs	r2, #240	; 0xf0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:137
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 8000ad6:	6819      	ldr	r1, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:138
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
 8000ad8:	605a      	str	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:139
  if (dma_isr_redir[1].dma_func)
 8000ada:	4a06      	ldr	r2, [pc, #24]	; (8000af4 <Vector70+0x24>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:137
CH_IRQ_HANDLER(DMA1_Ch2_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 8000adc:	f3c1 1103 	ubfx	r1, r1, #4, #4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:139
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
  if (dma_isr_redir[1].dma_func)
 8000ae0:	6893      	ldr	r3, [r2, #8]
 8000ae2:	b10b      	cbz	r3, 8000ae8 <Vector70+0x18>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:140
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8000ae4:	68d0      	ldr	r0, [r2, #12]
 8000ae6:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:143

  CH_IRQ_EPILOGUE();
}
 8000ae8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:142
  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 4;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000aec:	f7ff be88 	b.w	8000800 <_port_irq_epilogue>
 8000af0:	40026000 	.word	0x40026000
 8000af4:	20000828 	.word	0x20000828
	...

08000b00 <Vector74>:
Vector74():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:150
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
 8000b00:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:155
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 8000b02:	4b08      	ldr	r3, [pc, #32]	; (8000b24 <Vector74+0x24>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:156
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
 8000b04:	f44f 6270 	mov.w	r2, #3840	; 0xf00
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:155
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 8000b08:	6819      	ldr	r1, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:156
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
 8000b0a:	605a      	str	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:157
  if (dma_isr_redir[2].dma_func)
 8000b0c:	4a06      	ldr	r2, [pc, #24]	; (8000b28 <Vector74+0x28>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:155
CH_IRQ_HANDLER(DMA1_Ch3_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 8000b0e:	f3c1 2103 	ubfx	r1, r1, #8, #4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:157
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
  if (dma_isr_redir[2].dma_func)
 8000b12:	6913      	ldr	r3, [r2, #16]
 8000b14:	b10b      	cbz	r3, 8000b1a <Vector74+0x1a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:158
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8000b16:	6950      	ldr	r0, [r2, #20]
 8000b18:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:161

  CH_IRQ_EPILOGUE();
}
 8000b1a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:160
  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 8;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000b1e:	f7ff be6f 	b.w	8000800 <_port_irq_epilogue>
 8000b22:	bf00      	nop
 8000b24:	40026000 	.word	0x40026000
 8000b28:	20000828 	.word	0x20000828
$d():
 8000b2c:	00000000 	.word	0x00000000

08000b30 <Vector78>:
Vector78():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:168
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
 8000b30:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:173
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8000b32:	4b08      	ldr	r3, [pc, #32]	; (8000b54 <Vector78+0x24>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:174
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
 8000b34:	f44f 4270 	mov.w	r2, #61440	; 0xf000
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:173
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8000b38:	6819      	ldr	r1, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:174
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
 8000b3a:	605a      	str	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:175
  if (dma_isr_redir[3].dma_func)
 8000b3c:	4a06      	ldr	r2, [pc, #24]	; (8000b58 <Vector78+0x28>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:173
CH_IRQ_HANDLER(DMA1_Ch4_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8000b3e:	f3c1 3103 	ubfx	r1, r1, #12, #4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:175
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
  if (dma_isr_redir[3].dma_func)
 8000b42:	6993      	ldr	r3, [r2, #24]
 8000b44:	b10b      	cbz	r3, 8000b4a <Vector78+0x1a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:176
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8000b46:	69d0      	ldr	r0, [r2, #28]
 8000b48:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:179

  CH_IRQ_EPILOGUE();
}
 8000b4a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:178
  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 12;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000b4e:	f7ff be57 	b.w	8000800 <_port_irq_epilogue>
 8000b52:	bf00      	nop
 8000b54:	40026000 	.word	0x40026000
 8000b58:	20000828 	.word	0x20000828
$d():
 8000b5c:	00000000 	.word	0x00000000

08000b60 <Vector7C>:
Vector7C():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:186
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
 8000b60:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:191
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8000b62:	4b08      	ldr	r3, [pc, #32]	; (8000b84 <Vector7C+0x24>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:192
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
 8000b64:	f44f 2270 	mov.w	r2, #983040	; 0xf0000
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:191
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8000b68:	6819      	ldr	r1, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:192
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
 8000b6a:	605a      	str	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:193
  if (dma_isr_redir[4].dma_func)
 8000b6c:	4a06      	ldr	r2, [pc, #24]	; (8000b88 <Vector7C+0x28>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:191
CH_IRQ_HANDLER(DMA1_Ch5_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8000b6e:	f3c1 4103 	ubfx	r1, r1, #16, #4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:193
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
  if (dma_isr_redir[4].dma_func)
 8000b72:	6a13      	ldr	r3, [r2, #32]
 8000b74:	b10b      	cbz	r3, 8000b7a <Vector7C+0x1a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:194
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8000b76:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8000b78:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:197

  CH_IRQ_EPILOGUE();
}
 8000b7a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:196
  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 16;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000b7e:	f7ff be3f 	b.w	8000800 <_port_irq_epilogue>
 8000b82:	bf00      	nop
 8000b84:	40026000 	.word	0x40026000
 8000b88:	20000828 	.word	0x20000828
$d():
 8000b8c:	00000000 	.word	0x00000000

08000b90 <Vector80>:
Vector80():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:204
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
 8000b90:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:209
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 8000b92:	4b08      	ldr	r3, [pc, #32]	; (8000bb4 <Vector80+0x24>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:210
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
 8000b94:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:209
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 8000b98:	6819      	ldr	r1, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:210
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
 8000b9a:	605a      	str	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:211
  if (dma_isr_redir[5].dma_func)
 8000b9c:	4a06      	ldr	r2, [pc, #24]	; (8000bb8 <Vector80+0x28>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:209
CH_IRQ_HANDLER(DMA1_Ch6_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 8000b9e:	f3c1 5103 	ubfx	r1, r1, #20, #4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:211
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
  if (dma_isr_redir[5].dma_func)
 8000ba2:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8000ba4:	b10b      	cbz	r3, 8000baa <Vector80+0x1a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:212
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8000ba6:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8000ba8:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:215

  CH_IRQ_EPILOGUE();
}
 8000baa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:214
  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 20;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000bae:	f7ff be27 	b.w	8000800 <_port_irq_epilogue>
 8000bb2:	bf00      	nop
 8000bb4:	40026000 	.word	0x40026000
 8000bb8:	20000828 	.word	0x20000828
$d():
 8000bbc:	00000000 	.word	0x00000000

08000bc0 <Vector84>:
Vector84():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:222
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
 8000bc0:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:227
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 8000bc2:	4b08      	ldr	r3, [pc, #32]	; (8000be4 <Vector84+0x24>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:228
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
 8000bc4:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:227
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 8000bc8:	6819      	ldr	r1, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:228
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
 8000bca:	605a      	str	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:229
  if (dma_isr_redir[6].dma_func)
 8000bcc:	4a06      	ldr	r2, [pc, #24]	; (8000be8 <Vector84+0x28>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:227
CH_IRQ_HANDLER(DMA1_Ch7_IRQHandler) {
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 8000bce:	f3c1 6103 	ubfx	r1, r1, #24, #4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:229
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
  if (dma_isr_redir[6].dma_func)
 8000bd2:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8000bd4:	b10b      	cbz	r3, 8000bda <Vector84+0x1a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:230
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8000bd6:	6b50      	ldr	r0, [r2, #52]	; 0x34
 8000bd8:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:233

  CH_IRQ_EPILOGUE();
}
 8000bda:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:232
  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = STM32_DMA_ISR_MASK << 24;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  CH_IRQ_EPILOGUE();
 8000bde:	f7ff be0f 	b.w	8000800 <_port_irq_epilogue>
 8000be2:	bf00      	nop
 8000be4:	40026000 	.word	0x40026000
 8000be8:	20000828 	.word	0x20000828
$d():
 8000bec:	00000000 	.word	0x00000000

08000bf0 <dmaInit>:
dmaInit():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:247
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 8000bf0:	4a09      	ldr	r2, [pc, #36]	; (8000c18 <dmaInit+0x28>)
 8000bf2:	2300      	movs	r3, #0
 8000bf4:	6013      	str	r3, [r2, #0]
 8000bf6:	210c      	movs	r1, #12
 8000bf8:	4359      	muls	r1, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:249 (discriminator 2)
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0;
 8000bfa:	4a08      	ldr	r2, [pc, #32]	; (8000c1c <dmaInit+0x2c>)
 8000bfc:	5889      	ldr	r1, [r1, r2]
 8000bfe:	2200      	movs	r2, #0
 8000c00:	600a      	str	r2, [r1, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:250 (discriminator 2)
    dma_isr_redir[i].dma_func = NULL;
 8000c02:	4907      	ldr	r1, [pc, #28]	; (8000c20 <dmaInit+0x30>)
 8000c04:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:248 (discriminator 2)
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8000c08:	3301      	adds	r3, #1
 8000c0a:	2b07      	cmp	r3, #7
 8000c0c:	d1f3      	bne.n	8000bf6 <dmaInit+0x6>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:252
    _stm32_dma_streams[i].channel->CCR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFF;
 8000c0e:	4b05      	ldr	r3, [pc, #20]	; (8000c24 <dmaInit+0x34>)
 8000c10:	f04f 32ff 	mov.w	r2, #4294967295
 8000c14:	605a      	str	r2, [r3, #4]
 8000c16:	4770      	bx	lr
 8000c18:	20000860 	.word	0x20000860
 8000c1c:	08002300 	.word	0x08002300
 8000c20:	20000828 	.word	0x20000828
 8000c24:	40026000 	.word	0x40026000
	...

08000c30 <dmaStreamAllocate>:
dmaStreamAllocate():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:282
 * @special
 */
bool_t dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                         uint32_t priority,
                         stm32_dmaisr_t func,
                         void *param) {
 8000c30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000c34:	460f      	mov	r7, r1
 8000c36:	4615      	mov	r5, r2
 8000c38:	4698      	mov	r8, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:284

  chDbgCheck(dmastp != NULL, "dmaStreamAllocate");
 8000c3a:	4604      	mov	r4, r0
 8000c3c:	b910      	cbnz	r0, 8000c44 <dmaStreamAllocate+0x14>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:284 (discriminator 1)
 8000c3e:	481a      	ldr	r0, [pc, #104]	; (8000ca8 <dmaStreamAllocate+0x78>)
 8000c40:	f000 fcf6 	bl	8001630 <chDbgPanic>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:287

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
 8000c44:	7a62      	ldrb	r2, [r4, #9]
 8000c46:	2001      	movs	r0, #1
 8000c48:	fa00 fc02 	lsl.w	ip, r0, r2
 8000c4c:	4e17      	ldr	r6, [pc, #92]	; (8000cac <dmaStreamAllocate+0x7c>)
 8000c4e:	6831      	ldr	r1, [r6, #0]
 8000c50:	ea1c 0f01 	tst.w	ip, r1
 8000c54:	d126      	bne.n	8000ca4 <dmaStreamAllocate+0x74>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:291
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8000c56:	4816      	ldr	r0, [pc, #88]	; (8000cb0 <dmaStreamAllocate+0x80>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:293
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 8000c58:	ea4c 0301 	orr.w	r3, ip, r1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:291
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8000c5c:	f840 5032 	str.w	r5, [r0, r2, lsl #3]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:293
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 8000c60:	6033      	str	r3, [r6, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:292
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8000c62:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:296
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 8000c66:	065b      	lsls	r3, r3, #25
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:292
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8000c68:	f8c2 8004 	str.w	r8, [r2, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:296
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 8000c6c:	d004      	beq.n	8000c78 <dmaStreamAllocate+0x48>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:297
    rccEnableDMA1(FALSE);
 8000c6e:	4b11      	ldr	r3, [pc, #68]	; (8000cb4 <dmaStreamAllocate+0x84>)
 8000c70:	69da      	ldr	r2, [r3, #28]
 8000c72:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000c76:	61da      	str	r2, [r3, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:300

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8000c78:	6823      	ldr	r3, [r4, #0]
 8000c7a:	200f      	movs	r0, #15
 8000c7c:	681a      	ldr	r2, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:301
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8000c7e:	2600      	movs	r6, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:300
  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
    rccEnableDMA1(FALSE);

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8000c80:	f022 020f 	bic.w	r2, r2, #15
 8000c84:	601a      	str	r2, [r3, #0]
 8000c86:	7a21      	ldrb	r1, [r4, #8]
 8000c88:	6862      	ldr	r2, [r4, #4]
 8000c8a:	fa00 f101 	lsl.w	r1, r0, r1
 8000c8e:	6011      	str	r1, [r2, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:301
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8000c90:	601e      	str	r6, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:304

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
 8000c92:	b135      	cbz	r5, 8000ca2 <dmaStreamAllocate+0x72>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:305
    nvicEnableVector(dmastp->vector, CORTEX_PRIORITY_MASK(priority));
 8000c94:	7aa0      	ldrb	r0, [r4, #10]
 8000c96:	0139      	lsls	r1, r7, #4
 8000c98:	f7ff fec2 	bl	8000a20 <nvicEnableVector>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:307

  return FALSE;
 8000c9c:	4630      	mov	r0, r6
 8000c9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000ca2:	4628      	mov	r0, r5
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/stm32_dma.c:308
}
 8000ca4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000ca8:	080022b0 	.word	0x080022b0
 8000cac:	20000860 	.word	0x20000860
 8000cb0:	20000828 	.word	0x20000828
 8000cb4:	40023800 	.word	0x40023800
	...

08000cc0 <_unhandled_exception>:
_unhandled_exception():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../os/hal/vectors.c:169
 * @notapi
 */
#if !defined(__DOXYGEN__)
__attribute__ ((naked))
#endif
void _unhandled_exception(void) {
 8000cc0:	e7fe      	b.n	8000cc0 <_unhandled_exception>
	...

08000cd0 <SnsGroup_t::Init() const>:
_ZNK10SnsGroup_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:47
    eventmask_t EvtMskRising, EvtMskFalling;    // Events to send to App.PThread
    ftVoidPVoid pFuncPostprocessor;             // Function to call after check of group
    const SnsData_t *Pins;
    bool *WasHi;
    // Methods
    void Init() const { for(uint32_t i=0; i < Cnt; i++) Pins[i].Init(); }
 8000cd0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000cd2:	6805      	ldr	r5, [r0, #0]
 8000cd4:	2200      	movs	r2, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:47 (discriminator 1)
 8000cd6:	42aa      	cmp	r2, r5
 8000cd8:	d03b      	beq.n	8000d52 <SnsGroup_t::Init() const+0x82>
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:47 (discriminator 2)
 8000cda:	6903      	ldr	r3, [r0, #16]
 8000cdc:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
_ZNK9SnsData_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:35 (discriminator 2)
// Single pin setup data
struct SnsData_t {
    GPIO_TypeDef *PGpio;
    uint16_t Pin;
    PinPullUpDown_t Pud;
    void Init() const { PinSetupIn(PGpio, Pin, Pud); }
 8000ce0:	88a1      	ldrh	r1, [r4, #4]
 8000ce2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8000ce6:	79a6      	ldrb	r6, [r4, #6]
PinClockEnable():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:183 (discriminator 2)
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8000ce8:	4c1a      	ldr	r4, [pc, #104]	; (8000d54 <SnsGroup_t::Init() const+0x84>)
 8000cea:	42a3      	cmp	r3, r4
 8000cec:	d105      	bne.n	8000cfa <SnsGroup_t::Init() const+0x2a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:183
 8000cee:	f504 5460 	add.w	r4, r4, #14336	; 0x3800
 8000cf2:	69e7      	ldr	r7, [r4, #28]
 8000cf4:	f047 0701 	orr.w	r7, r7, #1
 8000cf8:	e019      	b.n	8000d2e <SnsGroup_t::Init() const+0x5e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:184
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8000cfa:	4c17      	ldr	r4, [pc, #92]	; (8000d58 <SnsGroup_t::Init() const+0x88>)
 8000cfc:	42a3      	cmp	r3, r4
 8000cfe:	d105      	bne.n	8000d0c <SnsGroup_t::Init() const+0x3c>
 8000d00:	f504 5450 	add.w	r4, r4, #13312	; 0x3400
 8000d04:	69e7      	ldr	r7, [r4, #28]
 8000d06:	f047 0702 	orr.w	r7, r7, #2
 8000d0a:	e010      	b.n	8000d2e <SnsGroup_t::Init() const+0x5e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:185
    else if(PGpioPort == GPIOC) RCC->AHBENR |= RCC_AHBENR_GPIOCEN;
 8000d0c:	4c13      	ldr	r4, [pc, #76]	; (8000d5c <SnsGroup_t::Init() const+0x8c>)
 8000d0e:	42a3      	cmp	r3, r4
 8000d10:	d105      	bne.n	8000d1e <SnsGroup_t::Init() const+0x4e>
 8000d12:	f504 5440 	add.w	r4, r4, #12288	; 0x3000
 8000d16:	69e7      	ldr	r7, [r4, #28]
 8000d18:	f047 0704 	orr.w	r7, r7, #4
 8000d1c:	e007      	b.n	8000d2e <SnsGroup_t::Init() const+0x5e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:186
    else if(PGpioPort == GPIOD) RCC->AHBENR |= RCC_AHBENR_GPIODEN;
 8000d1e:	4c10      	ldr	r4, [pc, #64]	; (8000d60 <SnsGroup_t::Init() const+0x90>)
 8000d20:	42a3      	cmp	r3, r4
 8000d22:	d105      	bne.n	8000d30 <SnsGroup_t::Init() const+0x60>
 8000d24:	f504 5430 	add.w	r4, r4, #11264	; 0x2c00
 8000d28:	69e7      	ldr	r7, [r4, #28]
 8000d2a:	f047 0708 	orr.w	r7, r7, #8
 8000d2e:	61e7      	str	r7, [r4, #28]
PinSetupIn():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:220
        const PinPullUpDown_t APullUpDown
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8000d30:	0049      	lsls	r1, r1, #1
 8000d32:	2403      	movs	r4, #3
 8000d34:	408c      	lsls	r4, r1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:223
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
 8000d36:	fa06 f101 	lsl.w	r1, r6, r1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:220
        const PinPullUpDown_t APullUpDown
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8000d3a:	681f      	ldr	r7, [r3, #0]
 8000d3c:	43e4      	mvns	r4, r4
 8000d3e:	4027      	ands	r7, r4
 8000d40:	601f      	str	r7, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:222
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
 8000d42:	68df      	ldr	r7, [r3, #12]
_ZNK10SnsGroup_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:47
    eventmask_t EvtMskRising, EvtMskFalling;    // Events to send to App.PThread
    ftVoidPVoid pFuncPostprocessor;             // Function to call after check of group
    const SnsData_t *Pins;
    bool *WasHi;
    // Methods
    void Init() const { for(uint32_t i=0; i < Cnt; i++) Pins[i].Init(); }
 8000d44:	3201      	adds	r2, #1
_ZNK9SnsData_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:222
 8000d46:	403c      	ands	r4, r7
 8000d48:	60dc      	str	r4, [r3, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:223
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << (APinNumber*2);
 8000d4a:	68dc      	ldr	r4, [r3, #12]
 8000d4c:	4321      	orrs	r1, r4
 8000d4e:	60d9      	str	r1, [r3, #12]
 8000d50:	e7c1      	b.n	8000cd6 <SnsGroup_t::Init() const+0x6>
_ZNK10SnsGroup_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:47
 8000d52:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000d54:	40020000 	.word	0x40020000
 8000d58:	40020400 	.word	0x40020400
 8000d5c:	40020800 	.word	0x40020800
 8000d60:	40020c00 	.word	0x40020c00
	...

08000d70 <SnsGroup_t::Check() const>:
_ZNK10SnsGroup_t5CheckEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:59
    void SignalEvtFalling() const {
        chSysLock();
        chEvtSignalI(App.PThread, EvtMskFalling);
        chSysUnlock();
    }
    void Check() const {
 8000d70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:60
        for(uint32_t i=0; i < Cnt; i++) {
 8000d72:	2500      	movs	r5, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:59
    void SignalEvtFalling() const {
        chSysLock();
        chEvtSignalI(App.PThread, EvtMskFalling);
        chSysUnlock();
    }
    void Check() const {
 8000d74:	4604      	mov	r4, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:60
        for(uint32_t i=0; i < Cnt; i++) {
 8000d76:	462e      	mov	r6, r5
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:60 (discriminator 1)
 8000d78:	6823      	ldr	r3, [r4, #0]
 8000d7a:	429e      	cmp	r6, r3
 8000d7c:	d216      	bcs.n	8000dac <SnsGroup_t::Check() const+0x3c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:61
            if     (EvtMskRising  and  Pins[i].IsHi() and !WasHi[i]) SignalEvtRising();
 8000d7e:	6861      	ldr	r1, [r4, #4]
 8000d80:	6923      	ldr	r3, [r4, #16]
 8000d82:	6962      	ldr	r2, [r4, #20]
 8000d84:	b1c1      	cbz	r1, 8000db8 <SnsGroup_t::Check() const+0x48>
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:61 (discriminator 1)
 8000d86:	1958      	adds	r0, r3, r5
PinIsSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:180 (discriminator 1)
// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
 8000d88:	8880      	ldrh	r0, [r0, #4]
 8000d8a:	2701      	movs	r7, #1
 8000d8c:	fa07 f000 	lsl.w	r0, r7, r0
_ZNK9SnsData_t4IsHiEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:37 (discriminator 1)
    GPIO_TypeDef *PGpio;
    uint16_t Pin;
    PinPullUpDown_t Pud;
    void Init() const { PinSetupIn(PGpio, Pin, Pud); }
    void Off()  const { PinSetupAnalog(PGpio, Pin);  }
    bool IsHi() const { return PinIsSet(PGpio, Pin); }
 8000d90:	5959      	ldr	r1, [r3, r5]
PinIsSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:180 (discriminator 1)
 8000d92:	8a09      	ldrh	r1, [r1, #16]
 8000d94:	b289      	uxth	r1, r1
_ZNK10SnsGroup_t5CheckEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:61 (discriminator 1)
        chEvtSignalI(App.PThread, EvtMskFalling);
        chSysUnlock();
    }
    void Check() const {
        for(uint32_t i=0; i < Cnt; i++) {
            if     (EvtMskRising  and  Pins[i].IsHi() and !WasHi[i]) SignalEvtRising();
 8000d96:	4208      	tst	r0, r1
 8000d98:	d00e      	beq.n	8000db8 <SnsGroup_t::Check() const+0x48>
 8000d9a:	5d91      	ldrb	r1, [r2, r6]
 8000d9c:	b961      	cbnz	r1, 8000db8 <SnsGroup_t::Check() const+0x48>
_ZNK10SnsGroup_t15SignalEvtRisingEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:50
    bool *WasHi;
    // Methods
    void Init() const { for(uint32_t i=0; i < Cnt; i++) Pins[i].Init(); }
    void Off()  const { for(uint32_t i=0; i < Cnt; i++) Pins[i].Off();  }
    void SignalEvtRising () const {
        chSysLock();
 8000d9e:	2320      	movs	r3, #32
 8000da0:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:51
        chEvtSignalI(App.PThread, EvtMskRising);
 8000da4:	4b1b      	ldr	r3, [pc, #108]	; (8000e14 <SnsGroup_t::Check() const+0xa4>)
 8000da6:	6861      	ldr	r1, [r4, #4]
 8000da8:	6858      	ldr	r0, [r3, #4]
 8000daa:	e02b      	b.n	8000e04 <SnsGroup_t::Check() const+0x94>
_ZNK10SnsGroup_t5CheckEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:65
        for(uint32_t i=0; i < Cnt; i++) {
            if     (EvtMskRising  and  Pins[i].IsHi() and !WasHi[i]) SignalEvtRising();
            else if(EvtMskFalling and !Pins[i].IsHi() and  WasHi[i]) SignalEvtFalling();
            WasHi[i] = Pins[i].IsHi();
        } // for
        if(pFuncPostprocessor != nullptr) pFuncPostprocessor((void*)this);
 8000dac:	68e3      	ldr	r3, [r4, #12]
 8000dae:	2b00      	cmp	r3, #0
 8000db0:	d02e      	beq.n	8000e10 <SnsGroup_t::Check() const+0xa0>
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:65 (discriminator 1)
 8000db2:	4620      	mov	r0, r4
 8000db4:	4798      	blx	r3
 8000db6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:62
        chSysUnlock();
    }
    void Check() const {
        for(uint32_t i=0; i < Cnt; i++) {
            if     (EvtMskRising  and  Pins[i].IsHi() and !WasHi[i]) SignalEvtRising();
            else if(EvtMskFalling and !Pins[i].IsHi() and  WasHi[i]) SignalEvtFalling();
 8000db8:	68a1      	ldr	r1, [r4, #8]
 8000dba:	b159      	cbz	r1, 8000dd4 <SnsGroup_t::Check() const+0x64>
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:62 (discriminator 1)
 8000dbc:	1959      	adds	r1, r3, r5
PinIsSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:180 (discriminator 1)
 8000dbe:	8889      	ldrh	r1, [r1, #4]
 8000dc0:	2001      	movs	r0, #1
 8000dc2:	fa00 f101 	lsl.w	r1, r0, r1
_ZNK9SnsData_t4IsHiEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:37 (discriminator 1)
    GPIO_TypeDef *PGpio;
    uint16_t Pin;
    PinPullUpDown_t Pud;
    void Init() const { PinSetupIn(PGpio, Pin, Pud); }
    void Off()  const { PinSetupAnalog(PGpio, Pin);  }
    bool IsHi() const { return PinIsSet(PGpio, Pin); }
 8000dc6:	595b      	ldr	r3, [r3, r5]
PinIsSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:180 (discriminator 1)
 8000dc8:	8a1b      	ldrh	r3, [r3, #16]
 8000dca:	b29b      	uxth	r3, r3
_ZNK10SnsGroup_t5CheckEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:62 (discriminator 1)
        chSysUnlock();
    }
    void Check() const {
        for(uint32_t i=0; i < Cnt; i++) {
            if     (EvtMskRising  and  Pins[i].IsHi() and !WasHi[i]) SignalEvtRising();
            else if(EvtMskFalling and !Pins[i].IsHi() and  WasHi[i]) SignalEvtFalling();
 8000dcc:	4219      	tst	r1, r3
 8000dce:	d101      	bne.n	8000dd4 <SnsGroup_t::Check() const+0x64>
 8000dd0:	5d93      	ldrb	r3, [r2, r6]
 8000dd2:	b98b      	cbnz	r3, 8000df8 <SnsGroup_t::Check() const+0x88>
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:63
            WasHi[i] = Pins[i].IsHi();
 8000dd4:	6923      	ldr	r3, [r4, #16]
PinIsSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:180
 8000dd6:	2001      	movs	r0, #1
_ZNK10SnsGroup_t5CheckEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:63
 8000dd8:	1959      	adds	r1, r3, r5
PinIsSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:180
 8000dda:	8889      	ldrh	r1, [r1, #4]
_ZNK9SnsData_t4IsHiEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:37
    GPIO_TypeDef *PGpio;
    uint16_t Pin;
    PinPullUpDown_t Pud;
    void Init() const { PinSetupIn(PGpio, Pin, Pud); }
    void Off()  const { PinSetupAnalog(PGpio, Pin);  }
    bool IsHi() const { return PinIsSet(PGpio, Pin); }
 8000ddc:	595b      	ldr	r3, [r3, r5]
PinIsSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:180
 8000dde:	fa00 f101 	lsl.w	r1, r0, r1
 8000de2:	8a1a      	ldrh	r2, [r3, #16]
_ZNK10SnsGroup_t5CheckEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:63
    }
    void Check() const {
        for(uint32_t i=0; i < Cnt; i++) {
            if     (EvtMskRising  and  Pins[i].IsHi() and !WasHi[i]) SignalEvtRising();
            else if(EvtMskFalling and !Pins[i].IsHi() and  WasHi[i]) SignalEvtFalling();
            WasHi[i] = Pins[i].IsHi();
 8000de4:	6963      	ldr	r3, [r4, #20]
PinIsSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:180
 8000de6:	b292      	uxth	r2, r2
 8000de8:	4211      	tst	r1, r2
 8000dea:	bf0c      	ite	eq
 8000dec:	2200      	moveq	r2, #0
 8000dee:	2201      	movne	r2, #1
 8000df0:	559a      	strb	r2, [r3, r6]
 8000df2:	3508      	adds	r5, #8
_ZNK10SnsGroup_t5CheckEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:60
        chSysLock();
        chEvtSignalI(App.PThread, EvtMskFalling);
        chSysUnlock();
    }
    void Check() const {
        for(uint32_t i=0; i < Cnt; i++) {
 8000df4:	4406      	add	r6, r0
 8000df6:	e7bf      	b.n	8000d78 <SnsGroup_t::Check() const+0x8>
_ZNK10SnsGroup_t16SignalEvtFallingEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:55
        chSysLock();
        chEvtSignalI(App.PThread, EvtMskRising);
        chSysUnlock();
    }
    void SignalEvtFalling() const {
        chSysLock();
 8000df8:	2320      	movs	r3, #32
 8000dfa:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:56
        chEvtSignalI(App.PThread, EvtMskFalling);
 8000dfe:	4b05      	ldr	r3, [pc, #20]	; (8000e14 <SnsGroup_t::Check() const+0xa4>)
 8000e00:	68a1      	ldr	r1, [r4, #8]
 8000e02:	6858      	ldr	r0, [r3, #4]
 8000e04:	f7ff fa4c 	bl	80002a0 <chEvtSignalI>
D:\Nute\MagicThings\Salem\Box_fw\Debug/.././SnsPins.h:57
        chSysUnlock();
 8000e08:	2300      	movs	r3, #0
 8000e0a:	f383 8811 	msr	BASEPRI, r3
 8000e0e:	e7e1      	b.n	8000dd4 <SnsGroup_t::Check() const+0x64>
 8000e10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000e12:	bf00      	nop
 8000e14:	200016fc 	.word	0x200016fc
	...

08000e20 <Sensors_t::Init()>:
_ZN9Sensors_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/SimpleSensors.cpp:20
static void SensorsThread(void *arg) {
    chRegSetThreadName("Sensors");
    Sensors.ITask();
}

void Sensors_t::Init() {
 8000e20:	b507      	push	{r0, r1, r2, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/SimpleSensors.cpp:22
    // Init pins
    for(uint32_t i=0; i < SNSGROUP_CNT; i++) SnsGroups[i]->Init();
 8000e22:	4809      	ldr	r0, [pc, #36]	; (8000e48 <Sensors_t::Init()+0x28>)
 8000e24:	f7ff ff54 	bl	8000cd0 <SnsGroup_t::Init() const>
 8000e28:	4808      	ldr	r0, [pc, #32]	; (8000e4c <Sensors_t::Init()+0x2c>)
 8000e2a:	f7ff ff51 	bl	8000cd0 <SnsGroup_t::Init() const>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/SimpleSensors.cpp:24
    // Create and start thread
    chThdCreateStatic(waSensorsThread, sizeof(waSensorsThread), LOWPRIO, (tfunc_t)SensorsThread, NULL);
 8000e2e:	2300      	movs	r3, #0
 8000e30:	9300      	str	r3, [sp, #0]
 8000e32:	f44f 7188 	mov.w	r1, #272	; 0x110
 8000e36:	2202      	movs	r2, #2
 8000e38:	4b05      	ldr	r3, [pc, #20]	; (8000e50 <Sensors_t::Init()+0x30>)
 8000e3a:	4806      	ldr	r0, [pc, #24]	; (8000e54 <Sensors_t::Init()+0x34>)
 8000e3c:	f7ff fc00 	bl	8000640 <chThdCreateStatic>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/SimpleSensors.cpp:25
}
 8000e40:	b003      	add	sp, #12
 8000e42:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e46:	bf00      	nop
 8000e48:	08002380 	.word	0x08002380
 8000e4c:	08002360 	.word	0x08002360
 8000e50:	08000e81 	.word	0x08000e81
 8000e54:	20000868 	.word	0x20000868
	...

08000e60 <Sensors_t::ITask()>:
_ZN9Sensors_t5ITaskEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/SimpleSensors.cpp:28

__attribute__((noreturn))
void Sensors_t::ITask() {
 8000e60:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/SimpleSensors.cpp:30
    while(true) {
        chThdSleepMilliseconds(SNS_POLL_PERIOD_MS);
 8000e62:	2048      	movs	r0, #72	; 0x48
 8000e64:	f7ff fc04 	bl	8000670 <chThdSleep>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/SimpleSensors.cpp:32
        // Iterate groups checking edge
        for(uint32_t i=0; i < SNSGROUP_CNT; i++) SnsGroups[i]->Check();
 8000e68:	4803      	ldr	r0, [pc, #12]	; (8000e78 <Sensors_t::ITask()+0x18>)
 8000e6a:	f7ff ff81 	bl	8000d70 <SnsGroup_t::Check() const>
 8000e6e:	4803      	ldr	r0, [pc, #12]	; (8000e7c <Sensors_t::ITask()+0x1c>)
 8000e70:	f7ff ff7e 	bl	8000d70 <SnsGroup_t::Check() const>
 8000e74:	e7f5      	b.n	8000e62 <Sensors_t::ITask()+0x2>
 8000e76:	bf00      	nop
 8000e78:	08002380 	.word	0x08002380
 8000e7c:	08002360 	.word	0x08002360

08000e80 <SensorsThread(void*)>:
SensorsThread():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/SimpleSensors.cpp:15
Sensors_t Sensors;

// ==== Sensors Thread ====
static WORKING_AREA(waSensorsThread, 128);
__attribute__((noreturn))
static void SensorsThread(void *arg) {
 8000e80:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/SimpleSensors.cpp:16
    chRegSetThreadName("Sensors");
 8000e82:	4b03      	ldr	r3, [pc, #12]	; (8000e90 <SensorsThread(void*)+0x10>)
 8000e84:	4a03      	ldr	r2, [pc, #12]	; (8000e94 <SensorsThread(void*)+0x14>)
 8000e86:	699b      	ldr	r3, [r3, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/SimpleSensors.cpp:17
    Sensors.ITask();
 8000e88:	4803      	ldr	r0, [pc, #12]	; (8000e98 <SensorsThread(void*)+0x18>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/SimpleSensors.cpp:16

// ==== Sensors Thread ====
static WORKING_AREA(waSensorsThread, 128);
__attribute__((noreturn))
static void SensorsThread(void *arg) {
    chRegSetThreadName("Sensors");
 8000e8a:	619a      	str	r2, [r3, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/SimpleSensors.cpp:17
    Sensors.ITask();
 8000e8c:	f7ff ffe8 	bl	8000e60 <Sensors_t::ITask()>
 8000e90:	20001704 	.word	0x20001704
 8000e94:	080023b0 	.word	0x080023b0
 8000e98:	2000097c 	.word	0x2000097c
$d():
 8000e9c:	00000000 	.word	0x00000000

08000ea0 <Clk_t::UpdateFreqValues()>:
_ZN5Clk_t16UpdateFreqValuesEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:58
        StartUpCounter++;
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
}

void Clk_t::UpdateFreqValues() {
 8000ea0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000ea2:	b093      	sub	sp, #76	; 0x4c
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:62
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000ea4:	2100      	movs	r1, #0
 8000ea6:	2220      	movs	r2, #32
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:58
        StartUpCounter++;
    } while(StartUpCounter < HSE_STARTUP_TIMEOUT);
    return 1; // Timeout
}

void Clk_t::UpdateFreqValues() {
 8000ea8:	4605      	mov	r5, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:62
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000eaa:	a80a      	add	r0, sp, #40	; 0x28
 8000eac:	f001 f8e0 	bl	8002070 <memset>
 8000eb0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000eb4:	930a      	str	r3, [sp, #40]	; 0x28
 8000eb6:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8000eba:	930b      	str	r3, [sp, #44]	; 0x2c
 8000ebc:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8000ec0:	930c      	str	r3, [sp, #48]	; 0x30
 8000ec2:	4b34      	ldr	r3, [pc, #208]	; (8000f94 <Clk_t::UpdateFreqValues()+0xf4>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8000ec4:	4a34      	ldr	r2, [pc, #208]	; (8000f98 <Clk_t::UpdateFreqValues()+0xf8>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000ec6:	930d      	str	r3, [sp, #52]	; 0x34
 8000ec8:	4b34      	ldr	r3, [pc, #208]	; (8000f9c <Clk_t::UpdateFreqValues()+0xfc>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8000eca:	6851      	ldr	r1, [r2, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000ecc:	930e      	str	r3, [sp, #56]	; 0x38
 8000ece:	4b34      	ldr	r3, [pc, #208]	; (8000fa0 <Clk_t::UpdateFreqValues()+0x100>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8000ed0:	6810      	ldr	r0, [r2, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000ed2:	930f      	str	r3, [sp, #60]	; 0x3c
 8000ed4:	4b33      	ldr	r3, [pc, #204]	; (8000fa4 <Clk_t::UpdateFreqValues()+0x104>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:64
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
    const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 8000ed6:	ae06      	add	r6, sp, #24
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:62

void Clk_t::UpdateFreqValues() {
    uint32_t tmp, PllMul, PllDiv;
    uint32_t SysClkHz;
    // Tables
    const uint32_t MSIClk[8] = {65536, 131072, 262144, 524188, 1048000, 2097000, 4194000};
 8000ed8:	9310      	str	r3, [sp, #64]	; 0x40
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:63
    const uint8_t PllMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
 8000eda:	ab03      	add	r3, sp, #12
 8000edc:	c303      	stmia	r3!, {r0, r1}
 8000ede:	7a11      	ldrb	r1, [r2, #8]
 8000ee0:	7019      	strb	r1, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:64
    const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
 8000ee2:	f102 0309 	add.w	r3, r2, #9
 8000ee6:	3219      	adds	r2, #25
 8000ee8:	4617      	mov	r7, r2
 8000eea:	6818      	ldr	r0, [r3, #0]
 8000eec:	6859      	ldr	r1, [r3, #4]
 8000eee:	4634      	mov	r4, r6
 8000ef0:	c403      	stmia	r4!, {r0, r1}
 8000ef2:	3308      	adds	r3, #8
 8000ef4:	4293      	cmp	r3, r2
 8000ef6:	4626      	mov	r6, r4
 8000ef8:	d1f7      	bne.n	8000eea <Clk_t::UpdateFreqValues()+0x4a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:65
    const uint8_t APBPrescTable[8] = {0, 0, 0, 0, 1, 2, 3, 4};
 8000efa:	6838      	ldr	r0, [r7, #0]
 8000efc:	6879      	ldr	r1, [r7, #4]
 8000efe:	ab01      	add	r3, sp, #4
 8000f00:	c303      	stmia	r3!, {r0, r1}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:68

    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
 8000f02:	4b29      	ldr	r3, [pc, #164]	; (8000fa8 <Clk_t::UpdateFreqValues()+0x108>)
 8000f04:	689a      	ldr	r2, [r3, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:69
    tmp >>= 2;
 8000f06:	f3c2 0281 	ubfx	r2, r2, #2, #2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:70
    switch(tmp) {
 8000f0a:	2a02      	cmp	r2, #2
 8000f0c:	d024      	beq.n	8000f58 <Clk_t::UpdateFreqValues()+0xb8>
 8000f0e:	2a03      	cmp	r2, #3
 8000f10:	d00c      	beq.n	8000f2c <Clk_t::UpdateFreqValues()+0x8c>
 8000f12:	2a01      	cmp	r2, #1
 8000f14:	d101      	bne.n	8000f1a <Clk_t::UpdateFreqValues()+0x7a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:77
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
            SysClkHz = MSIClk[tmp];
            break;

        case 0b01: // HSI
            SysClkHz = HSI_FREQ_HZ;
 8000f16:	4b25      	ldr	r3, [pc, #148]	; (8000fac <Clk_t::UpdateFreqValues()+0x10c>)
 8000f18:	e01f      	b.n	8000f5a <Clk_t::UpdateFreqValues()+0xba>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:72
    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
    tmp >>= 2;
    switch(tmp) {
        case 0b00: // MSI
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
 8000f1a:	685b      	ldr	r3, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:73
            SysClkHz = MSIClk[tmp];
 8000f1c:	a812      	add	r0, sp, #72	; 0x48
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:72
    // Figure out SysClk
    tmp = RCC->CFGR & RCC_CFGR_SWS;
    tmp >>= 2;
    switch(tmp) {
        case 0b00: // MSI
            tmp = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
 8000f1e:	f3c3 3342 	ubfx	r3, r3, #13, #3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:73
            SysClkHz = MSIClk[tmp];
 8000f22:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8000f26:	f853 3c20 	ldr.w	r3, [r3, #-32]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:74
            break;
 8000f2a:	e016      	b.n	8000f5a <Clk_t::UpdateFreqValues()+0xba>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:86
            SysClkHz = CRYSTAL_FREQ_HZ;
            break;

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
 8000f2c:	689a      	ldr	r2, [r3, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:87
            PllMul = PllMulTable[tmp];
 8000f2e:	a912      	add	r1, sp, #72	; 0x48
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:86
            SysClkHz = CRYSTAL_FREQ_HZ;
            break;

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
 8000f30:	f3c2 4283 	ubfx	r2, r2, #18, #4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:87
            PllMul = PllMulTable[tmp];
 8000f34:	440a      	add	r2, r1
 8000f36:	f812 1c3c 	ldrb.w	r1, [r2, #-60]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:88
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 8000f3a:	689a      	ldr	r2, [r3, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:90
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
 8000f3c:	689b      	ldr	r3, [r3, #8]
 8000f3e:	481c      	ldr	r0, [pc, #112]	; (8000fb0 <Clk_t::UpdateFreqValues()+0x110>)
 8000f40:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8000f44:	4b19      	ldr	r3, [pc, #100]	; (8000fac <Clk_t::UpdateFreqValues()+0x10c>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:88

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
            PllMul = PllMulTable[tmp];
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 8000f46:	f3c2 5281 	ubfx	r2, r2, #22, #2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:90
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
 8000f4a:	bf18      	it	ne
 8000f4c:	4603      	movne	r3, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:91
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
 8000f4e:	434b      	muls	r3, r1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:88

        case 0b11: // PLL used as system clock source
            // Get different PLL dividers
            tmp = (RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
            PllMul = PllMulTable[tmp];
            PllDiv = ((RCC->CFGR & RCC_CFGR_PLLDIV) >> 22) +1;
 8000f50:	3201      	adds	r2, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:91
            // Which src is used as pll input?
            SysClkHz = ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)? HSI_FREQ_HZ : CRYSTAL_FREQ_HZ;
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
 8000f52:	fbb3 f3f2 	udiv	r3, r3, r2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:92
            break;
 8000f56:	e000      	b.n	8000f5a <Clk_t::UpdateFreqValues()+0xba>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:81
        case 0b01: // HSI
            SysClkHz = HSI_FREQ_HZ;
            break;

        case 0b10: // HSE
            SysClkHz = CRYSTAL_FREQ_HZ;
 8000f58:	4b15      	ldr	r3, [pc, #84]	; (8000fb0 <Clk_t::UpdateFreqValues()+0x110>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:96
            SysClkHz = (SysClkHz * PllMul) / PllDiv;
            break;
    } // switch

    // AHB freq
    tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8000f5a:	4a13      	ldr	r2, [pc, #76]	; (8000fa8 <Clk_t::UpdateFreqValues()+0x108>)
 8000f5c:	a812      	add	r0, sp, #72	; 0x48
 8000f5e:	6891      	ldr	r1, [r2, #8]
 8000f60:	f3c1 1103 	ubfx	r1, r1, #4, #4
 8000f64:	4401      	add	r1, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:97
    AHBFreqHz = SysClkHz >> tmp;
 8000f66:	f811 1c30 	ldrb.w	r1, [r1, #-48]
 8000f6a:	40cb      	lsrs	r3, r1
 8000f6c:	602b      	str	r3, [r5, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:99
    // APB freq
    tmp = APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> 8];
 8000f6e:	6891      	ldr	r1, [r2, #8]
 8000f70:	f3c1 2102 	ubfx	r1, r1, #8, #3
 8000f74:	4401      	add	r1, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:100
    APB1FreqHz = AHBFreqHz >> tmp;
 8000f76:	f811 1c44 	ldrb.w	r1, [r1, #-68]
 8000f7a:	fa23 f101 	lsr.w	r1, r3, r1
 8000f7e:	6069      	str	r1, [r5, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:101
    tmp = APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> 11];
 8000f80:	6892      	ldr	r2, [r2, #8]
 8000f82:	f3c2 22c2 	ubfx	r2, r2, #11, #3
 8000f86:	4402      	add	r2, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:102
    APB2FreqHz = AHBFreqHz >> tmp;
 8000f88:	f812 2c44 	ldrb.w	r2, [r2, #-68]
 8000f8c:	40d3      	lsrs	r3, r2
 8000f8e:	60ab      	str	r3, [r5, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:103
}
 8000f90:	b013      	add	sp, #76	; 0x4c
 8000f92:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000f94:	0007ff9c 	.word	0x0007ff9c
 8000f98:	08002110 	.word	0x08002110
 8000f9c:	000ffdc0 	.word	0x000ffdc0
 8000fa0:	001fff68 	.word	0x001fff68
 8000fa4:	003ffed0 	.word	0x003ffed0
 8000fa8:	40023800 	.word	0x40023800
 8000fac:	00f42400 	.word	0x00f42400
 8000fb0:	007a1200 	.word	0x007a1200
	...

08000fc0 <SetupVCore(VCore_t)>:
_Z10SetupVCore7VCore_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:198

// =============================== V Core ======================================
VCore_t VCore;
void SetupVCore(VCore_t AVCore) {
    // PWR clock enable
    RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000fc0:	4b09      	ldr	r3, [pc, #36]	; (8000fe8 <SetupVCore(VCore_t)+0x28>)
 8000fc2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000fc6:	625a      	str	r2, [r3, #36]	; 0x24
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:200 (discriminator 1)
    // Core voltage setup
    while((PWR->CSR & PWR_CSR_VOSF) != 0); // Wait until regulator is stable
 8000fc8:	4b08      	ldr	r3, [pc, #32]	; (8000fec <SetupVCore(VCore_t)+0x2c>)
 8000fca:	685a      	ldr	r2, [r3, #4]
 8000fcc:	06d1      	lsls	r1, r2, #27
 8000fce:	d4fb      	bmi.n	8000fc8 <SetupVCore(VCore_t)+0x8>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:201
    uint32_t tmp = PWR->CR;
 8000fd0:	681a      	ldr	r2, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:202
    tmp &= ~PWR_CR_VOS;
 8000fd2:	f422 52c0 	bic.w	r2, r2, #6144	; 0x1800
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:203
    tmp |= ((uint32_t)AVCore) << 11;
 8000fd6:	ea42 22c0 	orr.w	r2, r2, r0, lsl #11
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:204
    PWR->CR = tmp;
 8000fda:	601a      	str	r2, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:205 (discriminator 1)
    while((PWR->CSR & PWR_CSR_VOSF) != 0); // Wait until regulator is stable
 8000fdc:	685a      	ldr	r2, [r3, #4]
 8000fde:	06d2      	lsls	r2, r2, #27
 8000fe0:	d4fc      	bmi.n	8000fdc <SetupVCore(VCore_t)+0x1c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/clocking_L1xx.cpp:206
    VCore = AVCore;
 8000fe2:	4b03      	ldr	r3, [pc, #12]	; (8000ff0 <SetupVCore(VCore_t)+0x30>)
 8000fe4:	7018      	strb	r0, [r3, #0]
 8000fe6:	4770      	bx	lr
 8000fe8:	40023800 	.word	0x40023800
 8000fec:	40007000 	.word	0x40007000
 8000ff0:	2000097d 	.word	0x2000097d
	...

08001000 <TimeElapsed(unsigned long*, unsigned long)>:
TimeElapsed():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:137
void __attribute__ ((weak)) _init(void)  {}
}
#endif

#if 1 // =========================== Time ======================================
static inline bool TimeElapsed(systime_t *PSince, uint32_t Delay_ms) {
 8001000:	b510      	push	{r4, lr}
 8001002:	4602      	mov	r2, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:138
    chSysLock();
 8001004:	2320      	movs	r3, #32
 8001006:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:139
    bool Rslt = (systime_t)(chTimeNow() - *PSince) > MS2ST(Delay_ms);
 800100a:	4b0b      	ldr	r3, [pc, #44]	; (8001038 <TimeElapsed(unsigned long*, unsigned long)+0x38>)
 800100c:	6800      	ldr	r0, [r0, #0]
 800100e:	68dc      	ldr	r4, [r3, #12]
 8001010:	1a20      	subs	r0, r4, r0
 8001012:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8001016:	4361      	muls	r1, r4
 8001018:	f5a1 717a 	sub.w	r1, r1, #1000	; 0x3e8
 800101c:	fbb1 f4f4 	udiv	r4, r1, r4
 8001020:	3401      	adds	r4, #1
 8001022:	42a0      	cmp	r0, r4
 8001024:	bf94      	ite	ls
 8001026:	2000      	movls	r0, #0
 8001028:	2001      	movhi	r0, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:140
    if(Rslt) *PSince = chTimeNow();
 800102a:	b108      	cbz	r0, 8001030 <TimeElapsed(unsigned long*, unsigned long)+0x30>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:140 (discriminator 1)
 800102c:	68db      	ldr	r3, [r3, #12]
 800102e:	6013      	str	r3, [r2, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:141
    chSysUnlock();
 8001030:	2300      	movs	r3, #0
 8001032:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:143
    return Rslt;
}
 8001036:	bd10      	pop	{r4, pc}
 8001038:	200017c0 	.word	0x200017c0
$d():
 800103c:	00000000 	.word	0x00000000

08001040 <CircBuf_t<KeyEvtInfo_t, 7ul>::Put(KeyEvtInfo_t*)>:
_ZN9CircBuf_tI12KeyEvtInfo_tLm7EE3PutEPS0_():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:41
        IFullSlotsCount--;
        return OK;
    }

    uint8_t Put(T *p) {
        if(IFullSlotsCount >= Sz) return FAILURE;
 8001040:	6803      	ldr	r3, [r0, #0]
 8001042:	2b06      	cmp	r3, #6
 8001044:	d811      	bhi.n	800106a <CircBuf_t<KeyEvtInfo_t, 7ul>::Put(KeyEvtInfo_t*)+0x2a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:42
        memcpy(PWrite, p, sizeof(T));
 8001046:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001048:	680a      	ldr	r2, [r1, #0]
 800104a:	601a      	str	r2, [r3, #0]
 800104c:	888a      	ldrh	r2, [r1, #4]
 800104e:	809a      	strh	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:43
        if(++PWrite > (IBuf + Sz - 1)) PWrite = IBuf;   // Circulate buffer
 8001050:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001052:	f100 0228 	add.w	r2, r0, #40	; 0x28
 8001056:	3306      	adds	r3, #6
 8001058:	4293      	cmp	r3, r2
 800105a:	bf88      	it	hi
 800105c:	1d03      	addhi	r3, r0, #4
 800105e:	6343      	str	r3, [r0, #52]	; 0x34
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:44
        IFullSlotsCount++;
 8001060:	6803      	ldr	r3, [r0, #0]
 8001062:	3301      	adds	r3, #1
 8001064:	6003      	str	r3, [r0, #0]
 8001066:	2000      	movs	r0, #0
 8001068:	4770      	bx	lr
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:41
        IFullSlotsCount--;
        return OK;
    }

    uint8_t Put(T *p) {
        if(IFullSlotsCount >= Sz) return FAILURE;
 800106a:	2001      	movs	r0, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:46
        memcpy(PWrite, p, sizeof(T));
        if(++PWrite > (IBuf + Sz - 1)) PWrite = IBuf;   // Circulate buffer
        IFullSlotsCount++;
        return OK;
    }
 800106c:	4770      	bx	lr
	...

08001070 <Keys_t::AddEvtToQueue(KeyEvtInfo_t)>:
_ZN6Keys_t13AddEvtToQueueE12KeyEvtInfo_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:105
        } // if still pressed
#endif
    } // for i
}

void Keys_t::AddEvtToQueue(KeyEvtInfo_t Evt) {
 8001070:	b537      	push	{r0, r1, r2, r4, r5, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:109
//    Uart.Printf("EvtType=%u; Keys: ", Evt.Type);
//    for(uint8_t i=0; i<Evt.NKeys; i++) Uart.Printf("%u ", Evt.KeyID[i]);
//    Uart.Printf("\r\n");
    if(App.PThread == nullptr) return;
 8001072:	4b0b      	ldr	r3, [pc, #44]	; (80010a0 <Keys_t::AddEvtToQueue(KeyEvtInfo_t)+0x30>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:105
        } // if still pressed
#endif
    } // for i
}

void Keys_t::AddEvtToQueue(KeyEvtInfo_t Evt) {
 8001074:	e88d 0006 	stmia.w	sp, {r1, r2}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:109
//    Uart.Printf("EvtType=%u; Keys: ", Evt.Type);
//    for(uint8_t i=0; i<Evt.NKeys; i++) Uart.Printf("%u ", Evt.KeyID[i]);
//    Uart.Printf("\r\n");
    if(App.PThread == nullptr) return;
 8001078:	685a      	ldr	r2, [r3, #4]
 800107a:	461d      	mov	r5, r3
 800107c:	b16a      	cbz	r2, 800109a <Keys_t::AddEvtToQueue(KeyEvtInfo_t)+0x2a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:110
    chSysLock();
 800107e:	2320      	movs	r3, #32
 8001080:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:111
    EvtBuf.Put(&Evt);
 8001084:	4669      	mov	r1, sp
 8001086:	3018      	adds	r0, #24
 8001088:	f7ff ffda 	bl	8001040 <CircBuf_t<KeyEvtInfo_t, 7ul>::Put(KeyEvtInfo_t*)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:112
    chEvtSignalI(App.PThread, EVTMSK_KEYS);
 800108c:	6868      	ldr	r0, [r5, #4]
 800108e:	2102      	movs	r1, #2
 8001090:	f7ff f906 	bl	80002a0 <chEvtSignalI>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:113
    chSysUnlock();
 8001094:	2300      	movs	r3, #0
 8001096:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:114
}
 800109a:	b003      	add	sp, #12
 800109c:	bd30      	pop	{r4, r5, pc}
 800109e:	bf00      	nop
 80010a0:	200016fc 	.word	0x200016fc
	...

080010b0 <Keys_t::AddEvtToQueue(KeyEvt_t, unsigned char)>:
_ZN6Keys_t13AddEvtToQueueE8KeyEvt_th():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:116

void Keys_t::AddEvtToQueue(KeyEvt_t AType, uint8_t KeyIndx) {
 80010b0:	b507      	push	{r0, r1, r2, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:119
    KeyEvtInfo_t IEvt;
    IEvt.Type = AType;
    IEvt.KeysCnt = 1;
 80010b2:	2301      	movs	r3, #1
 80010b4:	f88d 3001 	strb.w	r3, [sp, #1]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:118
    chSysUnlock();
}

void Keys_t::AddEvtToQueue(KeyEvt_t AType, uint8_t KeyIndx) {
    KeyEvtInfo_t IEvt;
    IEvt.Type = AType;
 80010b8:	f88d 1000 	strb.w	r1, [sp]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:120
    IEvt.KeysCnt = 1;
    IEvt.KeyID[0] = KeyIndx;
 80010bc:	f88d 2002 	strb.w	r2, [sp, #2]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:121
    chSysLock();
 80010c0:	2320      	movs	r3, #32
 80010c2:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:122
    EvtBuf.Put(&IEvt);
 80010c6:	4669      	mov	r1, sp
 80010c8:	3018      	adds	r0, #24
 80010ca:	f7ff ffb9 	bl	8001040 <CircBuf_t<KeyEvtInfo_t, 7ul>::Put(KeyEvtInfo_t*)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:123
    chEvtSignalI(App.PThread, EVTMSK_KEYS);
 80010ce:	4b05      	ldr	r3, [pc, #20]	; (80010e4 <Keys_t::AddEvtToQueue(KeyEvt_t, unsigned char)+0x34>)
 80010d0:	2102      	movs	r1, #2
 80010d2:	6858      	ldr	r0, [r3, #4]
 80010d4:	f7ff f8e4 	bl	80002a0 <chEvtSignalI>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:124
    chSysUnlock();
 80010d8:	2300      	movs	r3, #0
 80010da:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:125
}
 80010de:	b003      	add	sp, #12
 80010e0:	f85d fb04 	ldr.w	pc, [sp], #4
 80010e4:	200016fc 	.word	0x200016fc
	...

080010f0 <Keys_t::ProcessKeysState(bool*)>:
_ZN6Keys_t16ProcessKeysStateEPb():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:21
    SnsGroup_t *grp = (SnsGroup_t*)p;
    Keys.ProcessKeysState(grp->WasHi);
}


void Keys_t::ProcessKeysState(bool *PCurrentState) {
 80010f0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80010f4:	4604      	mov	r4, r0
 80010f6:	468a      	mov	sl, r1
 80010f8:	4605      	mov	r5, r0
 80010fa:	2700      	movs	r7, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:25
//    Uart.Printf("\r%A", PCurrentState, KEYS_CNT, ' ');
    // Iterate keys
    for(uint8_t i=0; i<KEYS_CNT; i++) {
        bool PressedNow = KeyIsPressed(PCurrentState[i]);
 80010fc:	f81a 3007 	ldrb.w	r3, [sl, r7]
 8001100:	fa5f f987 	uxtb.w	r9, r7
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:28

        // ==== Key Press ====
        if(PressedNow and !Key[i].IsPressed) {
 8001104:	f093 0201 	eors.w	r2, r3, #1
 8001108:	d03a      	beq.n	8001180 <Keys_t::ProcessKeysState(bool*)+0x90>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:28 (discriminator 1)
 800110a:	782e      	ldrb	r6, [r5, #0]
 800110c:	2e00      	cmp	r6, #0
 800110e:	d137      	bne.n	8001180 <Keys_t::ProcessKeysState(bool*)+0x90>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:29
            Key[i].IsPressed = true;
 8001110:	2301      	movs	r3, #1
 8001112:	702b      	strb	r3, [r5, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:31
#if KEY_LONGPRESS
            Key[i].IsLongPress = false;
 8001114:	70ae      	strb	r6, [r5, #2]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:32
            Key[i].IsRepeating = false;
 8001116:	706e      	strb	r6, [r5, #1]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:35
#endif
            KeyEvtInfo_t IEvt;
            IEvt.KeysCnt = 0;
 8001118:	46b0      	mov	r8, r6
 800111a:	eb06 0346 	add.w	r3, r6, r6, lsl #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:38
            // Check if combo
            for(uint8_t j=0; j<KEYS_CNT; j++) {
                if(Key[j].IsPressed) {
 800111e:	5ce3      	ldrb	r3, [r4, r3]
 8001120:	b2f2      	uxtb	r2, r6
 8001122:	b18b      	cbz	r3, 8001148 <Keys_t::ProcessKeysState(bool*)+0x58>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:39
                    IEvt.KeyID[IEvt.KeysCnt] = j;
 8001124:	ab02      	add	r3, sp, #8
 8001126:	4443      	add	r3, r8
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:41
                    IEvt.KeysCnt++;
                    if((j != i) and !IsCombo) {
 8001128:	454a      	cmp	r2, r9
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:40
            IEvt.KeysCnt = 0;
            // Check if combo
            for(uint8_t j=0; j<KEYS_CNT; j++) {
                if(Key[j].IsPressed) {
                    IEvt.KeyID[IEvt.KeysCnt] = j;
                    IEvt.KeysCnt++;
 800112a:	f108 0801 	add.w	r8, r8, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:39
            KeyEvtInfo_t IEvt;
            IEvt.KeysCnt = 0;
            // Check if combo
            for(uint8_t j=0; j<KEYS_CNT; j++) {
                if(Key[j].IsPressed) {
                    IEvt.KeyID[IEvt.KeysCnt] = j;
 800112e:	f803 2c06 	strb.w	r2, [r3, #-6]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:40
                    IEvt.KeysCnt++;
 8001132:	fa5f f888 	uxtb.w	r8, r8
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:41
                    if((j != i) and !IsCombo) {
 8001136:	d007      	beq.n	8001148 <Keys_t::ProcessKeysState(bool*)+0x58>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:41 (discriminator 1)
 8001138:	7d23      	ldrb	r3, [r4, #20]
 800113a:	b92b      	cbnz	r3, 8001148 <Keys_t::ProcessKeysState(bool*)+0x58>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:42
                        IsCombo = true;
 800113c:	2301      	movs	r3, #1
 800113e:	7523      	strb	r3, [r4, #20]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:43
                        AddEvtToQueue(keCancel, j);
 8001140:	4620      	mov	r0, r4
 8001142:	2103      	movs	r1, #3
 8001144:	f7ff ffb4 	bl	80010b0 <Keys_t::AddEvtToQueue(KeyEvt_t, unsigned char)>
 8001148:	3601      	adds	r6, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:37
            Key[i].IsRepeating = false;
#endif
            KeyEvtInfo_t IEvt;
            IEvt.KeysCnt = 0;
            // Check if combo
            for(uint8_t j=0; j<KEYS_CNT; j++) {
 800114a:	2e04      	cmp	r6, #4
 800114c:	d1e5      	bne.n	800111a <Keys_t::ProcessKeysState(bool*)+0x2a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:47
                        IsCombo = true;
                        AddEvtToQueue(keCancel, j);
                    }
                }
            } // for j
            if(IEvt.KeysCnt == 1) {   // Single key pressed, no combo
 800114e:	f1b8 0f01 	cmp.w	r8, #1
 8001152:	d109      	bne.n	8001168 <Keys_t::ProcessKeysState(bool*)+0x78>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:48
                IsCombo = false;
 8001154:	2300      	movs	r3, #0
 8001156:	7523      	strb	r3, [r4, #20]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:49
                IEvt.Type = kePress;
 8001158:	f88d 3000 	strb.w	r3, [sp]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:51
#if KEY_LONGPRESS   // Reset timers
                RepeatTimer = chTimeNow();
 800115c:	4b24      	ldr	r3, [pc, #144]	; (80011f0 <Keys_t::ProcessKeysState(bool*)+0x100>)
 800115e:	68da      	ldr	r2, [r3, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:52
                LongPressTimer = chTimeNow();
 8001160:	68db      	ldr	r3, [r3, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:51
            } // for j
            if(IEvt.KeysCnt == 1) {   // Single key pressed, no combo
                IsCombo = false;
                IEvt.Type = kePress;
#if KEY_LONGPRESS   // Reset timers
                RepeatTimer = chTimeNow();
 8001162:	60e2      	str	r2, [r4, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:52
                LongPressTimer = chTimeNow();
 8001164:	6123      	str	r3, [r4, #16]
 8001166:	e002      	b.n	800116e <Keys_t::ProcessKeysState(bool*)+0x7e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:55
#endif
            }
            else IEvt.Type = keCombo;
 8001168:	2305      	movs	r3, #5
 800116a:	f88d 3000 	strb.w	r3, [sp]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:56
            AddEvtToQueue(IEvt);
 800116e:	f88d 8001 	strb.w	r8, [sp, #1]
 8001172:	ab02      	add	r3, sp, #8
 8001174:	4620      	mov	r0, r4
 8001176:	e913 0006 	ldmdb	r3, {r1, r2}
 800117a:	f7ff ff79 	bl	8001070 <Keys_t::AddEvtToQueue(KeyEvtInfo_t)>
 800117e:	e02e      	b.n	80011de <Keys_t::ProcessKeysState(bool*)+0xee>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:60
        } // if became pressed

        // ==== Key Release ====
        else if(!PressedNow and Key[i].IsPressed) {
 8001180:	b123      	cbz	r3, 800118c <Keys_t::ProcessKeysState(bool*)+0x9c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:60 (discriminator 1)
 8001182:	782b      	ldrb	r3, [r5, #0]
 8001184:	b113      	cbz	r3, 800118c <Keys_t::ProcessKeysState(bool*)+0x9c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:61
            Key[i].IsPressed = false;
 8001186:	2300      	movs	r3, #0
 8001188:	702b      	strb	r3, [r5, #0]
 800118a:	e028      	b.n	80011de <Keys_t::ProcessKeysState(bool*)+0xee>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:80
            else AddEvtToQueue(keRelease, i);
#endif
        }

#if KEY_LONGPRESS // ==== Long Press ====
        else if(PressedNow and Key[i].IsPressed and !IsCombo) {
 800118c:	b33a      	cbz	r2, 80011de <Keys_t::ProcessKeysState(bool*)+0xee>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:80 (discriminator 1)
 800118e:	782b      	ldrb	r3, [r5, #0]
 8001190:	b32b      	cbz	r3, 80011de <Keys_t::ProcessKeysState(bool*)+0xee>
 8001192:	7d23      	ldrb	r3, [r4, #20]
 8001194:	bb1b      	cbnz	r3, 80011de <Keys_t::ProcessKeysState(bool*)+0xee>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:82
            // Check if long press
            if(!Key[i].IsLongPress) {
 8001196:	78ab      	ldrb	r3, [r5, #2]
 8001198:	b963      	cbnz	r3, 80011b4 <Keys_t::ProcessKeysState(bool*)+0xc4>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:83
                if(TimeElapsed(&LongPressTimer, KEY_LONGPRESS_DELAY_MS)) {
 800119a:	f104 0010 	add.w	r0, r4, #16
 800119e:	f240 215b 	movw	r1, #603	; 0x25b
 80011a2:	f7ff ff2d 	bl	8001000 <TimeElapsed(unsigned long*, unsigned long)>
 80011a6:	b128      	cbz	r0, 80011b4 <Keys_t::ProcessKeysState(bool*)+0xc4>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:84
                    Key[i].IsLongPress = true;
 80011a8:	2101      	movs	r1, #1
 80011aa:	70a9      	strb	r1, [r5, #2]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:85
                    AddEvtToQueue(keLongPress, i);
 80011ac:	4620      	mov	r0, r4
 80011ae:	464a      	mov	r2, r9
 80011b0:	f7ff ff7e 	bl	80010b0 <Keys_t::AddEvtToQueue(KeyEvt_t, unsigned char)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:89
                }
            }
            // Check if repeat
            if(!Key[i].IsRepeating) {
 80011b4:	786b      	ldrb	r3, [r5, #1]
 80011b6:	f104 000c 	add.w	r0, r4, #12
 80011ba:	b93b      	cbnz	r3, 80011cc <Keys_t::ProcessKeysState(bool*)+0xdc>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:90
                if(TimeElapsed(&RepeatTimer, KEYS_DELAY_BEFORE_REPEAT_MS)) {
 80011bc:	f240 310f 	movw	r1, #783	; 0x30f
 80011c0:	f7ff ff1e 	bl	8001000 <TimeElapsed(unsigned long*, unsigned long)>
 80011c4:	b158      	cbz	r0, 80011de <Keys_t::ProcessKeysState(bool*)+0xee>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:91
                    Key[i].IsRepeating = true;
 80011c6:	2301      	movs	r3, #1
 80011c8:	706b      	strb	r3, [r5, #1]
 80011ca:	e003      	b.n	80011d4 <Keys_t::ProcessKeysState(bool*)+0xe4>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:96
                    AddEvtToQueue(keRepeat, i);
                }
            }
            else {
                if(TimeElapsed(&RepeatTimer, KEY_REPEAT_PERIOD_MS)) {
 80011cc:	21b4      	movs	r1, #180	; 0xb4
 80011ce:	f7ff ff17 	bl	8001000 <TimeElapsed(unsigned long*, unsigned long)>
 80011d2:	b120      	cbz	r0, 80011de <Keys_t::ProcessKeysState(bool*)+0xee>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:97
                    AddEvtToQueue(keRepeat, i);
 80011d4:	4620      	mov	r0, r4
 80011d6:	2104      	movs	r1, #4
 80011d8:	464a      	mov	r2, r9
 80011da:	f7ff ff69 	bl	80010b0 <Keys_t::AddEvtToQueue(KeyEvt_t, unsigned char)>
 80011de:	3701      	adds	r7, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:24


void Keys_t::ProcessKeysState(bool *PCurrentState) {
//    Uart.Printf("\r%A", PCurrentState, KEYS_CNT, ' ');
    // Iterate keys
    for(uint8_t i=0; i<KEYS_CNT; i++) {
 80011e0:	2f04      	cmp	r7, #4
 80011e2:	f105 0503 	add.w	r5, r5, #3
 80011e6:	d189      	bne.n	80010fc <Keys_t::ProcessKeysState(bool*)+0xc>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:103
                }
            }
        } // if still pressed
#endif
    } // for i
}
 80011e8:	b002      	add	sp, #8
 80011ea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80011ee:	bf00      	nop
 80011f0:	200017c0 	.word	0x200017c0
	...

08001200 <ProcessKeyState(void*)>:
_Z15ProcessKeyStatePv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:15
#include "evt_mask.h"
#include "SimpleSensors.h"

Keys_t Keys;

void ProcessKeyState(void *p) {
 8001200:	4603      	mov	r3, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/keys.cpp:17
    SnsGroup_t *grp = (SnsGroup_t*)p;
    Keys.ProcessKeysState(grp->WasHi);
 8001202:	6959      	ldr	r1, [r3, #20]
 8001204:	4801      	ldr	r0, [pc, #4]	; (800120c <ProcessKeyState(void*)+0xc>)
 8001206:	f7ff bf73 	b.w	80010f0 <Keys_t::ProcessKeysState(bool*)>
 800120a:	bf00      	nop
 800120c:	2000098c 	.word	0x2000098c

08001210 <PinClockEnable(GPIO_TypeDef*)>:
PinClockEnable():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:183
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001210:	4b12      	ldr	r3, [pc, #72]	; (800125c <PinClockEnable(GPIO_TypeDef*)+0x4c>)
 8001212:	4298      	cmp	r0, r3
 8001214:	d105      	bne.n	8001222 <PinClockEnable(GPIO_TypeDef*)+0x12>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:183 (discriminator 1)
 8001216:	f503 5360 	add.w	r3, r3, #14336	; 0x3800
 800121a:	69da      	ldr	r2, [r3, #28]
 800121c:	f042 0201 	orr.w	r2, r2, #1
 8001220:	e019      	b.n	8001256 <PinClockEnable(GPIO_TypeDef*)+0x46>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:184
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8001222:	4b0f      	ldr	r3, [pc, #60]	; (8001260 <PinClockEnable(GPIO_TypeDef*)+0x50>)
 8001224:	4298      	cmp	r0, r3
 8001226:	d105      	bne.n	8001234 <PinClockEnable(GPIO_TypeDef*)+0x24>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:184 (discriminator 1)
 8001228:	f503 5350 	add.w	r3, r3, #13312	; 0x3400
 800122c:	69da      	ldr	r2, [r3, #28]
 800122e:	f042 0202 	orr.w	r2, r2, #2
 8001232:	e010      	b.n	8001256 <PinClockEnable(GPIO_TypeDef*)+0x46>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:185
    else if(PGpioPort == GPIOC) RCC->AHBENR |= RCC_AHBENR_GPIOCEN;
 8001234:	4b0b      	ldr	r3, [pc, #44]	; (8001264 <PinClockEnable(GPIO_TypeDef*)+0x54>)
 8001236:	4298      	cmp	r0, r3
 8001238:	d105      	bne.n	8001246 <PinClockEnable(GPIO_TypeDef*)+0x36>
 800123a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800123e:	69da      	ldr	r2, [r3, #28]
 8001240:	f042 0204 	orr.w	r2, r2, #4
 8001244:	e007      	b.n	8001256 <PinClockEnable(GPIO_TypeDef*)+0x46>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:186
    else if(PGpioPort == GPIOD) RCC->AHBENR |= RCC_AHBENR_GPIODEN;
 8001246:	4b08      	ldr	r3, [pc, #32]	; (8001268 <PinClockEnable(GPIO_TypeDef*)+0x58>)
 8001248:	4298      	cmp	r0, r3
 800124a:	d105      	bne.n	8001258 <PinClockEnable(GPIO_TypeDef*)+0x48>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:186 (discriminator 1)
 800124c:	f503 5330 	add.w	r3, r3, #11264	; 0x2c00
 8001250:	69da      	ldr	r2, [r3, #28]
 8001252:	f042 0208 	orr.w	r2, r2, #8
 8001256:	61da      	str	r2, [r3, #28]
 8001258:	4770      	bx	lr
 800125a:	bf00      	nop
 800125c:	40020000 	.word	0x40020000
 8001260:	40020400 	.word	0x40020400
 8001264:	40020800 	.word	0x40020800
 8001268:	40020c00 	.word	0x40020c00
$d():
 800126c:	00000000 	.word	0x00000000

08001270 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>:
_ZN9CmdUart_t8PrintNowEPKc():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.h:74
#endif
public:
    void Printf(const char *S, ...);
    void PrintfI(const char *S, ...);
    void FlushTx() { while(!IDmaIsIdle); }  // wait DMA
    void PrintNow(const char *S) {
 8001270:	3801      	subs	r0, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.h:75
        while(*S != 0) {
 8001272:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8001276:	b12b      	cbz	r3, 8001284 <CmdUart_t::PrintNow(char const*) [clone .isra.12]+0x14>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.h:76
            while(!(UART->SR & USART_SR_TXE));
 8001278:	4a03      	ldr	r2, [pc, #12]	; (8001288 <CmdUart_t::PrintNow(char const*) [clone .isra.12]+0x18>)
 800127a:	8811      	ldrh	r1, [r2, #0]
 800127c:	0609      	lsls	r1, r1, #24
 800127e:	d5fb      	bpl.n	8001278 <CmdUart_t::PrintNow(char const*) [clone .isra.12]+0x8>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.h:77
            UART->DR = *S++;
 8001280:	8093      	strh	r3, [r2, #4]
 8001282:	e7f6      	b.n	8001272 <CmdUart_t::PrintNow(char const*) [clone .isra.12]+0x2>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.h:79
        }
    }
 8001284:	4770      	bx	lr
 8001286:	bf00      	nop
 8001288:	40013800 	.word	0x40013800
$d():
 800128c:	00000000 	.word	0x00000000

08001290 <PinSetupAlterFunc(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinAF_t, PinSpeed_t) [clone .constprop.13]>:
PinSetupAlterFunc():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:234
    PGpioPort->MODER |= 0b11 << (APinNumber*2);  // Set new bits
    // Disable pull-up/down
    PGpioPort->PUPDR &= ~(0b11 << (APinNumber*2)); // clear previous bits
}

static inline void PinSetupAlterFunc(
 8001290:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001292:	460d      	mov	r5, r1
 8001294:	4604      	mov	r4, r0
 8001296:	4616      	mov	r6, r2
 8001298:	461f      	mov	r7, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:242
        const PinOutMode_t PinOutMode,
        const PinPullUpDown_t APullUpDown,
        const PinAF_t AAlterFunc,
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
 800129a:	f7ff ffb9 	bl	8001210 <PinClockEnable(GPIO_TypeDef*)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:243
    uint32_t Offset = APinNumber*2;
 800129e:	0068      	lsls	r0, r5, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:245
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 80012a0:	2103      	movs	r1, #3
 80012a2:	4081      	lsls	r1, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:246
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 80012a4:	2202      	movs	r2, #2
 80012a6:	fa02 f000 	lsl.w	r0, r2, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:245
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 80012aa:	6823      	ldr	r3, [r4, #0]
 80012ac:	43c9      	mvns	r1, r1
 80012ae:	400b      	ands	r3, r1
 80012b0:	6023      	str	r3, [r4, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:246
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 80012b2:	6823      	ldr	r3, [r4, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:249
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 80012b4:	40ae      	lsls	r6, r5
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:246
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 80012b6:	4303      	orrs	r3, r0
 80012b8:	6023      	str	r3, [r4, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:248
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 80012ba:	2301      	movs	r3, #1
 80012bc:	40ab      	lsls	r3, r5
 80012be:	88a2      	ldrh	r2, [r4, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:257
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
 80012c0:	2d07      	cmp	r5, #7
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:248
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 80012c2:	b292      	uxth	r2, r2
 80012c4:	ea22 0303 	bic.w	r3, r2, r3
 80012c8:	80a3      	strh	r3, [r4, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:249
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 80012ca:	88a3      	ldrh	r3, [r4, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:258
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
 80012cc:	bf88      	it	hi
 80012ce:	3d08      	subhi	r5, #8
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:249
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 80012d0:	ea46 0603 	orr.w	r6, r6, r3
 80012d4:	b2b6      	uxth	r6, r6
 80012d6:	80a6      	strh	r6, [r4, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:251
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 80012d8:	68e3      	ldr	r3, [r4, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:258
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
 80012da:	ea4f 0585 	mov.w	r5, r5, lsl #2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:251
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 80012de:	ea01 0303 	and.w	r3, r1, r3
 80012e2:	60e3      	str	r3, [r4, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:252
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 80012e4:	68e3      	ldr	r3, [r4, #12]
 80012e6:	60e3      	str	r3, [r4, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:254
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 80012e8:	68a3      	ldr	r3, [r4, #8]
 80012ea:	ea01 0103 	and.w	r1, r1, r3
 80012ee:	60a1      	str	r1, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:255
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 80012f0:	68a3      	ldr	r3, [r4, #8]
 80012f2:	ea40 0003 	orr.w	r0, r0, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:257
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
 80012f6:	bf94      	ite	ls
 80012f8:	2300      	movls	r3, #0
 80012fa:	2301      	movhi	r3, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:255
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 80012fc:	60a0      	str	r0, [r4, #8]
 80012fe:	eb04 0483 	add.w	r4, r4, r3, lsl #2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:259
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001302:	230f      	movs	r3, #15
 8001304:	40ab      	lsls	r3, r5
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:260
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8001306:	fa07 f505 	lsl.w	r5, r7, r5
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:259
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 800130a:	6a22      	ldr	r2, [r4, #32]
 800130c:	ea22 0303 	bic.w	r3, r2, r3
 8001310:	6223      	str	r3, [r4, #32]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:260
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8001312:	6a23      	ldr	r3, [r4, #32]
 8001314:	431d      	orrs	r5, r3
 8001316:	6225      	str	r5, [r4, #32]
 8001318:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
_ZL17PinSetupAlterFuncP12GPIO_TypeDeft12PinOutMode_t15PinPullUpDown_t7PinAF_t10PinSpeed_t.constprop.13():
 800131a:	0000      	movs	r0, r0
 800131c:	0000      	movs	r0, r0
	...

08001320 <Timer_t::InitClock(TIM_TypeDef*)>:
_ZN7Timer_t9InitClockEP11TIM_TypeDef():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:15
#include <string.h>
#include <uart.h>

#if 1 // ============================= Timer ===================================
void Timer_t::InitClock(TIM_TypeDef *Tmr) {
    if     (Tmr == TIM2)  { rccEnableTIM2(FALSE); }
 8001320:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8001324:	d104      	bne.n	8001330 <Timer_t::InitClock(TIM_TypeDef*)+0x10>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:15 (discriminator 1)
 8001326:	4b23      	ldr	r3, [pc, #140]	; (80013b4 <Timer_t::InitClock(TIM_TypeDef*)+0x94>)
 8001328:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800132a:	f042 0201 	orr.w	r2, r2, #1
 800132e:	e007      	b.n	8001340 <Timer_t::InitClock(TIM_TypeDef*)+0x20>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:16
    else if(Tmr == TIM3)  { rccEnableTIM3(FALSE); }
 8001330:	4b21      	ldr	r3, [pc, #132]	; (80013b8 <Timer_t::InitClock(TIM_TypeDef*)+0x98>)
 8001332:	4298      	cmp	r0, r3
 8001334:	d106      	bne.n	8001344 <Timer_t::InitClock(TIM_TypeDef*)+0x24>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:16 (discriminator 1)
 8001336:	f503 330d 	add.w	r3, r3, #144384	; 0x23400
 800133a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800133c:	f042 0202 	orr.w	r2, r2, #2
 8001340:	625a      	str	r2, [r3, #36]	; 0x24
 8001342:	4770      	bx	lr
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:17
    else if(Tmr == TIM4)  { rccEnableTIM4(FALSE); }
 8001344:	4b1d      	ldr	r3, [pc, #116]	; (80013bc <Timer_t::InitClock(TIM_TypeDef*)+0x9c>)
 8001346:	4298      	cmp	r0, r3
 8001348:	d105      	bne.n	8001356 <Timer_t::InitClock(TIM_TypeDef*)+0x36>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:17 (discriminator 1)
 800134a:	f503 330c 	add.w	r3, r3, #143360	; 0x23000
 800134e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001350:	f042 0204 	orr.w	r2, r2, #4
 8001354:	e7f4      	b.n	8001340 <Timer_t::InitClock(TIM_TypeDef*)+0x20>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:18
    else if(Tmr == TIM6)  { rccEnableAPB1(RCC_APB1ENR_TIM6EN,  FALSE); }
 8001356:	4b1a      	ldr	r3, [pc, #104]	; (80013c0 <Timer_t::InitClock(TIM_TypeDef*)+0xa0>)
 8001358:	4298      	cmp	r0, r3
 800135a:	d105      	bne.n	8001368 <Timer_t::InitClock(TIM_TypeDef*)+0x48>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:18 (discriminator 1)
 800135c:	f503 330a 	add.w	r3, r3, #141312	; 0x22800
 8001360:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001362:	f042 0210 	orr.w	r2, r2, #16
 8001366:	e7eb      	b.n	8001340 <Timer_t::InitClock(TIM_TypeDef*)+0x20>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:19
    else if(Tmr == TIM7)  { rccEnableAPB1(RCC_APB1ENR_TIM7EN,  FALSE); }
 8001368:	4b16      	ldr	r3, [pc, #88]	; (80013c4 <Timer_t::InitClock(TIM_TypeDef*)+0xa4>)
 800136a:	4298      	cmp	r0, r3
 800136c:	d105      	bne.n	800137a <Timer_t::InitClock(TIM_TypeDef*)+0x5a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:19 (discriminator 1)
 800136e:	f503 3309 	add.w	r3, r3, #140288	; 0x22400
 8001372:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001374:	f042 0220 	orr.w	r2, r2, #32
 8001378:	e7e2      	b.n	8001340 <Timer_t::InitClock(TIM_TypeDef*)+0x20>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:20
    else if(Tmr == TIM9)  { rccEnableAPB2(RCC_APB2ENR_TIM9EN,  FALSE); }
 800137a:	4b13      	ldr	r3, [pc, #76]	; (80013c8 <Timer_t::InitClock(TIM_TypeDef*)+0xa8>)
 800137c:	4298      	cmp	r0, r3
 800137e:	d105      	bne.n	800138c <Timer_t::InitClock(TIM_TypeDef*)+0x6c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:20 (discriminator 1)
 8001380:	f503 3398 	add.w	r3, r3, #77824	; 0x13000
 8001384:	6a1a      	ldr	r2, [r3, #32]
 8001386:	f042 0204 	orr.w	r2, r2, #4
 800138a:	e010      	b.n	80013ae <Timer_t::InitClock(TIM_TypeDef*)+0x8e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:21
    else if(Tmr == TIM10) { rccEnableAPB2(RCC_APB2ENR_TIM10EN, FALSE); }
 800138c:	4b0f      	ldr	r3, [pc, #60]	; (80013cc <Timer_t::InitClock(TIM_TypeDef*)+0xac>)
 800138e:	4298      	cmp	r0, r3
 8001390:	d105      	bne.n	800139e <Timer_t::InitClock(TIM_TypeDef*)+0x7e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:21 (discriminator 1)
 8001392:	f503 3396 	add.w	r3, r3, #76800	; 0x12c00
 8001396:	6a1a      	ldr	r2, [r3, #32]
 8001398:	f042 0208 	orr.w	r2, r2, #8
 800139c:	e007      	b.n	80013ae <Timer_t::InitClock(TIM_TypeDef*)+0x8e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:22
    else if(Tmr == TIM11) { rccEnableAPB2(RCC_APB2ENR_TIM11EN, FALSE); }
 800139e:	4b0c      	ldr	r3, [pc, #48]	; (80013d0 <Timer_t::InitClock(TIM_TypeDef*)+0xb0>)
 80013a0:	4298      	cmp	r0, r3
 80013a2:	d105      	bne.n	80013b0 <Timer_t::InitClock(TIM_TypeDef*)+0x90>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:22 (discriminator 1)
 80013a4:	f503 3394 	add.w	r3, r3, #75776	; 0x12800
 80013a8:	6a1a      	ldr	r2, [r3, #32]
 80013aa:	f042 0210 	orr.w	r2, r2, #16
 80013ae:	621a      	str	r2, [r3, #32]
 80013b0:	4770      	bx	lr
 80013b2:	bf00      	nop
 80013b4:	40023800 	.word	0x40023800
 80013b8:	40000400 	.word	0x40000400
 80013bc:	40000800 	.word	0x40000800
 80013c0:	40001000 	.word	0x40001000
 80013c4:	40001400 	.word	0x40001400
 80013c8:	40010800 	.word	0x40010800
 80013cc:	40010c00 	.word	0x40010c00
 80013d0:	40011000 	.word	0x40011000
	...

080013e0 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)>:
_ZN7Timer_t7InitPwmEP11TIM_TypeDefP12GPIO_TypeDefthm10Inverted_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:25
}

void Timer_t::InitPwm(TIM_TypeDef* Tmr, GPIO_TypeDef *GPIO, uint16_t N, uint8_t Chnl, uint32_t ATopValue, Inverted_t Inverted) {
 80013e0:	b538      	push	{r3, r4, r5, lr}
 80013e2:	4604      	mov	r4, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:27
    // GPIO
    if              (Tmr == TIM2)              PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF1);
 80013e4:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:25
    else if(Tmr == TIM9)  { rccEnableAPB2(RCC_APB2ENR_TIM9EN,  FALSE); }
    else if(Tmr == TIM10) { rccEnableAPB2(RCC_APB2ENR_TIM10EN, FALSE); }
    else if(Tmr == TIM11) { rccEnableAPB2(RCC_APB2ENR_TIM11EN, FALSE); }
}

void Timer_t::InitPwm(TIM_TypeDef* Tmr, GPIO_TypeDef *GPIO, uint16_t N, uint8_t Chnl, uint32_t ATopValue, Inverted_t Inverted) {
 80013e8:	4608      	mov	r0, r1
 80013ea:	461d      	mov	r5, r3
 80013ec:	4611      	mov	r1, r2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:27
    // GPIO
    if              (Tmr == TIM2)              PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF1);
 80013ee:	d102      	bne.n	80013f6 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0x16>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:27 (discriminator 1)
 80013f0:	2200      	movs	r2, #0
 80013f2:	2301      	movs	r3, #1
 80013f4:	e016      	b.n	8001424 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0x44>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:28
    else if(ANY_OF_2(Tmr, TIM3, TIM4))         PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF2);
 80013f6:	4b29      	ldr	r3, [pc, #164]	; (800149c <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0xbc>)
 80013f8:	429c      	cmp	r4, r3
 80013fa:	d003      	beq.n	8001404 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0x24>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:28 (discriminator 2)
 80013fc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001400:	429c      	cmp	r4, r3
 8001402:	d102      	bne.n	800140a <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0x2a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:28 (discriminator 1)
 8001404:	2200      	movs	r2, #0
 8001406:	2302      	movs	r3, #2
 8001408:	e00c      	b.n	8001424 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0x44>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:29
    else if(ANY_OF_3(Tmr, TIM9, TIM10, TIM11)) PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF3);
 800140a:	4b25      	ldr	r3, [pc, #148]	; (80014a0 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0xc0>)
 800140c:	429c      	cmp	r4, r3
 800140e:	d007      	beq.n	8001420 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0x40>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:29 (discriminator 2)
 8001410:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001414:	429c      	cmp	r4, r3
 8001416:	d003      	beq.n	8001420 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0x40>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:29 (discriminator 1)
 8001418:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800141c:	429c      	cmp	r4, r3
 800141e:	d103      	bne.n	8001428 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0x48>
 8001420:	2200      	movs	r2, #0
 8001422:	2303      	movs	r3, #3
 8001424:	f7ff ff34 	bl	8001290 <PinSetupAlterFunc(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinAF_t, PinSpeed_t) [clone .constprop.13]>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:30
    Tmr->ARR = ATopValue;
 8001428:	9b04      	ldr	r3, [sp, #16]
 800142a:	62e3      	str	r3, [r4, #44]	; 0x2c
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:32
    // Output
    uint16_t tmp = (Inverted == invInverted)? 0b111 : 0b110; // PWM mode 1 or 2
 800142c:	f89d 3014 	ldrb.w	r3, [sp, #20]
 8001430:	2b01      	cmp	r3, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:33
    switch(Chnl) {
 8001432:	f105 33ff 	add.w	r3, r5, #4294967295
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:32
    if              (Tmr == TIM2)              PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF1);
    else if(ANY_OF_2(Tmr, TIM3, TIM4))         PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF2);
    else if(ANY_OF_3(Tmr, TIM9, TIM10, TIM11)) PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF3);
    Tmr->ARR = ATopValue;
    // Output
    uint16_t tmp = (Inverted == invInverted)? 0b111 : 0b110; // PWM mode 1 or 2
 8001436:	bf14      	ite	ne
 8001438:	2206      	movne	r2, #6
 800143a:	2207      	moveq	r2, #7
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:33
    switch(Chnl) {
 800143c:	2b03      	cmp	r3, #3
 800143e:	d82b      	bhi.n	8001498 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0xb8>
 8001440:	e8df f003 	tbb	[pc, r3]
 8001444:	20160c02 	.word	0x20160c02
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:35
        case 1:
            Tmr->CCMR1 |= (tmp << 4);
 8001448:	8b23      	ldrh	r3, [r4, #24]
 800144a:	b29b      	uxth	r3, r3
 800144c:	ea43 1202 	orr.w	r2, r3, r2, lsl #4
 8001450:	8322      	strh	r2, [r4, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:36
            Tmr->CCER  |= TIM_CCER_CC1E;
 8001452:	8c23      	ldrh	r3, [r4, #32]
 8001454:	b29b      	uxth	r3, r3
 8001456:	f043 0301 	orr.w	r3, r3, #1
 800145a:	e01c      	b.n	8001496 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0xb6>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:40
            break;

        case 2:
            Tmr->CCMR1 |= (tmp << 12);
 800145c:	8b23      	ldrh	r3, [r4, #24]
 800145e:	b29b      	uxth	r3, r3
 8001460:	ea43 3202 	orr.w	r2, r3, r2, lsl #12
 8001464:	8322      	strh	r2, [r4, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:41
            Tmr->CCER  |= TIM_CCER_CC2E;
 8001466:	8c23      	ldrh	r3, [r4, #32]
 8001468:	b29b      	uxth	r3, r3
 800146a:	f043 0310 	orr.w	r3, r3, #16
 800146e:	e012      	b.n	8001496 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0xb6>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:45
            break;

        case 3:
            Tmr->CCMR2 |= (tmp << 4);
 8001470:	8ba3      	ldrh	r3, [r4, #28]
 8001472:	b29b      	uxth	r3, r3
 8001474:	ea43 1202 	orr.w	r2, r3, r2, lsl #4
 8001478:	83a2      	strh	r2, [r4, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:46
            Tmr->CCER  |= TIM_CCER_CC3E;
 800147a:	8c23      	ldrh	r3, [r4, #32]
 800147c:	b29b      	uxth	r3, r3
 800147e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001482:	e008      	b.n	8001496 <Timer_t::InitPwm(TIM_TypeDef*, GPIO_TypeDef*, unsigned short, unsigned char, unsigned long, Inverted_t)+0xb6>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:50
            break;

        case 4:
            Tmr->CCMR2 |= (tmp << 12);
 8001484:	8ba3      	ldrh	r3, [r4, #28]
 8001486:	b29b      	uxth	r3, r3
 8001488:	ea43 3202 	orr.w	r2, r3, r2, lsl #12
 800148c:	83a2      	strh	r2, [r4, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:51
            Tmr->CCER  |= TIM_CCER_CC4E;
 800148e:	8c23      	ldrh	r3, [r4, #32]
 8001490:	b29b      	uxth	r3, r3
 8001492:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001496:	8423      	strh	r3, [r4, #32]
 8001498:	bd38      	pop	{r3, r4, r5, pc}
 800149a:	bf00      	nop
 800149c:	40000400 	.word	0x40000400
 80014a0:	40010800 	.word	0x40010800
	...

080014b0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)>:
_ZN8PwmPin_t4InitEP12GPIO_TypeDeftP11TIM_TypeDefhtb():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:60
    }
}
#endif

#if 1 // ============================= PWM pin =================================
void PwmPin_t::Init(GPIO_TypeDef *GPIO, uint16_t N, TIM_TypeDef* PTim, uint8_t Chnl, uint16_t TopValue, bool Inverted) {
 80014b0:	b510      	push	{r4, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:62
    Tim = PTim;
    if(Tim == TIM2) {
 80014b2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:60
    }
}
#endif

#if 1 // ============================= PWM pin =================================
void PwmPin_t::Init(GPIO_TypeDef *GPIO, uint16_t N, TIM_TypeDef* PTim, uint8_t Chnl, uint16_t TopValue, bool Inverted) {
 80014b6:	4604      	mov	r4, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:61
    Tim = PTim;
 80014b8:	6063      	str	r3, [r4, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:60
    }
}
#endif

#if 1 // ============================= PWM pin =================================
void PwmPin_t::Init(GPIO_TypeDef *GPIO, uint16_t N, TIM_TypeDef* PTim, uint8_t Chnl, uint16_t TopValue, bool Inverted) {
 80014ba:	4608      	mov	r0, r1
 80014bc:	4611      	mov	r1, r2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:62
    Tim = PTim;
    if(Tim == TIM2) {
 80014be:	d108      	bne.n	80014d2 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x22>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:63
        rccEnableTIM2(FALSE);
 80014c0:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
 80014c4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80014c6:	f042 0201 	orr.w	r2, r2, #1
 80014ca:	625a      	str	r2, [r3, #36]	; 0x24
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:64
        PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF1);
 80014cc:	2200      	movs	r2, #0
 80014ce:	2301      	movs	r3, #1
 80014d0:	e02c      	b.n	800152c <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x7c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:66
    }
    else if(Tim == TIM3) {
 80014d2:	4a46      	ldr	r2, [pc, #280]	; (80015ec <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x13c>)
 80014d4:	4293      	cmp	r3, r2
 80014d6:	d104      	bne.n	80014e2 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x32>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:67
        rccEnableTIM3(FALSE);
 80014d8:	4b45      	ldr	r3, [pc, #276]	; (80015f0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x140>)
 80014da:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80014dc:	f042 0202 	orr.w	r2, r2, #2
 80014e0:	e006      	b.n	80014f0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x40>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:70
        PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF2);
    }
    else if(Tim == TIM4) {
 80014e2:	4a44      	ldr	r2, [pc, #272]	; (80015f4 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x144>)
 80014e4:	4293      	cmp	r3, r2
 80014e6:	d107      	bne.n	80014f8 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x48>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:71
        rccEnableTIM4(FALSE);
 80014e8:	4b41      	ldr	r3, [pc, #260]	; (80015f0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x140>)
 80014ea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80014ec:	f042 0204 	orr.w	r2, r2, #4
 80014f0:	625a      	str	r2, [r3, #36]	; 0x24
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:72
        PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF2);
 80014f2:	2200      	movs	r2, #0
 80014f4:	2302      	movs	r3, #2
 80014f6:	e019      	b.n	800152c <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x7c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:74
    }
    else if(Tim == TIM9) {
 80014f8:	4a3f      	ldr	r2, [pc, #252]	; (80015f8 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x148>)
 80014fa:	4293      	cmp	r3, r2
 80014fc:	d104      	bne.n	8001508 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x58>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:75
        rccEnableTIM9(FALSE);
 80014fe:	4b3c      	ldr	r3, [pc, #240]	; (80015f0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x140>)
 8001500:	6a1a      	ldr	r2, [r3, #32]
 8001502:	f042 0204 	orr.w	r2, r2, #4
 8001506:	e00e      	b.n	8001526 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x76>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:78
        PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF3);
    }
    else if(Tim == TIM10) {
 8001508:	4a3c      	ldr	r2, [pc, #240]	; (80015fc <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x14c>)
 800150a:	4293      	cmp	r3, r2
 800150c:	d104      	bne.n	8001518 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x68>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:79
        rccEnableAPB2(RCC_APB2ENR_TIM10EN, FALSE);
 800150e:	4b38      	ldr	r3, [pc, #224]	; (80015f0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x140>)
 8001510:	6a1a      	ldr	r2, [r3, #32]
 8001512:	f042 0208 	orr.w	r2, r2, #8
 8001516:	e006      	b.n	8001526 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x76>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:82
        PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF3);
    }
    else if(Tim == TIM11) {
 8001518:	4a39      	ldr	r2, [pc, #228]	; (8001600 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x150>)
 800151a:	4293      	cmp	r3, r2
 800151c:	d108      	bne.n	8001530 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x80>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:83
        rccEnableAPB2(RCC_APB2ENR_TIM11EN, FALSE);
 800151e:	4b34      	ldr	r3, [pc, #208]	; (80015f0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x140>)
 8001520:	6a1a      	ldr	r2, [r3, #32]
 8001522:	f042 0210 	orr.w	r2, r2, #16
 8001526:	621a      	str	r2, [r3, #32]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:84
        PinSetupAlterFunc(GPIO, N, omPushPull, pudNone, AF3);
 8001528:	2200      	movs	r2, #0
 800152a:	2303      	movs	r3, #3
 800152c:	f7ff feb0 	bl	8001290 <PinSetupAlterFunc(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinAF_t, PinSpeed_t) [clone .constprop.13]>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:87
    }
    // Clock src
    if(ANY_OF_3(Tim, TIM2, TIM3, TIM4)) PClk = &Clk.APB1FreqHz;
 8001530:	6863      	ldr	r3, [r4, #4]
 8001532:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8001536:	d006      	beq.n	8001546 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x96>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:87 (discriminator 2)
 8001538:	4a2c      	ldr	r2, [pc, #176]	; (80015ec <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x13c>)
 800153a:	4293      	cmp	r3, r2
 800153c:	d003      	beq.n	8001546 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x96>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:87 (discriminator 1)
 800153e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001542:	4293      	cmp	r3, r2
 8001544:	d101      	bne.n	800154a <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x9a>
 8001546:	4a2f      	ldr	r2, [pc, #188]	; (8001604 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x154>)
 8001548:	e000      	b.n	800154c <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x9c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:88
    else PClk = &Clk.APB2FreqHz;
 800154a:	4a2f      	ldr	r2, [pc, #188]	; (8001608 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x158>)
 800154c:	6022      	str	r2, [r4, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:91

    // Common
    Tim->CR1 = TIM_CR1_CEN; // Enable timer, set clk division to 0, AutoReload not buffered
 800154e:	2201      	movs	r2, #1
 8001550:	801a      	strh	r2, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:92
    Tim->CR2 = 0;
 8001552:	2200      	movs	r2, #0
 8001554:	809a      	strh	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:93
    Tim->ARR = TopValue;
 8001556:	f8bd 200c 	ldrh.w	r2, [sp, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:97

    // Output
    uint16_t tmp = Inverted? 0b111 : 0b110; // PWM mode 1 or 2
    switch(Chnl) {
 800155a:	f89d 1008 	ldrb.w	r1, [sp, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:93
    else PClk = &Clk.APB2FreqHz;

    // Common
    Tim->CR1 = TIM_CR1_CEN; // Enable timer, set clk division to 0, AutoReload not buffered
    Tim->CR2 = 0;
    Tim->ARR = TopValue;
 800155e:	62da      	str	r2, [r3, #44]	; 0x2c
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:96

    // Output
    uint16_t tmp = Inverted? 0b111 : 0b110; // PWM mode 1 or 2
 8001560:	f89d 2010 	ldrb.w	r2, [sp, #16]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:97
    switch(Chnl) {
 8001564:	3901      	subs	r1, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:96
    Tim->CR1 = TIM_CR1_CEN; // Enable timer, set clk division to 0, AutoReload not buffered
    Tim->CR2 = 0;
    Tim->ARR = TopValue;

    // Output
    uint16_t tmp = Inverted? 0b111 : 0b110; // PWM mode 1 or 2
 8001566:	2a00      	cmp	r2, #0
 8001568:	bf0c      	ite	eq
 800156a:	2206      	moveq	r2, #6
 800156c:	2207      	movne	r2, #7
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:97
    switch(Chnl) {
 800156e:	2903      	cmp	r1, #3
 8001570:	d837      	bhi.n	80015e2 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x132>
 8001572:	e8df f001 	tbb	[pc, r1]
 8001576:	0f02      	.short	0x0f02
 8001578:	291c      	.short	0x291c
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:99
        case 1:
            PCCR = &Tim->CCR1;
 800157a:	f103 0134 	add.w	r1, r3, #52	; 0x34
 800157e:	60a1      	str	r1, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:100
            Tim->CCMR1 |= (tmp << 4);
 8001580:	8b19      	ldrh	r1, [r3, #24]
 8001582:	b289      	uxth	r1, r1
 8001584:	ea41 1202 	orr.w	r2, r1, r2, lsl #4
 8001588:	831a      	strh	r2, [r3, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:101
            Tim->CCER  |= TIM_CCER_CC1E;
 800158a:	8c1a      	ldrh	r2, [r3, #32]
 800158c:	b292      	uxth	r2, r2
 800158e:	f042 0201 	orr.w	r2, r2, #1
 8001592:	e025      	b.n	80015e0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x130>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:105
            break;

        case 2:
            PCCR = &Tim->CCR2;
 8001594:	f103 0138 	add.w	r1, r3, #56	; 0x38
 8001598:	60a1      	str	r1, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:106
            Tim->CCMR1 |= (tmp << 12);
 800159a:	8b19      	ldrh	r1, [r3, #24]
 800159c:	b289      	uxth	r1, r1
 800159e:	ea41 3202 	orr.w	r2, r1, r2, lsl #12
 80015a2:	831a      	strh	r2, [r3, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:107
            Tim->CCER  |= TIM_CCER_CC2E;
 80015a4:	8c1a      	ldrh	r2, [r3, #32]
 80015a6:	b292      	uxth	r2, r2
 80015a8:	f042 0210 	orr.w	r2, r2, #16
 80015ac:	e018      	b.n	80015e0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x130>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:111
            break;

        case 3:
            PCCR = &Tim->CCR3;
 80015ae:	f103 013c 	add.w	r1, r3, #60	; 0x3c
 80015b2:	60a1      	str	r1, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:112
            Tim->CCMR2 |= (tmp << 4);
 80015b4:	8b99      	ldrh	r1, [r3, #28]
 80015b6:	b289      	uxth	r1, r1
 80015b8:	ea41 1202 	orr.w	r2, r1, r2, lsl #4
 80015bc:	839a      	strh	r2, [r3, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:113
            Tim->CCER  |= TIM_CCER_CC3E;
 80015be:	8c1a      	ldrh	r2, [r3, #32]
 80015c0:	b292      	uxth	r2, r2
 80015c2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80015c6:	e00b      	b.n	80015e0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)+0x130>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:117
            break;

        case 4:
            PCCR = &Tim->CCR4;
 80015c8:	f103 0140 	add.w	r1, r3, #64	; 0x40
 80015cc:	60a1      	str	r1, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:118
            Tim->CCMR2 |= (tmp << 12);
 80015ce:	8b99      	ldrh	r1, [r3, #28]
 80015d0:	b289      	uxth	r1, r1
 80015d2:	ea41 3202 	orr.w	r2, r1, r2, lsl #12
 80015d6:	839a      	strh	r2, [r3, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:119
            Tim->CCER  |= TIM_CCER_CC4E;
 80015d8:	8c1a      	ldrh	r2, [r3, #32]
 80015da:	b292      	uxth	r2, r2
 80015dc:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80015e0:	841a      	strh	r2, [r3, #32]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:124
            break;

        default: break;
    }
    *PCCR = 0;
 80015e2:	68a3      	ldr	r3, [r4, #8]
 80015e4:	2200      	movs	r2, #0
 80015e6:	601a      	str	r2, [r3, #0]
 80015e8:	bd10      	pop	{r4, pc}
 80015ea:	bf00      	nop
 80015ec:	40000400 	.word	0x40000400
 80015f0:	40023800 	.word	0x40023800
 80015f4:	40000800 	.word	0x40000800
 80015f8:	40010800 	.word	0x40010800
 80015fc:	40010c00 	.word	0x40010c00
 8001600:	40011000 	.word	0x40011000
 8001604:	20000984 	.word	0x20000984
 8001608:	20000988 	.word	0x20000988
$d():
 800160c:	00000000 	.word	0x00000000

08001610 <PwmPin_t::SetFreqHz(unsigned long)>:
_ZN8PwmPin_t9SetFreqHzEm():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:128
}

void PwmPin_t::SetFreqHz(uint32_t FreqHz) {
    uint32_t divider = Tim->ARR * FreqHz;
 8001610:	6843      	ldr	r3, [r0, #4]
 8001612:	6ada      	ldr	r2, [r3, #44]	; 0x2c
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:129
    if(divider == 0) return;
 8001614:	4351      	muls	r1, r2
 8001616:	d007      	beq.n	8001628 <PwmPin_t::SetFreqHz(unsigned long)+0x18>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:130
    uint32_t FPrescaler = *PClk / divider;
 8001618:	6802      	ldr	r2, [r0, #0]
 800161a:	6812      	ldr	r2, [r2, #0]
 800161c:	fbb2 f1f1 	udiv	r1, r2, r1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:131
    if(FPrescaler != 0) FPrescaler--;   // do not decrease in case of high freq
 8001620:	b101      	cbz	r1, 8001624 <PwmPin_t::SetFreqHz(unsigned long)+0x14>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:131 (discriminator 1)
 8001622:	3901      	subs	r1, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:132
    Tim->PSC = (uint16_t)FPrescaler;
 8001624:	b289      	uxth	r1, r1
 8001626:	8519      	strh	r1, [r3, #40]	; 0x28
 8001628:	4770      	bx	lr
 800162a:	0000      	movs	r0, r0
 800162c:	0000      	movs	r0, r0
	...

08001630 <chDbgPanic>:
chDbgPanic():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:137
}
#endif

#if CH_DBG_ENABLED // ========================= DEBUG ==========================
void chDbgPanic(const char *msg1) {
 8001630:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:138
    Uart.PrintNow(msg1);
 8001632:	f7ff fe1d 	bl	8001270 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:139
    Uart.PrintNow(" @");
 8001636:	4806      	ldr	r0, [pc, #24]	; (8001650 <chDbgPanic+0x20>)
 8001638:	f7ff fe1a 	bl	8001270 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:140
    Uart.PrintNow(chThdSelf()->p_name);
 800163c:	4b05      	ldr	r3, [pc, #20]	; (8001654 <chDbgPanic+0x24>)
 800163e:	699b      	ldr	r3, [r3, #24]
 8001640:	6998      	ldr	r0, [r3, #24]
 8001642:	f7ff fe15 	bl	8001270 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:142
    Uart.PrintNow("\r");
}
 8001646:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.cpp:141
#if CH_DBG_ENABLED // ========================= DEBUG ==========================
void chDbgPanic(const char *msg1) {
    Uart.PrintNow(msg1);
    Uart.PrintNow(" @");
    Uart.PrintNow(chThdSelf()->p_name);
    Uart.PrintNow("\r");
 800164a:	4803      	ldr	r0, [pc, #12]	; (8001658 <chDbgPanic+0x28>)
 800164c:	f7ff be10 	b.w	8001270 <CmdUart_t::PrintNow(char const*) [clone .isra.12]>
 8001650:	080023e0 	.word	0x080023e0
 8001654:	20001704 	.word	0x20001704
 8001658:	080023e3 	.word	0x080023e3
$d():
 800165c:	00000000 	.word	0x00000000

08001660 <IPutUint.4105>:
IPutUint():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:11
    uint32_t CharCnt = 0, width = 0;
    bool zero_padded = false;
    // Print number n to buffer p in base base. If number is shorter
    // than width, it's prepended with spaces or zeros (if zero_padded
    // is set) from the left.
    void IPutUint(uint32_t n, uint32_t base) {
 8001660:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001662:	4664      	mov	r4, ip
 8001664:	b085      	sub	sp, #20
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:13
        char digits[10];
        uint32_t len = 0;
 8001666:	2500      	movs	r5, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:16
        // Place digits to buffer
        do {
            uint32_t digit = n % base;
 8001668:	fbb0 f3f1 	udiv	r3, r0, r1
 800166c:	fb01 0213 	mls	r2, r1, r3, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:18
            n /= base;
            digits[len++] = (digit < 10)? '0'+digit : 'A'+digit-10;
 8001670:	2a09      	cmp	r2, #9
 8001672:	f105 0501 	add.w	r5, r5, #1
 8001676:	bf94      	ite	ls
 8001678:	3230      	addls	r2, #48	; 0x30
 800167a:	3237      	addhi	r2, #55	; 0x37
 800167c:	ae01      	add	r6, sp, #4
 800167e:	b2d2      	uxtb	r2, r2
 8001680:	1977      	adds	r7, r6, r5
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:17
        char digits[10];
        uint32_t len = 0;
        // Place digits to buffer
        do {
            uint32_t digit = n % base;
            n /= base;
 8001682:	4618      	mov	r0, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:18
            digits[len++] = (digit < 10)? '0'+digit : 'A'+digit-10;
 8001684:	f807 2c01 	strb.w	r2, [r7, #-1]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:19
        } while(n > 0);
 8001688:	2b00      	cmp	r3, #0
 800168a:	d1ed      	bne.n	8001668 <IPutUint.4105+0x8>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:18
        uint32_t len = 0;
        // Place digits to buffer
        do {
            uint32_t digit = n % base;
            n /= base;
            digits[len++] = (digit < 10)? '0'+digit : 'A'+digit-10;
 800168c:	462f      	mov	r7, r5
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:21 (discriminator 1)
        } while(n > 0);
        // Add padding
        for(uint32_t i = len; i < width; i++) {
 800168e:	6823      	ldr	r3, [r4, #0]
 8001690:	429d      	cmp	r5, r3
 8001692:	d20e      	bcs.n	80016b2 <IPutUint.4105+0x52>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:22
            if(zero_padded) PPutChar('0');
 8001694:	7c22      	ldrb	r2, [r4, #16]
 8001696:	68e3      	ldr	r3, [r4, #12]
 8001698:	b10a      	cbz	r2, 800169e <IPutUint.4105+0x3e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:22 (discriminator 1)
 800169a:	2030      	movs	r0, #48	; 0x30
 800169c:	e000      	b.n	80016a0 <IPutUint.4105+0x40>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:23
            else            PPutChar(' ');
 800169e:	2020      	movs	r0, #32
 80016a0:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:24
            if(++CharCnt >= MaxLength) return;
 80016a2:	68a3      	ldr	r3, [r4, #8]
 80016a4:	6862      	ldr	r2, [r4, #4]
 80016a6:	3301      	adds	r3, #1
 80016a8:	4293      	cmp	r3, r2
 80016aa:	60a3      	str	r3, [r4, #8]
 80016ac:	d20f      	bcs.n	80016ce <IPutUint.4105+0x6e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:21
            uint32_t digit = n % base;
            n /= base;
            digits[len++] = (digit < 10)? '0'+digit : 'A'+digit-10;
        } while(n > 0);
        // Add padding
        for(uint32_t i = len; i < width; i++) {
 80016ae:	3501      	adds	r5, #1
 80016b0:	e7ed      	b.n	800168e <IPutUint.4105+0x2e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:27
            if(zero_padded) PPutChar('0');
            else            PPutChar(' ');
            if(++CharCnt >= MaxLength) return;
        }
        // Print digits
        len = (len < (MaxLength - CharCnt))? len : (MaxLength - CharCnt);
 80016b2:	68a3      	ldr	r3, [r4, #8]
 80016b4:	6865      	ldr	r5, [r4, #4]
 80016b6:	1aed      	subs	r5, r5, r3
 80016b8:	42af      	cmp	r7, r5
 80016ba:	bf38      	it	cc
 80016bc:	463d      	movcc	r5, r7
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:28
        CharCnt += len;
 80016be:	442b      	add	r3, r5
 80016c0:	60a3      	str	r3, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:29 (discriminator 1)
        while(len > 0) PPutChar(digits[--len]);
 80016c2:	b125      	cbz	r5, 80016ce <IPutUint.4105+0x6e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:29 (discriminator 2)
 80016c4:	3d01      	subs	r5, #1
 80016c6:	68e3      	ldr	r3, [r4, #12]
 80016c8:	5d70      	ldrb	r0, [r6, r5]
 80016ca:	4798      	blx	r3
 80016cc:	e7f9      	b.n	80016c2 <IPutUint.4105+0x62>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:30
    } // IPutUint
 80016ce:	b005      	add	sp, #20
 80016d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080016e0 <kl_vsprintf>:
kl_vsprintf():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:5
#include "kl_sprintf.h"
#include <stdint.h>
#include <stdbool.h>

uint32_t kl_vsprintf(ftVoidChar PPutChar, uint32_t MaxLength, const char *format, va_list args) {
 80016e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80016e4:	461c      	mov	r4, r3
 80016e6:	b087      	sub	sp, #28
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:6
    uint32_t CharCnt = 0, width = 0;
 80016e8:	2300      	movs	r3, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:5
#include "kl_sprintf.h"
#include <stdint.h>
#include <stdbool.h>

uint32_t kl_vsprintf(ftVoidChar PPutChar, uint32_t MaxLength, const char *format, va_list args) {
 80016ea:	9004      	str	r0, [sp, #16]
 80016ec:	9102      	str	r1, [sp, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:6
    uint32_t CharCnt = 0, width = 0;
 80016ee:	9303      	str	r3, [sp, #12]
 80016f0:	9301      	str	r3, [sp, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:7
    bool zero_padded = false;
 80016f2:	f88d 3014 	strb.w	r3, [sp, #20]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:34 (discriminator 1)
        while(len > 0) PPutChar(digits[--len]);
    } // IPutUint

    const char *f = format;
    char c;
    while((c = *f++) != 0) {
 80016f6:	7810      	ldrb	r0, [r2, #0]
 80016f8:	1c56      	adds	r6, r2, #1
 80016fa:	b150      	cbz	r0, 8001712 <kl_vsprintf+0x32>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:35
        if(c != '%') {
 80016fc:	2825      	cmp	r0, #37	; 0x25
 80016fe:	d00c      	beq.n	800171a <kl_vsprintf+0x3a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:36
            PPutChar(c);
 8001700:	9b04      	ldr	r3, [sp, #16]
 8001702:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:37
            if(++CharCnt >= MaxLength) break;
 8001704:	9b03      	ldr	r3, [sp, #12]
 8001706:	9a02      	ldr	r2, [sp, #8]
 8001708:	3301      	adds	r3, #1
 800170a:	4293      	cmp	r3, r2
 800170c:	9303      	str	r3, [sp, #12]
 800170e:	f0c0 8095 	bcc.w	800183c <kl_vsprintf+0x15c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:89
                if(CharCnt >= MaxLength) break;
            }
        }
        if(CharCnt >= MaxLength) break;
    }
    return CharCnt;
 8001712:	9803      	ldr	r0, [sp, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:90
}
 8001714:	b007      	add	sp, #28
 8001716:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:43
            else continue;
        }

        // Here goes optional width specification.
        // If it starts with zero (zero_padded is true), it means we use '0' instead of ' ' as a filler.
        width = 0;
 800171a:	2200      	movs	r2, #0
 800171c:	9201      	str	r2, [sp, #4]
 800171e:	4611      	mov	r1, r2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:46
        zero_padded = false;
        while(true) {
            c = *f++;
 8001720:	f816 3b01 	ldrb.w	r3, [r6], #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:47
            if(c < '0' || c > '9') break;
 8001724:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
 8001728:	b2c5      	uxtb	r5, r0
 800172a:	2d09      	cmp	r5, #9
 800172c:	d807      	bhi.n	800173e <kl_vsprintf+0x5e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:48
            if((width == 0) && (c == '0')) zero_padded = true;
 800172e:	b912      	cbnz	r2, 8001736 <kl_vsprintf+0x56>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:48 (discriminator 1)
 8001730:	2b30      	cmp	r3, #48	; 0x30
 8001732:	bf08      	it	eq
 8001734:	2101      	moveq	r1, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:50
            width *= 10;
            width += c-'0';
 8001736:	230a      	movs	r3, #10
 8001738:	fb03 0202 	mla	r2, r3, r2, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:51
        }
 800173c:	e7f0      	b.n	8001720 <kl_vsprintf+0x40>
 800173e:	9201      	str	r2, [sp, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:53

        if((c == 's') || (c == 'S')) {
 8001740:	f003 02df 	and.w	r2, r3, #223	; 0xdf
 8001744:	2a53      	cmp	r2, #83	; 0x53
 8001746:	f88d 1014 	strb.w	r1, [sp, #20]
 800174a:	d110      	bne.n	800176e <kl_vsprintf+0x8e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:54
            char *s = va_arg(args, char*);
 800174c:	1d25      	adds	r5, r4, #4
 800174e:	6824      	ldr	r4, [r4, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:55 (discriminator 1)
            while((*s != 0) && (CharCnt++ < MaxLength)) PPutChar(*s++);
 8001750:	f814 3b01 	ldrb.w	r3, [r4], #1
 8001754:	2b00      	cmp	r3, #0
 8001756:	d06b      	beq.n	8001830 <kl_vsprintf+0x150>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:55 (discriminator 2)
 8001758:	9b03      	ldr	r3, [sp, #12]
 800175a:	1c5a      	adds	r2, r3, #1
 800175c:	9203      	str	r2, [sp, #12]
 800175e:	9a02      	ldr	r2, [sp, #8]
 8001760:	4293      	cmp	r3, r2
 8001762:	d265      	bcs.n	8001830 <kl_vsprintf+0x150>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:55 (discriminator 1)
 8001764:	f814 0c01 	ldrb.w	r0, [r4, #-1]
 8001768:	9b04      	ldr	r3, [sp, #16]
 800176a:	4798      	blx	r3
 800176c:	e7f0      	b.n	8001750 <kl_vsprintf+0x70>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:57
        }
        else if(c == 'c') {
 800176e:	2b63      	cmp	r3, #99	; 0x63
 8001770:	d10b      	bne.n	800178a <kl_vsprintf+0xaa>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:58
            PPutChar(va_arg(args, int));
 8001772:	9b04      	ldr	r3, [sp, #16]
 8001774:	7820      	ldrb	r0, [r4, #0]
 8001776:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:59
            if(++CharCnt >= MaxLength) break;
 8001778:	9b03      	ldr	r3, [sp, #12]
 800177a:	9a02      	ldr	r2, [sp, #8]
 800177c:	3301      	adds	r3, #1
 800177e:	4293      	cmp	r3, r2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:58
        if((c == 's') || (c == 'S')) {
            char *s = va_arg(args, char*);
            while((*s != 0) && (CharCnt++ < MaxLength)) PPutChar(*s++);
        }
        else if(c == 'c') {
            PPutChar(va_arg(args, int));
 8001780:	f104 0504 	add.w	r5, r4, #4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:59
            if(++CharCnt >= MaxLength) break;
 8001784:	9303      	str	r3, [sp, #12]
 8001786:	d353      	bcc.n	8001830 <kl_vsprintf+0x150>
 8001788:	e7c3      	b.n	8001712 <kl_vsprintf+0x32>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:61
        }
        else if(c == 'X') IPutUint(va_arg(args, uint32_t), 16);
 800178a:	2b58      	cmp	r3, #88	; 0x58
 800178c:	d105      	bne.n	800179a <kl_vsprintf+0xba>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:61 (discriminator 1)
 800178e:	1d25      	adds	r5, r4, #4
 8001790:	f10d 0c04 	add.w	ip, sp, #4
 8001794:	6820      	ldr	r0, [r4, #0]
 8001796:	2110      	movs	r1, #16
 8001798:	e006      	b.n	80017a8 <kl_vsprintf+0xc8>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:62
        else if(c == 'u') IPutUint(va_arg(args, uint32_t), 10);
 800179a:	2b75      	cmp	r3, #117	; 0x75
 800179c:	d107      	bne.n	80017ae <kl_vsprintf+0xce>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:62 (discriminator 1)
 800179e:	6820      	ldr	r0, [r4, #0]
 80017a0:	1d25      	adds	r5, r4, #4
 80017a2:	f10d 0c04 	add.w	ip, sp, #4
 80017a6:	210a      	movs	r1, #10
 80017a8:	f7ff ff5a 	bl	8001660 <IPutUint.4105>
 80017ac:	e040      	b.n	8001830 <kl_vsprintf+0x150>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:63
        else if(c == 'd') {
 80017ae:	2b64      	cmp	r3, #100	; 0x64
 80017b0:	d111      	bne.n	80017d6 <kl_vsprintf+0xf6>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:64
            int32_t n = va_arg(args, int32_t);
 80017b2:	1d25      	adds	r5, r4, #4
 80017b4:	6824      	ldr	r4, [r4, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:65
            if(n < 0) {
 80017b6:	2c00      	cmp	r4, #0
 80017b8:	da09      	bge.n	80017ce <kl_vsprintf+0xee>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:66
                PPutChar('-');
 80017ba:	9b04      	ldr	r3, [sp, #16]
 80017bc:	202d      	movs	r0, #45	; 0x2d
 80017be:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:67
                if(++CharCnt >= MaxLength) break;
 80017c0:	9b03      	ldr	r3, [sp, #12]
 80017c2:	9a02      	ldr	r2, [sp, #8]
 80017c4:	3301      	adds	r3, #1
 80017c6:	4293      	cmp	r3, r2
 80017c8:	9303      	str	r3, [sp, #12]
 80017ca:	d2a2      	bcs.n	8001712 <kl_vsprintf+0x32>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:68
                n = -n;
 80017cc:	4264      	negs	r4, r4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:70
            }
            IPutUint(n, 10);
 80017ce:	f10d 0c04 	add.w	ip, sp, #4
 80017d2:	4620      	mov	r0, r4
 80017d4:	e7e7      	b.n	80017a6 <kl_vsprintf+0xc6>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:72
        }
        else if(c == 'A') {
 80017d6:	2b41      	cmp	r3, #65	; 0x41
 80017d8:	d129      	bne.n	800182e <kl_vsprintf+0x14e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:76
            uint8_t *arr = va_arg(args, uint8_t*);
            int32_t n = va_arg(args, int32_t);
            int32_t Delimiter = va_arg(args, int32_t);
            zero_padded = true; // Every byte consists of two characters.
 80017da:	2301      	movs	r3, #1
 80017dc:	f88d 3014 	strb.w	r3, [sp, #20]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:77
            width = 2;          // ...01 02 0A etc.; not 1 2 A
 80017e0:	2302      	movs	r3, #2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:73
                n = -n;
            }
            IPutUint(n, 10);
        }
        else if(c == 'A') {
            uint8_t *arr = va_arg(args, uint8_t*);
 80017e2:	f8d4 9000 	ldr.w	r9, [r4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:74
            int32_t n = va_arg(args, int32_t);
 80017e6:	f8d4 8004 	ldr.w	r8, [r4, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:75
            int32_t Delimiter = va_arg(args, int32_t);
 80017ea:	f104 050c 	add.w	r5, r4, #12
 80017ee:	68a7      	ldr	r7, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:77
            zero_padded = true; // Every byte consists of two characters.
            width = 2;          // ...01 02 0A etc.; not 1 2 A
 80017f0:	9301      	str	r3, [sp, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:78
            for(int32_t i = 0; i < n; i++) {
 80017f2:	2400      	movs	r4, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:78 (discriminator 1)
 80017f4:	4544      	cmp	r4, r8
 80017f6:	da1b      	bge.n	8001830 <kl_vsprintf+0x150>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:79
                if((i > 0) && (Delimiter != 0)) {
 80017f8:	2c00      	cmp	r4, #0
 80017fa:	dc0c      	bgt.n	8001816 <kl_vsprintf+0x136>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:83
                    PPutChar((char)Delimiter); // do not place delimiter before or after array
                    if(++CharCnt >= MaxLength) break;
                }
                IPutUint(arr[i], 16);
 80017fc:	f10d 0c04 	add.w	ip, sp, #4
 8001800:	f819 0004 	ldrb.w	r0, [r9, r4]
 8001804:	2110      	movs	r1, #16
 8001806:	f7ff ff2b 	bl	8001660 <IPutUint.4105>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:84
                if(CharCnt >= MaxLength) break;
 800180a:	9b02      	ldr	r3, [sp, #8]
 800180c:	9a03      	ldr	r2, [sp, #12]
 800180e:	429a      	cmp	r2, r3
 8001810:	d20e      	bcs.n	8001830 <kl_vsprintf+0x150>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:78
            uint8_t *arr = va_arg(args, uint8_t*);
            int32_t n = va_arg(args, int32_t);
            int32_t Delimiter = va_arg(args, int32_t);
            zero_padded = true; // Every byte consists of two characters.
            width = 2;          // ...01 02 0A etc.; not 1 2 A
            for(int32_t i = 0; i < n; i++) {
 8001812:	3401      	adds	r4, #1
 8001814:	e7ee      	b.n	80017f4 <kl_vsprintf+0x114>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:79 (discriminator 1)
                if((i > 0) && (Delimiter != 0)) {
 8001816:	2f00      	cmp	r7, #0
 8001818:	d0f0      	beq.n	80017fc <kl_vsprintf+0x11c>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:80
                    PPutChar((char)Delimiter); // do not place delimiter before or after array
 800181a:	9b04      	ldr	r3, [sp, #16]
 800181c:	b2f8      	uxtb	r0, r7
 800181e:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:81
                    if(++CharCnt >= MaxLength) break;
 8001820:	9b03      	ldr	r3, [sp, #12]
 8001822:	9a02      	ldr	r2, [sp, #8]
 8001824:	3301      	adds	r3, #1
 8001826:	4293      	cmp	r3, r2
 8001828:	9303      	str	r3, [sp, #12]
 800182a:	d3e7      	bcc.n	80017fc <kl_vsprintf+0x11c>
 800182c:	e000      	b.n	8001830 <kl_vsprintf+0x150>
 800182e:	4625      	mov	r5, r4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_sprintf.c:87
                }
                IPutUint(arr[i], 16);
                if(CharCnt >= MaxLength) break;
            }
        }
        if(CharCnt >= MaxLength) break;
 8001830:	9b02      	ldr	r3, [sp, #8]
 8001832:	9a03      	ldr	r2, [sp, #12]
 8001834:	429a      	cmp	r2, r3
 8001836:	f4bf af6c 	bcs.w	8001712 <kl_vsprintf+0x32>
 800183a:	462c      	mov	r4, r5
 800183c:	4632      	mov	r2, r6
 800183e:	e75a      	b.n	80016f6 <kl_vsprintf+0x16>

08001840 <CmdUart_t::IPutChar(char)>:
_ZN9CmdUart_t8IPutCharEc():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:43
    IPrintf(format, args);
    va_end(args);
}

void CmdUart_t::IPutChar(char c) {
    *PWrite++ = c;
 8001840:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
 8001844:	1c5a      	adds	r2, r3, #1
 8001846:	f8c0 25e0 	str.w	r2, [r0, #1504]	; 0x5e0
 800184a:	7019      	strb	r1, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:44
    if(PWrite >= &TXBuf[UART_TXBUF_SIZE]) PWrite = TXBuf;   // Circulate buffer
 800184c:	f8d0 35e0 	ldr.w	r3, [r0, #1504]	; 0x5e0
 8001850:	f200 52dc 	addw	r2, r0, #1500	; 0x5dc
 8001854:	4293      	cmp	r3, r2
 8001856:	bf28      	it	cs
 8001858:	f8c0 05e0 	strcs.w	r0, [r0, #1504]	; 0x5e0
 800185c:	4770      	bx	lr
	...

08001860 <FPutChar(char)>:
FPutChar():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:24
    va_end(args);
    chSysUnlock();
}
}

static inline void FPutChar(char c) { Uart.IPutChar(c); }
 8001860:	4601      	mov	r1, r0
 8001862:	4801      	ldr	r0, [pc, #4]	; (8001868 <FPutChar(char)+0x8>)
 8001864:	f7ff bfec 	b.w	8001840 <CmdUart_t::IPutChar(char)>
 8001868:	200009dc 	.word	0x200009dc
$d():
 800186c:	00000000 	.word	0x00000000

08001870 <CmdUart_t::ISendViaDMA()>:
_ZN9CmdUart_t11ISendViaDMAEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:55
    // Start transmission if Idle
    if(IDmaIsIdle) ISendViaDMA();
}

void CmdUart_t::ISendViaDMA() {
    uint32_t PartSz = (TXBuf + UART_TXBUF_SIZE) - PRead; // Cnt from PRead to end of buf
 8001870:	f8d0 15dc 	ldr.w	r1, [r0, #1500]	; 0x5dc
 8001874:	f200 52dc 	addw	r2, r0, #1500	; 0x5dc
 8001878:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	; 0x5e8
 800187c:	1a52      	subs	r2, r2, r1
 800187e:	429a      	cmp	r2, r3
 8001880:	bf28      	it	cs
 8001882:	461a      	movcs	r2, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:56
    ITransSize = MIN(IFullSlotsCount, PartSz);
 8001884:	f8c0 25ec 	str.w	r2, [r0, #1516]	; 0x5ec
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:57
    if(ITransSize != 0) {
 8001888:	b162      	cbz	r2, 80018a4 <CmdUart_t::ISendViaDMA()+0x34>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:58
        IDmaIsIdle = false;
 800188a:	2300      	movs	r3, #0
 800188c:	f880 35e4 	strb.w	r3, [r0, #1508]	; 0x5e4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:59
        dmaStreamSetMemory0(UART_DMA_TX, PRead);
 8001890:	4b05      	ldr	r3, [pc, #20]	; (80018a8 <CmdUart_t::ISendViaDMA()+0x38>)
 8001892:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001894:	60d9      	str	r1, [r3, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:60
        dmaStreamSetTransactionSize(UART_DMA_TX, ITransSize);
 8001896:	605a      	str	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:61
        dmaStreamSetMode(UART_DMA_TX, UART_DMA_TX_MODE);
 8001898:	2292      	movs	r2, #146	; 0x92
 800189a:	601a      	str	r2, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:62
        dmaStreamEnable(UART_DMA_TX);
 800189c:	681a      	ldr	r2, [r3, #0]
 800189e:	f042 0201 	orr.w	r2, r2, #1
 80018a2:	601a      	str	r2, [r3, #0]
 80018a4:	4770      	bx	lr
 80018a6:	bf00      	nop
 80018a8:	08002300 	.word	0x08002300
$d():
 80018ac:	00000000 	.word	0x00000000

080018b0 <CmdUart_t::IPrintf(char const*, std::__va_list)>:
_ZN9CmdUart_t7IPrintfEPKcSt9__va_list():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:47
void CmdUart_t::IPutChar(char c) {
    *PWrite++ = c;
    if(PWrite >= &TXBuf[UART_TXBUF_SIZE]) PWrite = TXBuf;   // Circulate buffer
}

void CmdUart_t::IPrintf(const char *format, va_list args) {
 80018b0:	b558      	push	{r3, r4, r6, lr}
 80018b2:	460e      	mov	r6, r1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:48
    int32_t MaxLength = UART_TXBUF_SIZE - IFullSlotsCount;
 80018b4:	f8d0 15e8 	ldr.w	r1, [r0, #1512]	; 0x5e8
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:47
void CmdUart_t::IPutChar(char c) {
    *PWrite++ = c;
    if(PWrite >= &TXBuf[UART_TXBUF_SIZE]) PWrite = TXBuf;   // Circulate buffer
}

void CmdUart_t::IPrintf(const char *format, va_list args) {
 80018b8:	4604      	mov	r4, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:49
    int32_t MaxLength = UART_TXBUF_SIZE - IFullSlotsCount;
    IFullSlotsCount += kl_vsprintf(FPutChar, MaxLength, format, args);
 80018ba:	f5c1 61bb 	rsb	r1, r1, #1496	; 0x5d8
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:47
void CmdUart_t::IPutChar(char c) {
    *PWrite++ = c;
    if(PWrite >= &TXBuf[UART_TXBUF_SIZE]) PWrite = TXBuf;   // Circulate buffer
}

void CmdUart_t::IPrintf(const char *format, va_list args) {
 80018be:	4613      	mov	r3, r2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:49
    int32_t MaxLength = UART_TXBUF_SIZE - IFullSlotsCount;
    IFullSlotsCount += kl_vsprintf(FPutChar, MaxLength, format, args);
 80018c0:	4809      	ldr	r0, [pc, #36]	; (80018e8 <CmdUart_t::IPrintf(char const*, std::__va_list)+0x38>)
 80018c2:	3104      	adds	r1, #4
 80018c4:	4632      	mov	r2, r6
 80018c6:	f7ff ff0b 	bl	80016e0 <kl_vsprintf>
 80018ca:	f8d4 35e8 	ldr.w	r3, [r4, #1512]	; 0x5e8
 80018ce:	4418      	add	r0, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:51
    // Start transmission if Idle
    if(IDmaIsIdle) ISendViaDMA();
 80018d0:	f894 35e4 	ldrb.w	r3, [r4, #1508]	; 0x5e4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:49
    if(PWrite >= &TXBuf[UART_TXBUF_SIZE]) PWrite = TXBuf;   // Circulate buffer
}

void CmdUart_t::IPrintf(const char *format, va_list args) {
    int32_t MaxLength = UART_TXBUF_SIZE - IFullSlotsCount;
    IFullSlotsCount += kl_vsprintf(FPutChar, MaxLength, format, args);
 80018d4:	f8c4 05e8 	str.w	r0, [r4, #1512]	; 0x5e8
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:51
    // Start transmission if Idle
    if(IDmaIsIdle) ISendViaDMA();
 80018d8:	b123      	cbz	r3, 80018e4 <CmdUart_t::IPrintf(char const*, std::__va_list)+0x34>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:51 (discriminator 1)
 80018da:	4620      	mov	r0, r4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:52 (discriminator 1)
}
 80018dc:	e8bd 4058 	ldmia.w	sp!, {r3, r4, r6, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:51 (discriminator 1)

void CmdUart_t::IPrintf(const char *format, va_list args) {
    int32_t MaxLength = UART_TXBUF_SIZE - IFullSlotsCount;
    IFullSlotsCount += kl_vsprintf(FPutChar, MaxLength, format, args);
    // Start transmission if Idle
    if(IDmaIsIdle) ISendViaDMA();
 80018e0:	f7ff bfc6 	b.w	8001870 <CmdUart_t::ISendViaDMA()>
 80018e4:	bd58      	pop	{r3, r4, r6, pc}
 80018e6:	bf00      	nop
 80018e8:	08001861 	.word	0x08001861
$d():
 80018ec:	00000000 	.word	0x00000000

080018f0 <CmdUart_t::Printf(char const*, ...)>:
_ZN9CmdUart_t6PrintfEPKcz():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:26
}
}

static inline void FPutChar(char c) { Uart.IPutChar(c); }

void CmdUart_t::Printf(const char *format, ...) {
 80018f0:	b40e      	push	{r1, r2, r3}
 80018f2:	b503      	push	{r0, r1, lr}
 80018f4:	aa03      	add	r2, sp, #12
 80018f6:	f852 1b04 	ldr.w	r1, [r2], #4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:27
    chSysLock();
 80018fa:	2320      	movs	r3, #32
 80018fc:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:29
    va_list args;
    va_start(args, format);
 8001900:	9201      	str	r2, [sp, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:30
    IPrintf(format, args);
 8001902:	f7ff ffd5 	bl	80018b0 <CmdUart_t::IPrintf(char const*, std::__va_list)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:32
    va_end(args);
    chSysUnlock();
 8001906:	2300      	movs	r3, #0
 8001908:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:33
}
 800190c:	b002      	add	sp, #8
 800190e:	f85d eb04 	ldr.w	lr, [sp], #4
 8001912:	b003      	add	sp, #12
 8001914:	4770      	bx	lr
	...

08001920 <CmdUart_t::Init(unsigned long)>:
_ZN9CmdUart_t4InitEm():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:88
// Wrapper for TX IRQ
extern "C" {
void CmdUartTxIrq(void *p, uint32_t flags) { Uart.IRQDmaTxHandler(); }
}

void CmdUart_t::Init(uint32_t ABaudrate) {
 8001920:	b538      	push	{r3, r4, r5, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:91
    PWrite = TXBuf;
    PRead = TXBuf;
    IDmaIsIdle = true;
 8001922:	2301      	movs	r3, #1
 8001924:	f880 35e4 	strb.w	r3, [r0, #1508]	; 0x5e4
PinClockEnable():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:183
static inline void PinToggle (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->ODR  ^= (uint16_t)(1<<APinNumber); }
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
 8001928:	4c2c      	ldr	r4, [pc, #176]	; (80019dc <CmdUart_t::Init(unsigned long)+0xbc>)
_ZN9CmdUart_t4InitEm():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:92
    IFullSlotsCount = 0;
 800192a:	2300      	movs	r3, #0
 800192c:	f8c0 35e8 	str.w	r3, [r0, #1512]	; 0x5e8
PinClockEnable():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:183
 8001930:	69e2      	ldr	r2, [r4, #28]
_ZN9CmdUart_t4InitEm():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:89
extern "C" {
void CmdUartTxIrq(void *p, uint32_t flags) { Uart.IRQDmaTxHandler(); }
}

void CmdUart_t::Init(uint32_t ABaudrate) {
    PWrite = TXBuf;
 8001932:	f8c0 05e0 	str.w	r0, [r0, #1504]	; 0x5e0
PinClockEnable():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:183
 8001936:	f042 0201 	orr.w	r2, r2, #1
_ZN9CmdUart_t4InitEm():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:90
    PRead = TXBuf;
 800193a:	f8c0 05dc 	str.w	r0, [r0, #1500]	; 0x5dc
PinClockEnable():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:183
 800193e:	61e2      	str	r2, [r4, #28]
PinSetupAlterFunc():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:245
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8001940:	4a27      	ldr	r2, [pc, #156]	; (80019e0 <CmdUart_t::Init(unsigned long)+0xc0>)
_ZN9CmdUart_t4InitEm():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:102
    UART->CR1 = USART_CR1_UE;     // Enable USART
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8001942:	4d28      	ldr	r5, [pc, #160]	; (80019e4 <CmdUart_t::Init(unsigned long)+0xc4>)
PinSetupAlterFunc():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:245
 8001944:	6810      	ldr	r0, [r2, #0]
 8001946:	f420 2040 	bic.w	r0, r0, #786432	; 0xc0000
 800194a:	6010      	str	r0, [r2, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:246
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 800194c:	6810      	ldr	r0, [r2, #0]
 800194e:	f440 2000 	orr.w	r0, r0, #524288	; 0x80000
 8001952:	6010      	str	r0, [r2, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:248
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001954:	8890      	ldrh	r0, [r2, #4]
 8001956:	f420 7000 	bic.w	r0, r0, #512	; 0x200
 800195a:	0400      	lsls	r0, r0, #16
 800195c:	0c00      	lsrs	r0, r0, #16
 800195e:	8090      	strh	r0, [r2, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:249
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001960:	8890      	ldrh	r0, [r2, #4]
 8001962:	b280      	uxth	r0, r0
 8001964:	8090      	strh	r0, [r2, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:251
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8001966:	68d0      	ldr	r0, [r2, #12]
 8001968:	f420 2040 	bic.w	r0, r0, #786432	; 0xc0000
 800196c:	60d0      	str	r0, [r2, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:252
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 800196e:	68d0      	ldr	r0, [r2, #12]
 8001970:	60d0      	str	r0, [r2, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:254
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8001972:	6890      	ldr	r0, [r2, #8]
 8001974:	f420 2040 	bic.w	r0, r0, #786432	; 0xc0000
 8001978:	6090      	str	r0, [r2, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:255
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 800197a:	6890      	ldr	r0, [r2, #8]
 800197c:	f440 2000 	orr.w	r0, r0, #524288	; 0x80000
 8001980:	6090      	str	r0, [r2, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:259
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001982:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8001984:	f020 00f0 	bic.w	r0, r0, #240	; 0xf0
 8001988:	6250      	str	r0, [r2, #36]	; 0x24
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:260
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 800198a:	6a50      	ldr	r0, [r2, #36]	; 0x24
 800198c:	f040 0070 	orr.w	r0, r0, #112	; 0x70
 8001990:	6250      	str	r0, [r2, #36]	; 0x24
_ZN9CmdUart_t4InitEm():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:96
    IDmaIsIdle = true;
    IFullSlotsCount = 0;
    PinSetupAlterFunc(UART_GPIO, UART_TX_PIN, omPushPull, pudNone, UART_AF);

    // ==== USART configuration ====
    UART_RCC_ENABLE();
 8001992:	6a22      	ldr	r2, [r4, #32]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:102
    UART->CR1 = USART_CR1_UE;     // Enable USART
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 8001994:	4628      	mov	r0, r5
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:96
    IDmaIsIdle = true;
    IFullSlotsCount = 0;
    PinSetupAlterFunc(UART_GPIO, UART_TX_PIN, omPushPull, pudNone, UART_AF);

    // ==== USART configuration ====
    UART_RCC_ENABLE();
 8001996:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800199a:	6222      	str	r2, [r4, #32]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:97
    UART->CR1 = USART_CR1_UE;     // Enable USART
 800199c:	f5a4 3480 	sub.w	r4, r4, #65536	; 0x10000
 80019a0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80019a4:	81a2      	strh	r2, [r4, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:98
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
 80019a6:	4a10      	ldr	r2, [pc, #64]	; (80019e8 <CmdUart_t::Init(unsigned long)+0xc8>)
 80019a8:	6892      	ldr	r2, [r2, #8]
 80019aa:	fbb2 f1f1 	udiv	r1, r2, r1
 80019ae:	b28a      	uxth	r2, r1
 80019b0:	8122      	strh	r2, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:102
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 80019b2:	2107      	movs	r1, #7
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:100
    // ==== USART configuration ====
    UART_RCC_ENABLE();
    UART->CR1 = USART_CR1_UE;     // Enable USART
    if(UART == USART1) UART->BRR = Clk.APB2FreqHz / ABaudrate;
    else               UART->BRR = Clk.APB1FreqHz / ABaudrate;
    UART->CR2 = 0;
 80019b4:	8223      	strh	r3, [r4, #16]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:102
    // ==== DMA ====
    dmaStreamAllocate     (UART_DMA_TX, IRQ_PRIO_HIGH, CmdUartTxIrq, NULL);
 80019b6:	4a0d      	ldr	r2, [pc, #52]	; (80019ec <CmdUart_t::Init(unsigned long)+0xcc>)
 80019b8:	f7ff f93a 	bl	8000c30 <dmaStreamAllocate>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:103
    dmaStreamSetPeripheral(UART_DMA_TX, &UART->DR);
 80019bc:	682b      	ldr	r3, [r5, #0]
 80019be:	4a0c      	ldr	r2, [pc, #48]	; (80019f0 <CmdUart_t::Init(unsigned long)+0xd0>)
 80019c0:	609a      	str	r2, [r3, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:104
    dmaStreamSetMode      (UART_DMA_TX, UART_DMA_TX_MODE);
 80019c2:	2292      	movs	r2, #146	; 0x92
 80019c4:	601a      	str	r2, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:119
    dmaStreamSetMemory0   (UART_DMA_RX, IRxBuf);
    dmaStreamSetTransactionSize(UART_DMA_RX, UART_RXBUF_SZ);
    dmaStreamSetMode      (UART_DMA_RX, UART_DMA_RX_MODE);
    dmaStreamEnable       (UART_DMA_RX);
#else
    UART->CR1 = USART_CR1_TE;     // Transmitter enabled
 80019c6:	2308      	movs	r3, #8
 80019c8:	81a3      	strh	r3, [r4, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:120
    UART->CR3 = USART_CR3_DMAT;   // Enable DMA at transmitter
 80019ca:	2380      	movs	r3, #128	; 0x80
 80019cc:	82a3      	strh	r3, [r4, #20]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:122
#endif
    UART->CR1 |= USART_CR1_UE;    // Enable USART
 80019ce:	89a3      	ldrh	r3, [r4, #12]
 80019d0:	b29b      	uxth	r3, r3
 80019d2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80019d6:	81a3      	strh	r3, [r4, #12]
 80019d8:	bd38      	pop	{r3, r4, r5, pc}
 80019da:	bf00      	nop
 80019dc:	40023800 	.word	0x40023800
 80019e0:	40020000 	.word	0x40020000
 80019e4:	08002324 	.word	0x08002324
 80019e8:	20000980 	.word	0x20000980
 80019ec:	08001a71 	.word	0x08001a71
 80019f0:	40013804 	.word	0x40013804
	...

08001a00 <CmdUart_t::IRQDmaTxHandler()>:
_ZN9CmdUart_t15IRQDmaTxHandlerEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:127
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
 8001a00:	4a19      	ldr	r2, [pc, #100]	; (8001a68 <CmdUart_t::IRQDmaTxHandler()+0x68>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:126
#endif
    UART->CR1 |= USART_CR1_UE;    // Enable USART
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
 8001a02:	b510      	push	{r4, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:127
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
 8001a04:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8001a06:	240f      	movs	r4, #15
 8001a08:	6819      	ldr	r1, [r3, #0]
 8001a0a:	f021 010f 	bic.w	r1, r1, #15
 8001a0e:	6019      	str	r1, [r3, #0]
 8001a10:	6a91      	ldr	r1, [r2, #40]	; 0x28
 8001a12:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 8001a16:	fa04 f202 	lsl.w	r2, r4, r2
 8001a1a:	600a      	str	r2, [r1, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:129
    IFullSlotsCount -= ITransSize;
    PRead += ITransSize;
 8001a1c:	f8d0 45dc 	ldr.w	r4, [r0, #1500]	; 0x5dc
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:128
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
    IFullSlotsCount -= ITransSize;
 8001a20:	f8d0 15ec 	ldr.w	r1, [r0, #1516]	; 0x5ec
 8001a24:	f8d0 25e8 	ldr.w	r2, [r0, #1512]	; 0x5e8
 8001a28:	1a52      	subs	r2, r2, r1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:129
    PRead += ITransSize;
 8001a2a:	4421      	add	r1, r4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:130
    if(PRead >= (TXBuf + UART_TXBUF_SIZE)) PRead = TXBuf; // Circulate pointer
 8001a2c:	f200 54dc 	addw	r4, r0, #1500	; 0x5dc
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:129

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
    IFullSlotsCount -= ITransSize;
    PRead += ITransSize;
 8001a30:	42a1      	cmp	r1, r4
 8001a32:	bf28      	it	cs
 8001a34:	4601      	movcs	r1, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:128
}

// ==== TX DMA IRQ ====
void CmdUart_t::IRQDmaTxHandler() {
    dmaStreamDisable(UART_DMA_TX);    // Registers may be changed only when stream is disabled
    IFullSlotsCount -= ITransSize;
 8001a36:	f8c0 25e8 	str.w	r2, [r0, #1512]	; 0x5e8
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:129
    PRead += ITransSize;
 8001a3a:	f8c0 15dc 	str.w	r1, [r0, #1500]	; 0x5dc
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:132
    if(PRead >= (TXBuf + UART_TXBUF_SIZE)) PRead = TXBuf; // Circulate pointer

    if(IFullSlotsCount == 0) IDmaIsIdle = true; // Nothing left to send
 8001a3e:	b91a      	cbnz	r2, 8001a48 <CmdUart_t::IRQDmaTxHandler()+0x48>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:132 (discriminator 1)
 8001a40:	2301      	movs	r3, #1
 8001a42:	f880 35e4 	strb.w	r3, [r0, #1508]	; 0x5e4
 8001a46:	bd10      	pop	{r4, pc}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:134
    else {  // There is something to transmit more
        dmaStreamSetMemory0(UART_DMA_TX, PRead);
 8001a48:	60d9      	str	r1, [r3, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:135
        uint32_t PartSz = (TXBuf + UART_TXBUF_SIZE) - PRead;
 8001a4a:	1a61      	subs	r1, r4, r1
 8001a4c:	4291      	cmp	r1, r2
 8001a4e:	bf38      	it	cc
 8001a50:	460a      	movcc	r2, r1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:136
        ITransSize = (IFullSlotsCount > PartSz)? PartSz : IFullSlotsCount;
 8001a52:	f8c0 25ec 	str.w	r2, [r0, #1516]	; 0x5ec
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:137
        dmaStreamSetTransactionSize(UART_DMA_TX, ITransSize);
 8001a56:	605a      	str	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:138
        dmaStreamSetMode(UART_DMA_TX, UART_DMA_TX_MODE);
 8001a58:	2292      	movs	r2, #146	; 0x92
 8001a5a:	601a      	str	r2, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:139
        dmaStreamEnable(UART_DMA_TX);    // Restart DMA
 8001a5c:	681a      	ldr	r2, [r3, #0]
 8001a5e:	f042 0201 	orr.w	r2, r2, #1
 8001a62:	601a      	str	r2, [r3, #0]
 8001a64:	bd10      	pop	{r4, pc}
 8001a66:	bf00      	nop
 8001a68:	08002300 	.word	0x08002300
$d():
 8001a6c:	00000000 	.word	0x00000000

08001a70 <CmdUartTxIrq>:
CmdUartTxIrq():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/uart.cpp:85
#endif

// ==== Init & DMA ====
// Wrapper for TX IRQ
extern "C" {
void CmdUartTxIrq(void *p, uint32_t flags) { Uart.IRQDmaTxHandler(); }
 8001a70:	4801      	ldr	r0, [pc, #4]	; (8001a78 <CmdUartTxIrq+0x8>)
 8001a72:	f7ff bfc5 	b.w	8001a00 <CmdUart_t::IRQDmaTxHandler()>
 8001a76:	bf00      	nop
 8001a78:	200009dc 	.word	0x200009dc
$d():
 8001a7c:	00000000 	.word	0x00000000

08001a80 <PinSetupOut(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinSpeed_t) [clone .constprop.13]>:
PinSetupOut():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:188
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
    else if(PGpioPort == GPIOC) RCC->AHBENR |= RCC_AHBENR_GPIOCEN;
    else if(PGpioPort == GPIOD) RCC->AHBENR |= RCC_AHBENR_GPIODEN;
}
static inline void PinSetupOut(
 8001a80:	b570      	push	{r4, r5, r6, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:197
        const PinPullUpDown_t APullUpDown = pudNone,
        const PinSpeed_t ASpeed = ps40MHz
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
 8001a82:	0045      	lsls	r5, r0, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:199
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8001a84:	b2ed      	uxtb	r5, r5
 8001a86:	2103      	movs	r1, #3
 8001a88:	40a9      	lsls	r1, r5
PinClockEnable():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:184
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8001a8a:	4b13      	ldr	r3, [pc, #76]	; (8001ad8 <PinSetupOut(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinSpeed_t) [clone .constprop.13]+0x58>)
 8001a8c:	69da      	ldr	r2, [r3, #28]
 8001a8e:	f042 0202 	orr.w	r2, r2, #2
 8001a92:	61da      	str	r2, [r3, #28]
PinSetupOut():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:199
        ) {
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8001a94:	f5a3 5350 	sub.w	r3, r3, #13312	; 0x3400
 8001a98:	681c      	ldr	r4, [r3, #0]
 8001a9a:	43ca      	mvns	r2, r1
 8001a9c:	4014      	ands	r4, r2
 8001a9e:	601c      	str	r4, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:200
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 8001aa0:	2401      	movs	r4, #1
 8001aa2:	fa04 f505 	lsl.w	r5, r4, r5
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:202
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001aa6:	fa04 f000 	lsl.w	r0, r4, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:200
    // Clock
    PinClockEnable(PGpioPort);
    uint8_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
    PGpioPort->MODER |=   0b01 << Offset;   // Set new bits
 8001aaa:	681e      	ldr	r6, [r3, #0]
 8001aac:	4335      	orrs	r5, r6
 8001aae:	601d      	str	r5, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:202
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001ab0:	889d      	ldrh	r5, [r3, #4]
 8001ab2:	b2ad      	uxth	r5, r5
 8001ab4:	ea25 0000 	bic.w	r0, r5, r0
 8001ab8:	8098      	strh	r0, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:203
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001aba:	8898      	ldrh	r0, [r3, #4]
 8001abc:	b280      	uxth	r0, r0
 8001abe:	8098      	strh	r0, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:205
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8001ac0:	68d8      	ldr	r0, [r3, #12]
 8001ac2:	4010      	ands	r0, r2
 8001ac4:	60d8      	str	r0, [r3, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:206
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8001ac6:	68d8      	ldr	r0, [r3, #12]
 8001ac8:	60d8      	str	r0, [r3, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:208
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8001aca:	6898      	ldr	r0, [r3, #8]
 8001acc:	4002      	ands	r2, r0
 8001ace:	609a      	str	r2, [r3, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:209
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001ad0:	689a      	ldr	r2, [r3, #8]
 8001ad2:	4311      	orrs	r1, r2
 8001ad4:	6099      	str	r1, [r3, #8]
 8001ad6:	bd70      	pop	{r4, r5, r6, pc}
 8001ad8:	40023800 	.word	0x40023800
$d():
 8001adc:	00000000 	.word	0x00000000

08001ae0 <Lcd_t::WriteCmd(unsigned char)>:
PinClear():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:177
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8001ae0:	4b11      	ldr	r3, [pc, #68]	; (8001b28 <Lcd_t::WriteCmd(unsigned char)+0x48>)
 8001ae2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001ae6:	f44f 5000 	mov.w	r0, #8192	; 0x2000
_ZN5Lcd_t7SCLK_LoEv():
 8001aea:	835a      	strh	r2, [r3, #26]
_ZN5Lcd_t6XCS_LoEv():
 8001aec:	8358      	strh	r0, [r3, #26]
PinClear():
 8001aee:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001af2:	8358      	strh	r0, [r3, #26]
PinSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:176
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8001af4:	831a      	strh	r2, [r3, #24]
PinClear():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:177
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8001af6:	835a      	strh	r2, [r3, #26]
 8001af8:	2208      	movs	r2, #8
_ZN5Lcd_t8WriteCmdEh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:96
    SDA_Lo();
    SCLK_Hi();
    SCLK_Lo();
    // Send byte
    for(uint8_t i=0; i<8; i++) {
        if(AByte & 0x80) SDA_Hi();
 8001afa:	f011 0f80 	tst.w	r1, #128	; 0x80
 8001afe:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001b02:	f102 32ff 	add.w	r2, r2, #4294967295
PinSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:176
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8001b06:	bf14      	ite	ne
 8001b08:	8318      	strhne	r0, [r3, #24]
PinClear():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:177
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8001b0a:	8358      	strheq	r0, [r3, #26]
_ZN5Lcd_t8WriteCmdEh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:100
        else SDA_Lo();
        SCLK_Hi();
        SCLK_Lo();
        AByte <<= 1;
 8001b0c:	0049      	lsls	r1, r1, #1
PinSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:176
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8001b0e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
_ZN5Lcd_t8WriteCmdEh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:95
    // Send "Cmd" bit
    SDA_Lo();
    SCLK_Hi();
    SCLK_Lo();
    // Send byte
    for(uint8_t i=0; i<8; i++) {
 8001b12:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
_ZN5Lcd_t7SCLK_HiEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:176
 8001b16:	8318      	strh	r0, [r3, #24]
_ZN5Lcd_t8WriteCmdEh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:100
        if(AByte & 0x80) SDA_Hi();
        else SDA_Lo();
        SCLK_Hi();
        SCLK_Lo();
        AByte <<= 1;
 8001b18:	b2c9      	uxtb	r1, r1
PinClear():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:177
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8001b1a:	8358      	strh	r0, [r3, #26]
_ZN5Lcd_t8WriteCmdEh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:95
    // Send "Cmd" bit
    SDA_Lo();
    SCLK_Hi();
    SCLK_Lo();
    // Send byte
    for(uint8_t i=0; i<8; i++) {
 8001b1c:	d1ed      	bne.n	8001afa <Lcd_t::WriteCmd(unsigned char)+0x1a>
PinSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:176
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8001b1e:	4b02      	ldr	r3, [pc, #8]	; (8001b28 <Lcd_t::WriteCmd(unsigned char)+0x48>)
 8001b20:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001b24:	831a      	strh	r2, [r3, #24]
 8001b26:	4770      	bx	lr
 8001b28:	40020400 	.word	0x40020400
$d():
 8001b2c:	00000000 	.word	0x00000000

08001b30 <Lcd_t::DrawChar(unsigned char, Invert_t)>:
_ZN5Lcd_t8DrawCharEh8Invert_t():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:124
    XCS_Hi();
}

// ================================= Printf ====================================
// Prints char at current buf indx
void Lcd_t::DrawChar(uint8_t AChar, Invert_t AInvert) {
 8001b30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001b32:	4c10      	ldr	r4, [pc, #64]	; (8001b74 <Lcd_t::DrawChar(unsigned char, Invert_t)+0x44>)
 8001b34:	2506      	movs	r5, #6
 8001b36:	f8b0 36cc 	ldrh.w	r3, [r0, #1740]	; 0x6cc
 8001b3a:	fb05 4101 	mla	r1, r5, r1, r4
 8001b3e:	2400      	movs	r4, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:128
    uint8_t b;
    uint16_t w;
    for(uint8_t i=0; i<6; i++) {
        b = Font_6x8_Data[AChar][i];
 8001b40:	5d0d      	ldrb	r5, [r1, r4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:129
        if(AInvert == Inverted) b = ~b;
 8001b42:	2a01      	cmp	r2, #1
 8001b44:	bf04      	itt	eq
 8001b46:	43ed      	mvneq	r5, r5
 8001b48:	b2ed      	uxtbeq	r5, r5
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:132
        w = b;
        w = (w << 1) | 0x0001;
        IBuf[CurrentPosition++] = w;
 8001b4a:	1c5e      	adds	r6, r3, #1
 8001b4c:	b2b6      	uxth	r6, r6
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:131
    uint16_t w;
    for(uint8_t i=0; i<6; i++) {
        b = Font_6x8_Data[AChar][i];
        if(AInvert == Inverted) b = ~b;
        w = b;
        w = (w << 1) | 0x0001;
 8001b4e:	006f      	lsls	r7, r5, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:132
        IBuf[CurrentPosition++] = w;
 8001b50:	eb00 0343 	add.w	r3, r0, r3, lsl #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:133
        if(CurrentPosition >= LCD_VIDEOBUF_SIZE) CurrentPosition = 0;
 8001b54:	f5b6 7f58 	cmp.w	r6, #864	; 0x360
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:131
    uint16_t w;
    for(uint8_t i=0; i<6; i++) {
        b = Font_6x8_Data[AChar][i];
        if(AInvert == Inverted) b = ~b;
        w = b;
        w = (w << 1) | 0x0001;
 8001b58:	f047 0701 	orr.w	r7, r7, #1
 8001b5c:	f104 0401 	add.w	r4, r4, #1
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:132
        IBuf[CurrentPosition++] = w;
 8001b60:	819f      	strh	r7, [r3, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:133
        if(CurrentPosition >= LCD_VIDEOBUF_SIZE) CurrentPosition = 0;
 8001b62:	bf34      	ite	cc
 8001b64:	4633      	movcc	r3, r6
 8001b66:	2300      	movcs	r3, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:127
// ================================= Printf ====================================
// Prints char at current buf indx
void Lcd_t::DrawChar(uint8_t AChar, Invert_t AInvert) {
    uint8_t b;
    uint16_t w;
    for(uint8_t i=0; i<6; i++) {
 8001b68:	2c06      	cmp	r4, #6
 8001b6a:	d1e9      	bne.n	8001b40 <Lcd_t::DrawChar(unsigned char, Invert_t)+0x10>
 8001b6c:	f8a0 36cc 	strh.w	r3, [r0, #1740]	; 0x6cc
 8001b70:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001b72:	bf00      	nop
 8001b74:	080023f0 	.word	0x080023f0
	...

08001b80 <FLcdPutChar(char)>:
FLcdPutChar():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:137
        IBuf[CurrentPosition++] = w;
        if(CurrentPosition >= LCD_VIDEOBUF_SIZE) CurrentPosition = 0;
    }
}

static inline void FLcdPutChar(char c) { Lcd.DrawChar(c, NotInverted); }
 8001b80:	4601      	mov	r1, r0
 8001b82:	2200      	movs	r2, #0
 8001b84:	4801      	ldr	r0, [pc, #4]	; (8001b8c <FLcdPutChar(char)+0xc>)
 8001b86:	f7ff bfd3 	b.w	8001b30 <Lcd_t::DrawChar(unsigned char, Invert_t)>
 8001b8a:	bf00      	nop
 8001b8c:	20000fcc 	.word	0x20000fcc

08001b90 <Lcd_t::Printf(unsigned char, unsigned char, char const*, ...)>:
_ZN5Lcd_t6PrintfEhhPKcz():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:139

void Lcd_t::Printf(const uint8_t x, const uint8_t y, const char *S, ...) {
 8001b90:	b408      	push	{r3}
 8001b92:	b517      	push	{r0, r1, r2, r4, lr}
_ZN5Lcd_t10GotoCharXYEhh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.h:83
    // High-level
    void GotoCharXY(uint8_t x, uint8_t y) { CurrentPosition =  x*6 + y*96; }
 8001b94:	eb02 0242 	add.w	r2, r2, r2, lsl #1
_ZN5Lcd_t6PrintfEhhPKcz():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:139
 8001b98:	ab05      	add	r3, sp, #20
 8001b9a:	f853 4b04 	ldr.w	r4, [r3], #4
_ZN5Lcd_t10GotoCharXYEhh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.h:83
 8001b9e:	0152      	lsls	r2, r2, #5
 8001ba0:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8001ba4:	eb02 0141 	add.w	r1, r2, r1, lsl #1
 8001ba8:	f8a0 16cc 	strh.w	r1, [r0, #1740]	; 0x6cc
_ZN5Lcd_t6PrintfEhhPKcz():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:143
    GotoCharXY(x, y);
    va_list args;
    va_start(args, S);
    kl_vsprintf(FLcdPutChar, 16, S, args);
 8001bac:	4622      	mov	r2, r4
 8001bae:	2110      	movs	r1, #16
 8001bb0:	4804      	ldr	r0, [pc, #16]	; (8001bc4 <Lcd_t::Printf(unsigned char, unsigned char, char const*, ...)+0x34>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:142
static inline void FLcdPutChar(char c) { Lcd.DrawChar(c, NotInverted); }

void Lcd_t::Printf(const uint8_t x, const uint8_t y, const char *S, ...) {
    GotoCharXY(x, y);
    va_list args;
    va_start(args, S);
 8001bb2:	9301      	str	r3, [sp, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:143
    kl_vsprintf(FLcdPutChar, 16, S, args);
 8001bb4:	f7ff fd94 	bl	80016e0 <kl_vsprintf>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:145
    va_end(args);
}
 8001bb8:	b003      	add	sp, #12
 8001bba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8001bbe:	b001      	add	sp, #4
 8001bc0:	4770      	bx	lr
 8001bc2:	bf00      	nop
 8001bc4:	08001b81 	.word	0x08001b81
	...

08001bd0 <Lcd_t::Cls()>:
_ZN5Lcd_t3ClsEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:177
        for(uint8_t j=0; j<RepeatCount; j++) DrawChar(FCharCode, NotInverted);
    }
    va_end(Arg);
}

void Lcd_t::Cls() {
 8001bd0:	2300      	movs	r3, #0
 8001bd2:	18c2      	adds	r2, r0, r3
 8001bd4:	3302      	adds	r3, #2
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:178 (discriminator 2)
    for (uint32_t i=0; i < LCD_VIDEOBUF_SIZE; i++) IBuf[i] = 0x0001;
 8001bd6:	2101      	movs	r1, #1
 8001bd8:	f5b3 6fd8 	cmp.w	r3, #1728	; 0x6c0
 8001bdc:	8191      	strh	r1, [r2, #12]
 8001bde:	d1f8      	bne.n	8001bd2 <Lcd_t::Cls()+0x2>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:179
}
 8001be0:	4770      	bx	lr
	...

08001bf0 <Lcd_t::Init()>:
_ZN5Lcd_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:18
                            STM32_DMA_CR_DIR_M2P |    /* Direction is memory to peripheral */ \
                            STM32_DMA_CR_CIRC

Lcd_t Lcd;

void Lcd_t::Init(void) {
 8001bf0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:19
    BckLt.Init(LCD_BCKLT_GPIO, LCD_BCKLT_PIN, LCD_BCKLT_TMR, LCD_BCKLT_CHNL, LCD_TOP_BRIGHTNESS);
 8001bf4:	4c70      	ldr	r4, [pc, #448]	; (8001db8 <Lcd_t::Init()+0x1c8>)
 8001bf6:	2600      	movs	r6, #0
 8001bf8:	2202      	movs	r2, #2
 8001bfa:	2364      	movs	r3, #100	; 0x64
 8001bfc:	4621      	mov	r1, r4
 8001bfe:	e88d 004c 	stmia.w	sp, {r2, r3, r6}
 8001c02:	220e      	movs	r2, #14
 8001c04:	4b6d      	ldr	r3, [pc, #436]	; (8001dbc <Lcd_t::Init()+0x1cc>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:18
                            STM32_DMA_CR_DIR_M2P |    /* Direction is memory to peripheral */ \
                            STM32_DMA_CR_CIRC

Lcd_t Lcd;

void Lcd_t::Init(void) {
 8001c06:	4605      	mov	r5, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:19
    BckLt.Init(LCD_BCKLT_GPIO, LCD_BCKLT_PIN, LCD_BCKLT_TMR, LCD_BCKLT_CHNL, LCD_TOP_BRIGHTNESS);
 8001c08:	f7ff fc52 	bl	80014b0 <PwmPin_t::Init(GPIO_TypeDef*, unsigned short, TIM_TypeDef*, unsigned char, unsigned short, bool)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:22
    // ==== GPIOs ====
    // Configure LCD_XRES, LCD_XCS, LCD_SCLK & LCD_SDA as Push-Pull output
    PinSetupOut(LCD_BCKLT_GPIO, LCD_XRES, omPushPull);
 8001c0c:	200b      	movs	r0, #11
 8001c0e:	f7ff ff37 	bl	8001a80 <PinSetupOut(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinSpeed_t) [clone .constprop.13]>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:23
    PinSetupOut(LCD_BCKLT_GPIO, LCD_XCS,  omPushPull);
 8001c12:	200d      	movs	r0, #13
 8001c14:	f7ff ff34 	bl	8001a80 <PinSetupOut(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinSpeed_t) [clone .constprop.13]>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:24
    PinSetupOut(LCD_BCKLT_GPIO, LCD_SCLK, omPushPull);
 8001c18:	200c      	movs	r0, #12
 8001c1a:	f7ff ff31 	bl	8001a80 <PinSetupOut(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinSpeed_t) [clone .constprop.13]>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:25
    PinSetupOut(LCD_BCKLT_GPIO, LCD_SDA,  omPushPull);
 8001c1e:	200a      	movs	r0, #10
 8001c20:	f7ff ff2e 	bl	8001a80 <PinSetupOut(GPIO_TypeDef*, unsigned short, PinOutMode_t, PinPullUpDown_t, PinSpeed_t) [clone .constprop.13]>
PinClear():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:177
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8001c24:	f44f 6800 	mov.w	r8, #2048	; 0x800
 8001c28:	f44f 5380 	mov.w	r3, #4096	; 0x1000
PinSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:176
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8001c2c:	f44f 5700 	mov.w	r7, #8192	; 0x2000
_ZN5Lcd_t7SCLK_LoEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:177
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8001c30:	8363      	strh	r3, [r4, #26]
_ZN5Lcd_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:31
    // ========================= Init LCD ======================================
    SCLK_Lo();
    XCS_Hi();
    // Reset display
    XRES_Lo();
    chThdSleepMilliseconds(7);
 8001c32:	2007      	movs	r0, #7
_ZN5Lcd_t6XCS_HiEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:176
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8001c34:	8327      	strh	r7, [r4, #24]
PinClear():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:177
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8001c36:	f8a4 801a 	strh.w	r8, [r4, #26]
_ZN5Lcd_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:31
 8001c3a:	f7fe fd19 	bl	8000670 <chThdSleep>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:33
    XRES_Hi();
    WriteCmd(0xAF);    // display ON
 8001c3e:	21af      	movs	r1, #175	; 0xaf
PinSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:176
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8001c40:	f8a4 8018 	strh.w	r8, [r4, #24]
_ZN5Lcd_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:33
 8001c44:	4628      	mov	r0, r5
 8001c46:	f7ff ff4b 	bl	8001ae0 <Lcd_t::WriteCmd(unsigned char)>
PinClear():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:177
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8001c4a:	f8a4 801a 	strh.w	r8, [r4, #26]
_ZN5Lcd_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:36
    // Reset display again
    XRES_Lo();
    chThdSleepMilliseconds(7);
 8001c4e:	2007      	movs	r0, #7
 8001c50:	f7fe fd0e 	bl	8000670 <chThdSleep>
PinSet():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:176
    AF0=0, AF1=1, AF2=2, AF3=3, AF4=4, AF5=5, AF6=6, AF7=7,
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
 8001c54:	f8a4 8018 	strh.w	r8, [r4, #24]
_ZN5Lcd_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:38
    XRES_Hi();
    chThdSleepMilliseconds(7);
 8001c58:	2007      	movs	r0, #7
 8001c5a:	f7fe fd09 	bl	8000670 <chThdSleep>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:40
    // Initial commands
    WriteCmd(0xAF);    // display ON
 8001c5e:	4628      	mov	r0, r5
 8001c60:	21af      	movs	r1, #175	; 0xaf
 8001c62:	f7ff ff3d 	bl	8001ae0 <Lcd_t::WriteCmd(unsigned char)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:41
    WriteCmd(0xA4);    // Set normal display mode
 8001c66:	4628      	mov	r0, r5
 8001c68:	21a4      	movs	r1, #164	; 0xa4
 8001c6a:	f7ff ff39 	bl	8001ae0 <Lcd_t::WriteCmd(unsigned char)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:42
    WriteCmd(0x2F);    // Charge pump on
 8001c6e:	4628      	mov	r0, r5
 8001c70:	212f      	movs	r1, #47	; 0x2f
 8001c72:	f7ff ff35 	bl	8001ae0 <Lcd_t::WriteCmd(unsigned char)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:43
    WriteCmd(0x40);    // Set start row address = 0
 8001c76:	4628      	mov	r0, r5
 8001c78:	2140      	movs	r1, #64	; 0x40
 8001c7a:	f7ff ff31 	bl	8001ae0 <Lcd_t::WriteCmd(unsigned char)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:46

#if LCD_MIRROR_Y_AXIS
    WriteCmd(0xC8);    // Mirror Y axis
 8001c7e:	4628      	mov	r0, r5
 8001c80:	21c8      	movs	r1, #200	; 0xc8
 8001c82:	f7ff ff2d 	bl	8001ae0 <Lcd_t::WriteCmd(unsigned char)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:52
#endif
#if LCD_MIRROR_X_AXIS
    WriteCmd(0xA1);    // Mirror X axis
#endif
    // Set x=0, y=0
    WriteCmd(0xB0);    // Y axis initialization
 8001c86:	4628      	mov	r0, r5
 8001c88:	21b0      	movs	r1, #176	; 0xb0
 8001c8a:	f7ff ff29 	bl	8001ae0 <Lcd_t::WriteCmd(unsigned char)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:53
    WriteCmd(0x10);    // X axis initialisation1
 8001c8e:	4628      	mov	r0, r5
 8001c90:	2110      	movs	r1, #16
 8001c92:	f7ff ff25 	bl	8001ae0 <Lcd_t::WriteCmd(unsigned char)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:54
    WriteCmd(0x00);    // X axis initialisation2
 8001c96:	4631      	mov	r1, r6
 8001c98:	4628      	mov	r0, r5
 8001c9a:	f7ff ff21 	bl	8001ae0 <Lcd_t::WriteCmd(unsigned char)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:55
    Cls();             // clear LCD buffer
 8001c9e:	4628      	mov	r0, r5
 8001ca0:	f7ff ff96 	bl	8001bd0 <Lcd_t::Cls()>
PinClockEnable():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:184
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8001ca4:	4b46      	ldr	r3, [pc, #280]	; (8001dc0 <Lcd_t::Init()+0x1d0>)
_ZN5Lcd_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:68
    USART3->BRR = Clk.APB1FreqHz / LCD_UART_SPEED;
    USART3->CR2 = USART_CR2_CLKEN | USART_CR2_LBCL; // Enable clock, enable last bit clock
    USART3->CR1 = USART_CR1_UE | USART_CR1_M | USART_CR1_TE;
    USART3->CR3 = USART_CR3_DMAT;   // Enable DMA at transmitter
    // DMA
    dmaStreamAllocate     (LCD_DMA, IRQ_PRIO_LOW, nullptr, NULL);
 8001ca6:	f8df 8128 	ldr.w	r8, [pc, #296]	; 8001dd0 <Lcd_t::Init()+0x1e0>
PinClockEnable():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:184
 8001caa:	69da      	ldr	r2, [r3, #28]
_ZN5Lcd_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:70
    dmaStreamSetPeripheral(LCD_DMA, &USART3->DR);
    dmaStreamSetMemory0   (LCD_DMA, IBuf);
 8001cac:	350c      	adds	r5, #12
PinClockEnable():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:184
 8001cae:	f042 0202 	orr.w	r2, r2, #2
 8001cb2:	61da      	str	r2, [r3, #28]
PinSetupAlterFunc():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:245
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8001cb4:	6822      	ldr	r2, [r4, #0]
 8001cb6:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8001cba:	6022      	str	r2, [r4, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:246
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8001cbc:	6822      	ldr	r2, [r4, #0]
 8001cbe:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8001cc2:	6022      	str	r2, [r4, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:248
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001cc4:	88a0      	ldrh	r0, [r4, #4]
 8001cc6:	f420 5080 	bic.w	r0, r0, #4096	; 0x1000
 8001cca:	0400      	lsls	r0, r0, #16
 8001ccc:	0c00      	lsrs	r0, r0, #16
 8001cce:	80a0      	strh	r0, [r4, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:249
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001cd0:	88a2      	ldrh	r2, [r4, #4]
 8001cd2:	b292      	uxth	r2, r2
 8001cd4:	80a2      	strh	r2, [r4, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:251
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8001cd6:	68e2      	ldr	r2, [r4, #12]
 8001cd8:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8001cdc:	60e2      	str	r2, [r4, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:252
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8001cde:	68e2      	ldr	r2, [r4, #12]
 8001ce0:	60e2      	str	r2, [r4, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:254
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8001ce2:	68a2      	ldr	r2, [r4, #8]
 8001ce4:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8001ce8:	60a2      	str	r2, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:255
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001cea:	68a2      	ldr	r2, [r4, #8]
 8001cec:	f042 7240 	orr.w	r2, r2, #50331648	; 0x3000000
 8001cf0:	60a2      	str	r2, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:259
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001cf2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001cf4:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
 8001cf8:	6262      	str	r2, [r4, #36]	; 0x24
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:260
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8001cfa:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001cfc:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
 8001d00:	6262      	str	r2, [r4, #36]	; 0x24
PinClockEnable():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:184
// Check state
static inline bool PinIsSet(GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { return (PGpioPort->IDR & (uint32_t)(1<<APinNumber)); }
// Setup
static inline void PinClockEnable(GPIO_TypeDef *PGpioPort) {
    if     (PGpioPort == GPIOA) RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    else if(PGpioPort == GPIOB) RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 8001d02:	69da      	ldr	r2, [r3, #28]
 8001d04:	f042 0202 	orr.w	r2, r2, #2
 8001d08:	61da      	str	r2, [r3, #28]
PinSetupAlterFunc():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:245
        const PinSpeed_t ASpeed = ps10MHz) {
    // Clock
    PinClockEnable(PGpioPort);
    uint32_t Offset = APinNumber*2;
    // Setup mode
    PGpioPort->MODER &= ~(0b11 << Offset);  // clear previous bits
 8001d0a:	6822      	ldr	r2, [r4, #0]
 8001d0c:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8001d10:	6022      	str	r2, [r4, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:246
    PGpioPort->MODER |= 0b10 << Offset;     // Set new bits
 8001d12:	6822      	ldr	r2, [r4, #0]
 8001d14:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8001d18:	6022      	str	r2, [r4, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:248
    // Setup output type
    PGpioPort->OTYPER &= ~(1<<APinNumber);
 8001d1a:	88a0      	ldrh	r0, [r4, #4]
 8001d1c:	f420 6080 	bic.w	r0, r0, #1024	; 0x400
 8001d20:	0400      	lsls	r0, r0, #16
 8001d22:	0c00      	lsrs	r0, r0, #16
 8001d24:	80a0      	strh	r0, [r4, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:249
    PGpioPort->OTYPER |= (uint32_t)PinOutMode << APinNumber;
 8001d26:	88a2      	ldrh	r2, [r4, #4]
_ZN5Lcd_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:68
    USART3->BRR = Clk.APB1FreqHz / LCD_UART_SPEED;
    USART3->CR2 = USART_CR2_CLKEN | USART_CR2_LBCL; // Enable clock, enable last bit clock
    USART3->CR1 = USART_CR1_UE | USART_CR1_M | USART_CR1_TE;
    USART3->CR3 = USART_CR3_DMAT;   // Enable DMA at transmitter
    // DMA
    dmaStreamAllocate     (LCD_DMA, IRQ_PRIO_LOW, nullptr, NULL);
 8001d28:	4640      	mov	r0, r8
PinSetupAlterFunc():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:249
 8001d2a:	b292      	uxth	r2, r2
 8001d2c:	80a2      	strh	r2, [r4, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:251
    // Setup Pull-Up or Pull-Down
    PGpioPort->PUPDR &= ~(0b11 << Offset); // clear previous bits
 8001d2e:	68e2      	ldr	r2, [r4, #12]
 8001d30:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8001d34:	60e2      	str	r2, [r4, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:252
    PGpioPort->PUPDR |= (uint32_t)APullUpDown << Offset;
 8001d36:	68e2      	ldr	r2, [r4, #12]
 8001d38:	60e2      	str	r2, [r4, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:254
    // Setup speed
    PGpioPort->OSPEEDR &= ~(0b11 << Offset); // clear previous bits
 8001d3a:	68a2      	ldr	r2, [r4, #8]
 8001d3c:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8001d40:	60a2      	str	r2, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:255
    PGpioPort->OSPEEDR |= (uint32_t)ASpeed << Offset;
 8001d42:	68a2      	ldr	r2, [r4, #8]
 8001d44:	f442 1240 	orr.w	r2, r2, #3145728	; 0x300000
 8001d48:	60a2      	str	r2, [r4, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:259
    // Setup Alternate Function
    uint32_t n = (APinNumber <= 7)? 0 : 1;      // 0 if 0...7, 1 if 8..15
    Offset = 4 * ((APinNumber <= 7)? APinNumber : APinNumber - 8);
    PGpioPort->AFR[n] &= ~(0b1111 << Offset);
 8001d4a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001d4c:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
 8001d50:	6262      	str	r2, [r4, #36]	; 0x24
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:260
    PGpioPort->AFR[n] |= (uint32_t)AAlterFunc << Offset;
 8001d52:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001d54:	f442 62e0 	orr.w	r2, r2, #1792	; 0x700
 8001d58:	6262      	str	r2, [r4, #36]	; 0x24
_ZN5Lcd_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:61

    // ====================== Switch to USART + DMA ============================
    PinSetupAlterFunc(LCD_GPIO, LCD_SCLK, omPushPull, pudNone, AF7, ps40MHz);
    PinSetupAlterFunc(LCD_GPIO, LCD_SDA,  omPushPull, pudNone, AF7, ps40MHz);
    // ==== USART init ==== clock enabled, idle low, first edge, enable last bit pulse
    rccEnableUSART3(FALSE);
 8001d5a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001d5c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8001d60:	625a      	str	r2, [r3, #36]	; 0x24
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:63
    USART3->CR1 = USART_CR1_UE;     // Enable
    USART3->BRR = Clk.APB1FreqHz / LCD_UART_SPEED;
 8001d62:	4a18      	ldr	r2, [pc, #96]	; (8001dc4 <Lcd_t::Init()+0x1d4>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:62
    // ====================== Switch to USART + DMA ============================
    PinSetupAlterFunc(LCD_GPIO, LCD_SCLK, omPushPull, pudNone, AF7, ps40MHz);
    PinSetupAlterFunc(LCD_GPIO, LCD_SDA,  omPushPull, pudNone, AF7, ps40MHz);
    // ==== USART init ==== clock enabled, idle low, first edge, enable last bit pulse
    rccEnableUSART3(FALSE);
    USART3->CR1 = USART_CR1_UE;     // Enable
 8001d64:	f5a3 33f8 	sub.w	r3, r3, #126976	; 0x1f000
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:63
    USART3->BRR = Clk.APB1FreqHz / LCD_UART_SPEED;
 8001d68:	6851      	ldr	r1, [r2, #4]
 8001d6a:	4a17      	ldr	r2, [pc, #92]	; (8001dc8 <Lcd_t::Init()+0x1d8>)
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:62
    // ====================== Switch to USART + DMA ============================
    PinSetupAlterFunc(LCD_GPIO, LCD_SCLK, omPushPull, pudNone, AF7, ps40MHz);
    PinSetupAlterFunc(LCD_GPIO, LCD_SDA,  omPushPull, pudNone, AF7, ps40MHz);
    // ==== USART init ==== clock enabled, idle low, first edge, enable last bit pulse
    rccEnableUSART3(FALSE);
    USART3->CR1 = USART_CR1_UE;     // Enable
 8001d6c:	819f      	strh	r7, [r3, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:63
    USART3->BRR = Clk.APB1FreqHz / LCD_UART_SPEED;
 8001d6e:	fbb1 f2f2 	udiv	r2, r1, r2
 8001d72:	b292      	uxth	r2, r2
 8001d74:	811a      	strh	r2, [r3, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:64
    USART3->CR2 = USART_CR2_CLKEN | USART_CR2_LBCL; // Enable clock, enable last bit clock
 8001d76:	f44f 6210 	mov.w	r2, #2304	; 0x900
 8001d7a:	821a      	strh	r2, [r3, #16]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:65
    USART3->CR1 = USART_CR1_UE | USART_CR1_M | USART_CR1_TE;
 8001d7c:	f243 0208 	movw	r2, #12296	; 0x3008
 8001d80:	819a      	strh	r2, [r3, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:66
    USART3->CR3 = USART_CR3_DMAT;   // Enable DMA at transmitter
 8001d82:	2280      	movs	r2, #128	; 0x80
 8001d84:	829a      	strh	r2, [r3, #20]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:68
    // DMA
    dmaStreamAllocate     (LCD_DMA, IRQ_PRIO_LOW, nullptr, NULL);
 8001d86:	210f      	movs	r1, #15
 8001d88:	4632      	mov	r2, r6
 8001d8a:	4633      	mov	r3, r6
 8001d8c:	f7fe ff50 	bl	8000c30 <dmaStreamAllocate>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:69
    dmaStreamSetPeripheral(LCD_DMA, &USART3->DR);
 8001d90:	f8d8 3000 	ldr.w	r3, [r8]
 8001d94:	4a0d      	ldr	r2, [pc, #52]	; (8001dcc <Lcd_t::Init()+0x1dc>)
 8001d96:	609a      	str	r2, [r3, #8]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:71
    dmaStreamSetMemory0   (LCD_DMA, IBuf);
    dmaStreamSetTransactionSize(LCD_DMA, LCD_VIDEOBUF_SIZE);
 8001d98:	f44f 7258 	mov.w	r2, #864	; 0x360
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:70
    USART3->CR1 = USART_CR1_UE | USART_CR1_M | USART_CR1_TE;
    USART3->CR3 = USART_CR3_DMAT;   // Enable DMA at transmitter
    // DMA
    dmaStreamAllocate     (LCD_DMA, IRQ_PRIO_LOW, nullptr, NULL);
    dmaStreamSetPeripheral(LCD_DMA, &USART3->DR);
    dmaStreamSetMemory0   (LCD_DMA, IBuf);
 8001d9c:	60dd      	str	r5, [r3, #12]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:71
    dmaStreamSetTransactionSize(LCD_DMA, LCD_VIDEOBUF_SIZE);
 8001d9e:	605a      	str	r2, [r3, #4]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:72
    dmaStreamSetMode      (LCD_DMA, LCD_DMA_TX_MODE);
 8001da0:	f44f 62b6 	mov.w	r2, #1456	; 0x5b0
 8001da4:	601a      	str	r2, [r3, #0]
PinClear():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:177
    AF8=8, AF9=9,AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, AF15=15
};

// Set/clear
static inline void PinSet    (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRL = (uint16_t)(1<<APinNumber); }
static inline void PinClear  (GPIO_TypeDef *PGpioPort, const uint16_t APinNumber) { PGpioPort->BSRRH = (uint16_t)(1<<APinNumber); }
 8001da6:	8367      	strh	r7, [r4, #26]
_ZN5Lcd_t4InitEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:75
    // Start transmission
    XCS_Lo();
    dmaStreamEnable(LCD_DMA);
 8001da8:	681a      	ldr	r2, [r3, #0]
 8001daa:	f042 0201 	orr.w	r2, r2, #1
 8001dae:	601a      	str	r2, [r3, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../lcd1200.cpp:76
}
 8001db0:	b004      	add	sp, #16
 8001db2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001db6:	bf00      	nop
 8001db8:	40020400 	.word	0x40020400
 8001dbc:	40010800 	.word	0x40010800
 8001dc0:	40023800 	.word	0x40023800
 8001dc4:	20000980 	.word	0x20000980
 8001dc8:	000186a0 	.word	0x000186a0
 8001dcc:	40004804 	.word	0x40004804
 8001dd0:	0800230c 	.word	0x0800230c
	...

08001de0 <GeneralSequencerTmrCallback(void*)>:
GeneralSequencerTmrCallback():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:59
public:
    virtual void IProcessSequenceI() = 0;   // Common timer callback can call this
};

// Common Timer callback
static void GeneralSequencerTmrCallback(void *p) {
 8001de0:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:60
    chSysLockFromIsr();
 8001de2:	2320      	movs	r3, #32
 8001de4:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:61
    ((BaseSequenceProcess_t*)p)->IProcessSequenceI();
 8001de8:	6803      	ldr	r3, [r0, #0]
 8001dea:	689b      	ldr	r3, [r3, #8]
 8001dec:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:62
    chSysUnlockFromIsr();
 8001dee:	2300      	movs	r3, #0
 8001df0:	f383 8811 	msr	BASEPRI, r3
 8001df4:	bd08      	pop	{r3, pc}
	...

08001e00 <Beeper_t::ISwitchOff()>:
_ZN8Beeper_t10ISwitchOffEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:18
#define BEEP_TOP_VALUE   22

class Beeper_t : public BaseSequencer_t<BeepChunk_t> {
private:
    PwmPin_t IPin;
    void ISwitchOff() { IPin.Set(0); }
 8001e00:	6a83      	ldr	r3, [r0, #40]	; 0x28
_ZN8PwmPin_t3SetEt():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:271
    TIM_TypeDef* Tim;
public:
    __IO uint32_t *PCCR;    // Made public to allow DMA
    void SetFreqHz(uint32_t FreqHz);
    void Init(GPIO_TypeDef *GPIO, uint16_t N, TIM_TypeDef* PTim, uint8_t Chnl, uint16_t TopValue, bool Inverted=false);
    void Set(uint16_t Value) { *PCCR = Value; }
 8001e02:	2200      	movs	r2, #0
 8001e04:	601a      	str	r2, [r3, #0]
 8001e06:	4770      	bx	lr
	...

08001e10 <Beeper_t::ISetup()>:
_ZN8Beeper_t6ISetupEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:20
    SequencerLoopTask_t ISetup() {
        IPin.SetFreqHz(IPCurrentChunk->Freq_Hz);
 8001e10:	69c3      	ldr	r3, [r0, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:19

class Beeper_t : public BaseSequencer_t<BeepChunk_t> {
private:
    PwmPin_t IPin;
    void ISwitchOff() { IPin.Set(0); }
    SequencerLoopTask_t ISetup() {
 8001e12:	b510      	push	{r4, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:20
        IPin.SetFreqHz(IPCurrentChunk->Freq_Hz);
 8001e14:	f8b3 1005 	ldrh.w	r1, [r3, #5]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:19

class Beeper_t : public BaseSequencer_t<BeepChunk_t> {
private:
    PwmPin_t IPin;
    void ISwitchOff() { IPin.Set(0); }
    SequencerLoopTask_t ISetup() {
 8001e18:	4604      	mov	r4, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:20
        IPin.SetFreqHz(IPCurrentChunk->Freq_Hz);
 8001e1a:	3020      	adds	r0, #32
 8001e1c:	f7ff fbf8 	bl	8001610 <PwmPin_t::SetFreqHz(unsigned long)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:21
        IPin.Set(IPCurrentChunk->Volume);
 8001e20:	69e3      	ldr	r3, [r4, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:20
class Beeper_t : public BaseSequencer_t<BeepChunk_t> {
private:
    PwmPin_t IPin;
    void ISwitchOff() { IPin.Set(0); }
    SequencerLoopTask_t ISetup() {
        IPin.SetFreqHz(IPCurrentChunk->Freq_Hz);
 8001e22:	6aa2      	ldr	r2, [r4, #40]	; 0x28
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:21
        IPin.Set(IPCurrentChunk->Volume);
 8001e24:	f8d3 1001 	ldr.w	r1, [r3, #1]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:22
        IPCurrentChunk++;   // Always goto next
 8001e28:	3307      	adds	r3, #7
_ZN8PwmPin_t3SetEt():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_lib_L15x.h:271
 8001e2a:	b289      	uxth	r1, r1
 8001e2c:	6011      	str	r1, [r2, #0]
_ZN8Beeper_t6ISetupEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:24
        return sltProceed;  // Always proceed
    }
 8001e2e:	2000      	movs	r0, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:22
    PwmPin_t IPin;
    void ISwitchOff() { IPin.Set(0); }
    SequencerLoopTask_t ISetup() {
        IPin.SetFreqHz(IPCurrentChunk->Freq_Hz);
        IPin.Set(IPCurrentChunk->Volume);
        IPCurrentChunk++;   // Always goto next
 8001e30:	61e3      	str	r3, [r4, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/beeper.h:24
        return sltProceed;  // Always proceed
    }
 8001e32:	bd10      	pop	{r4, pc}
	...

08001e40 <BaseSequencer_t<BeepChunk_t>::IProcessSequenceI()>:
_ZN15BaseSequencer_tI11BeepChunk_tE17IProcessSequenceIEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:90
        chSysUnlock();
    }
    const TChunk* GetCurrentSequence() { return IPStartChunk; }

    void IProcessSequenceI() {
        if(chVTIsArmedI(&ITmr)) chVTResetI(&ITmr);  // Reset timer
 8001e40:	6903      	ldr	r3, [r0, #16]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:89
        ISwitchOff();
        chSysUnlock();
    }
    const TChunk* GetCurrentSequence() { return IPStartChunk; }

    void IProcessSequenceI() {
 8001e42:	b510      	push	{r4, lr}
 8001e44:	4604      	mov	r4, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:90
        if(chVTIsArmedI(&ITmr)) chVTResetI(&ITmr);  // Reset timer
 8001e46:	b113      	cbz	r3, 8001e4e <BaseSequencer_t<BeepChunk_t>::IProcessSequenceI()+0xe>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:90 (discriminator 1)
 8001e48:	3004      	adds	r0, #4
 8001e4a:	f7fe fc81 	bl	8000750 <chVTResetI>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:92
        while(true) {   // Process the sequence
            switch(IPCurrentChunk->ChunkSort) {
 8001e4e:	69e3      	ldr	r3, [r4, #28]
 8001e50:	781a      	ldrb	r2, [r3, #0]
 8001e52:	2a03      	cmp	r2, #3
 8001e54:	d8fd      	bhi.n	8001e52 <BaseSequencer_t<BeepChunk_t>::IProcessSequenceI()+0x12>
 8001e56:	e8df f002 	tbb	[pc, r2]
 8001e5a:	0902      	.short	0x0902
 8001e5c:	2819      	.short	0x2819
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:94
                case csSetup: // setup now and exit if required
                    if(ISetup() == sltBreak) return;
 8001e5e:	6823      	ldr	r3, [r4, #0]
 8001e60:	4620      	mov	r0, r4
 8001e62:	681b      	ldr	r3, [r3, #0]
 8001e64:	4798      	blx	r3
 8001e66:	2801      	cmp	r0, #1
 8001e68:	d1f1      	bne.n	8001e4e <BaseSequencer_t<BeepChunk_t>::IProcessSequenceI()+0xe>
 8001e6a:	bd10      	pop	{r4, pc}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:98
                    break;

                case csWait: { // Start timer, pointing to next chunk
                        uint32_t Delay = IPCurrentChunk->Time_ms;
 8001e6c:	f8d3 2001 	ldr.w	r2, [r3, #1]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:99
                        IPCurrentChunk++;
 8001e70:	3307      	adds	r3, #7
 8001e72:	61e3      	str	r3, [r4, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:100
                        if(Delay != 0) {
 8001e74:	2a00      	cmp	r2, #0
 8001e76:	d0ea      	beq.n	8001e4e <BaseSequencer_t<BeepChunk_t>::IProcessSequenceI()+0xe>
_ZN15BaseSequencer_tI11BeepChunk_tE10SetupDelayEm():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:72
private:
    VirtualTimer ITmr;
protected:
    const TChunk *IPStartChunk, *IPCurrentChunk;
    BaseSequencer_t() : IPStartChunk(nullptr), IPCurrentChunk(nullptr) {}
    void SetupDelay(uint32_t ms) { chVTSetI(&ITmr, MS2ST(ms), GeneralSequencerTmrCallback, this); }
 8001e78:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001e7c:	435a      	muls	r2, r3
 8001e7e:	f5a2 727a 	sub.w	r2, r2, #1000	; 0x3e8
 8001e82:	fbb2 f1f3 	udiv	r1, r2, r3
 8001e86:	1d20      	adds	r0, r4, #4
 8001e88:	3101      	adds	r1, #1
 8001e8a:	e008      	b.n	8001e9e <BaseSequencer_t<BeepChunk_t>::IProcessSequenceI()+0x5e>
_ZN15BaseSequencer_tI11BeepChunk_tE17IProcessSequenceIEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:108
                        }
                    }
                    break;

                case csGoto:
                    IPCurrentChunk = IPStartChunk + IPCurrentChunk->ChunkToJumpTo;
 8001e8c:	f8d3 3001 	ldr.w	r3, [r3, #1]
 8001e90:	69a2      	ldr	r2, [r4, #24]
 8001e92:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8001e96:	441a      	add	r2, r3
 8001e98:	61e2      	str	r2, [r4, #28]
_ZN15BaseSequencer_tI11BeepChunk_tE10SetupDelayEm():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:72
private:
    VirtualTimer ITmr;
protected:
    const TChunk *IPStartChunk, *IPCurrentChunk;
    BaseSequencer_t() : IPStartChunk(nullptr), IPCurrentChunk(nullptr) {}
    void SetupDelay(uint32_t ms) { chVTSetI(&ITmr, MS2ST(ms), GeneralSequencerTmrCallback, this); }
 8001e9a:	1d20      	adds	r0, r4, #4
 8001e9c:	2101      	movs	r1, #1
 8001e9e:	4623      	mov	r3, r4
 8001ea0:	4a02      	ldr	r2, [pc, #8]	; (8001eac <BaseSequencer_t<BeepChunk_t>::IProcessSequenceI()+0x6c>)
_ZN15BaseSequencer_tI11BeepChunk_tE17IProcessSequenceIEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:118
                case csEnd:
                    return;
                    break;
            } // switch
        } // while
    } // IProcessSequenceI
 8001ea2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
_ZN15BaseSequencer_tI11BeepChunk_tE10SetupDelayEm():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:72
private:
    VirtualTimer ITmr;
protected:
    const TChunk *IPStartChunk, *IPCurrentChunk;
    BaseSequencer_t() : IPStartChunk(nullptr), IPCurrentChunk(nullptr) {}
    void SetupDelay(uint32_t ms) { chVTSetI(&ITmr, MS2ST(ms), GeneralSequencerTmrCallback, this); }
 8001ea6:	f7fe bc2b 	b.w	8000700 <chVTSetI>
 8001eaa:	bd10      	pop	{r4, pc}
 8001eac:	08001de1 	.word	0x08001de1

08001eb0 <LedChnlTmr_t<255ul, (Inverted_t)1>::Set(unsigned char) const>:
_ZNK12LedChnlTmr_tILm255EL10Inverted_t1EE3SetEh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:37
template <uint32_t TopValue, Inverted_t Inverted>
class LedChnlTmr_t : public LedChnl_t {
public:
    TIM_TypeDef *PTimer;
    uint32_t TmrChnl;
    void Set(const uint8_t AValue) const { *TMR_PCCR(PTimer, TmrChnl) = AValue; }    // CCR[N] = AValue
 8001eb0:	68c2      	ldr	r2, [r0, #12]
 8001eb2:	6883      	ldr	r3, [r0, #8]
 8001eb4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8001eb8:	6319      	str	r1, [r3, #48]	; 0x30
 8001eba:	4770      	bx	lr
 8001ebc:	0000      	movs	r0, r0
	...

08001ec0 <LedSmooth_t::ISwitchOff()>:
_ZN11LedSmooth_t10ISwitchOffEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:146

class LedSmooth_t : public BaseSequencer_t<LedSmoothChunk_t> {
private:
    LedChnlTmr_t<LED_RGB_TOP_VALUE, LED_RGB_INVERTED> IChnl;
    uint8_t ICurrentBrightness;
    void ISwitchOff() { SetBrightness(0); }
 8001ec0:	b508      	push	{r3, lr}
_ZN11LedSmooth_t13SetBrightnessEh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:178
        BaseSequencer_t(), IChnl(AChnl), ICurrentBrightness(0) {}
    void Init() {
        IChnl.Init();
        SetBrightness(0);
    }
    void SetBrightness(uint8_t ABrightness) { IChnl.Set(ABrightness); }
 8001ec2:	3020      	adds	r0, #32
 8001ec4:	2100      	movs	r1, #0
 8001ec6:	f7ff fff3 	bl	8001eb0 <LedChnlTmr_t<255ul, (Inverted_t)1>::Set(unsigned char) const>
 8001eca:	bd08      	pop	{r3, pc}
_ZN11LedSmooth_t10ISwitchOffEv():
 8001ecc:	0000      	movs	r0, r0
	...

08001ed0 <BaseSequencer_t<LedSmoothChunk_t>::SetupDelay(unsigned long)>:
_ZN15BaseSequencer_tI16LedSmoothChunk_tE10SetupDelayEm():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:72
 8001ed0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8001ed4:	4351      	muls	r1, r2
 8001ed6:	f5a1 717a 	sub.w	r1, r1, #1000	; 0x3e8
 8001eda:	fbb1 f1f2 	udiv	r1, r1, r2
 8001ede:	4603      	mov	r3, r0
 8001ee0:	3101      	adds	r1, #1
 8001ee2:	3004      	adds	r0, #4
 8001ee4:	4a01      	ldr	r2, [pc, #4]	; (8001eec <BaseSequencer_t<LedSmoothChunk_t>::SetupDelay(unsigned long)+0x1c>)
 8001ee6:	f7fe bc0b 	b.w	8000700 <chVTSetI>
 8001eea:	bf00      	nop
 8001eec:	08001de1 	.word	0x08001de1

08001ef0 <LedSmooth_t::ISetup()>:
_ZN11LedSmooth_t6ISetupEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:147
class LedSmooth_t : public BaseSequencer_t<LedSmoothChunk_t> {
private:
    LedChnlTmr_t<LED_RGB_TOP_VALUE, LED_RGB_INVERTED> IChnl;
    uint8_t ICurrentBrightness;
    void ISwitchOff() { SetBrightness(0); }
    SequencerLoopTask_t ISetup() {
 8001ef0:	b538      	push	{r3, r4, r5, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:148
        if(ICurrentBrightness != IPCurrentChunk->Brightness) {
 8001ef2:	69c2      	ldr	r2, [r0, #28]
 8001ef4:	f890 3030 	ldrb.w	r3, [r0, #48]	; 0x30
 8001ef8:	7951      	ldrb	r1, [r2, #5]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:147
class LedSmooth_t : public BaseSequencer_t<LedSmoothChunk_t> {
private:
    LedChnlTmr_t<LED_RGB_TOP_VALUE, LED_RGB_INVERTED> IChnl;
    uint8_t ICurrentBrightness;
    void ISwitchOff() { SetBrightness(0); }
    SequencerLoopTask_t ISetup() {
 8001efa:	4604      	mov	r4, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:148
        if(ICurrentBrightness != IPCurrentChunk->Brightness) {
 8001efc:	428b      	cmp	r3, r1
 8001efe:	d02a      	beq.n	8001f56 <LedSmooth_t::ISetup()+0x66>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:149
            if(IPCurrentChunk->Value == 0) {     // If smooth time is zero,
 8001f00:	f8d2 5001 	ldr.w	r5, [r2, #1]
 8001f04:	3020      	adds	r0, #32
 8001f06:	b935      	cbnz	r5, 8001f16 <LedSmooth_t::ISetup()+0x26>
_ZN11LedSmooth_t13SetBrightnessEh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:178
        BaseSequencer_t(), IChnl(AChnl), ICurrentBrightness(0) {}
    void Init() {
        IChnl.Init();
        SetBrightness(0);
    }
    void SetBrightness(uint8_t ABrightness) { IChnl.Set(ABrightness); }
 8001f08:	f7ff ffd2 	bl	8001eb0 <LedChnlTmr_t<255ul, (Inverted_t)1>::Set(unsigned char) const>
_ZN11LedSmooth_t6ISetupEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:151
    void ISwitchOff() { SetBrightness(0); }
    SequencerLoopTask_t ISetup() {
        if(ICurrentBrightness != IPCurrentChunk->Brightness) {
            if(IPCurrentChunk->Value == 0) {     // If smooth time is zero,
                SetBrightness(IPCurrentChunk->Brightness); // set color now,
                ICurrentBrightness = IPCurrentChunk->Brightness;
 8001f0c:	69e3      	ldr	r3, [r4, #28]
 8001f0e:	795a      	ldrb	r2, [r3, #5]
 8001f10:	f884 2030 	strb.w	r2, [r4, #48]	; 0x30
 8001f14:	e011      	b.n	8001f3a <LedSmooth_t::ISetup()+0x4a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:155
                IPCurrentChunk++;                // and goto next chunk
            }
            else {
                if     (ICurrentBrightness < IPCurrentChunk->Brightness) ICurrentBrightness++;
 8001f16:	428b      	cmp	r3, r1
 8001f18:	d201      	bcs.n	8001f1e <LedSmooth_t::ISetup()+0x2e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:155 (discriminator 1)
 8001f1a:	3301      	adds	r3, #1
 8001f1c:	e001      	b.n	8001f22 <LedSmooth_t::ISetup()+0x32>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:156
                else if(ICurrentBrightness > IPCurrentChunk->Brightness) ICurrentBrightness--;
 8001f1e:	d902      	bls.n	8001f26 <LedSmooth_t::ISetup()+0x36>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:156 (discriminator 1)
 8001f20:	3b01      	subs	r3, #1
 8001f22:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
_ZN11LedSmooth_t13SetBrightnessEh():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:178
        BaseSequencer_t(), IChnl(AChnl), ICurrentBrightness(0) {}
    void Init() {
        IChnl.Init();
        SetBrightness(0);
    }
    void SetBrightness(uint8_t ABrightness) { IChnl.Set(ABrightness); }
 8001f26:	f894 1030 	ldrb.w	r1, [r4, #48]	; 0x30
 8001f2a:	f7ff ffc1 	bl	8001eb0 <LedChnlTmr_t<255ul, (Inverted_t)1>::Set(unsigned char) const>
_ZN11LedSmooth_t6ISetupEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:159
            else {
                if     (ICurrentBrightness < IPCurrentChunk->Brightness) ICurrentBrightness++;
                else if(ICurrentBrightness > IPCurrentChunk->Brightness) ICurrentBrightness--;
                SetBrightness(ICurrentBrightness);
                // Check if completed now
                if(ICurrentBrightness == IPCurrentChunk->Brightness) IPCurrentChunk++;
 8001f2e:	69e3      	ldr	r3, [r4, #28]
 8001f30:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
 8001f34:	7959      	ldrb	r1, [r3, #5]
 8001f36:	4291      	cmp	r1, r2
 8001f38:	d102      	bne.n	8001f40 <LedSmooth_t::ISetup()+0x50>
 8001f3a:	3306      	adds	r3, #6
 8001f3c:	61e3      	str	r3, [r4, #28]
 8001f3e:	e00c      	b.n	8001f5a <LedSmooth_t::ISetup()+0x6a>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:162
                else { // Not completed
                    // Calculate time to next adjustment
                    uint32_t Delay = ICalcDelay(ICurrentBrightness, IPCurrentChunk->Value);
 8001f40:	f8d3 1001 	ldr.w	r1, [r3, #1]
ICalcDelay():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:49
    }
    LedChnlTmr_t(GPIO_TypeDef *APGpio, uint16_t APin, TIM_TypeDef *APTimer, uint32_t ATmrChnl) : LedChnl_t(APGpio, APin), PTimer(APTimer), TmrChnl(ATmrChnl) {}
};

// TimeToWaitBeforeNextAdjustment = SmoothVar / (N+4) + 1, where N - current LED brightness.
static inline uint32_t ICalcDelay(uint32_t CurrentBrightness, uint32_t SmoothVar) { return (uint32_t)((SmoothVar / (CurrentBrightness+4)) + 1); }
 8001f44:	3204      	adds	r2, #4
 8001f46:	fbb1 f1f2 	udiv	r1, r1, r2
_ZN11LedSmooth_t6ISetupEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:163
                // Check if completed now
                if(ICurrentBrightness == IPCurrentChunk->Brightness) IPCurrentChunk++;
                else { // Not completed
                    // Calculate time to next adjustment
                    uint32_t Delay = ICalcDelay(ICurrentBrightness, IPCurrentChunk->Value);
                    SetupDelay(Delay);
 8001f4a:	4620      	mov	r0, r4
 8001f4c:	3101      	adds	r1, #1
 8001f4e:	f7ff ffbf 	bl	8001ed0 <BaseSequencer_t<LedSmoothChunk_t>::SetupDelay(unsigned long)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:164
                    return sltBreak;
 8001f52:	2001      	movs	r0, #1
 8001f54:	bd38      	pop	{r3, r4, r5, pc}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:168
                } // Not completed
            } // if time > 256
        } // if color is different
        else IPCurrentChunk++; // Color is the same, goto next chunk
 8001f56:	3206      	adds	r2, #6
 8001f58:	61c2      	str	r2, [r0, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:169
        return sltProceed;
 8001f5a:	2000      	movs	r0, #0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/led.h:170
    }
 8001f5c:	bd38      	pop	{r3, r4, r5, pc}
	...

08001f60 <BaseSequencer_t<LedSmoothChunk_t>::IProcessSequenceI()>:
_ZN15BaseSequencer_tI16LedSmoothChunk_tE17IProcessSequenceIEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:90
        chSysUnlock();
    }
    const TChunk* GetCurrentSequence() { return IPStartChunk; }

    void IProcessSequenceI() {
        if(chVTIsArmedI(&ITmr)) chVTResetI(&ITmr);  // Reset timer
 8001f60:	6903      	ldr	r3, [r0, #16]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:89
        ISwitchOff();
        chSysUnlock();
    }
    const TChunk* GetCurrentSequence() { return IPStartChunk; }

    void IProcessSequenceI() {
 8001f62:	b510      	push	{r4, lr}
 8001f64:	4604      	mov	r4, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:90
        if(chVTIsArmedI(&ITmr)) chVTResetI(&ITmr);  // Reset timer
 8001f66:	b113      	cbz	r3, 8001f6e <BaseSequencer_t<LedSmoothChunk_t>::IProcessSequenceI()+0xe>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:90 (discriminator 1)
 8001f68:	3004      	adds	r0, #4
 8001f6a:	f7fe fbf1 	bl	8000750 <chVTResetI>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:92
        while(true) {   // Process the sequence
            switch(IPCurrentChunk->ChunkSort) {
 8001f6e:	69e3      	ldr	r3, [r4, #28]
 8001f70:	781a      	ldrb	r2, [r3, #0]
 8001f72:	2a03      	cmp	r2, #3
 8001f74:	d8fd      	bhi.n	8001f72 <BaseSequencer_t<LedSmoothChunk_t>::IProcessSequenceI()+0x12>
 8001f76:	e8df f002 	tbb	[pc, r2]
 8001f7a:	0902      	.short	0x0902
 8001f7c:	1c11      	.short	0x1c11
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:94
                case csSetup: // setup now and exit if required
                    if(ISetup() == sltBreak) return;
 8001f7e:	6823      	ldr	r3, [r4, #0]
 8001f80:	4620      	mov	r0, r4
 8001f82:	681b      	ldr	r3, [r3, #0]
 8001f84:	4798      	blx	r3
 8001f86:	2801      	cmp	r0, #1
 8001f88:	d1f1      	bne.n	8001f6e <BaseSequencer_t<LedSmoothChunk_t>::IProcessSequenceI()+0xe>
 8001f8a:	bd10      	pop	{r4, pc}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:98
                    break;

                case csWait: { // Start timer, pointing to next chunk
                        uint32_t Delay = IPCurrentChunk->Time_ms;
 8001f8c:	f8d3 1001 	ldr.w	r1, [r3, #1]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:99
                        IPCurrentChunk++;
 8001f90:	3306      	adds	r3, #6
 8001f92:	61e3      	str	r3, [r4, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:100
                        if(Delay != 0) {
 8001f94:	2900      	cmp	r1, #0
 8001f96:	d0ea      	beq.n	8001f6e <BaseSequencer_t<LedSmoothChunk_t>::IProcessSequenceI()+0xe>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:101
                            SetupDelay(Delay);
 8001f98:	4620      	mov	r0, r4
 8001f9a:	e008      	b.n	8001fae <BaseSequencer_t<LedSmoothChunk_t>::IProcessSequenceI()+0x4e>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:108
                        }
                    }
                    break;

                case csGoto:
                    IPCurrentChunk = IPStartChunk + IPCurrentChunk->ChunkToJumpTo;
 8001f9c:	f8d3 2001 	ldr.w	r2, [r3, #1]
 8001fa0:	69a3      	ldr	r3, [r4, #24]
 8001fa2:	2106      	movs	r1, #6
 8001fa4:	fb01 3302 	mla	r3, r1, r2, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:109
                    SetupDelay(1);
 8001fa8:	4620      	mov	r0, r4
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:108
                        }
                    }
                    break;

                case csGoto:
                    IPCurrentChunk = IPStartChunk + IPCurrentChunk->ChunkToJumpTo;
 8001faa:	61e3      	str	r3, [r4, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:109
                    SetupDelay(1);
 8001fac:	2101      	movs	r1, #1
 8001fae:	f7ff ff8f 	bl	8001ed0 <BaseSequencer_t<LedSmoothChunk_t>::SetupDelay(unsigned long)>
 8001fb2:	bd10      	pop	{r4, pc}
	...

08001fc0 <BaseSequencer_t<BeepChunk_t>::StartSequence(BeepChunk_t const*)>:
_ZN15BaseSequencer_tI11BeepChunk_tE13StartSequenceEPKS0_():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:74
protected:
    const TChunk *IPStartChunk, *IPCurrentChunk;
    BaseSequencer_t() : IPStartChunk(nullptr), IPCurrentChunk(nullptr) {}
    void SetupDelay(uint32_t ms) { chVTSetI(&ITmr, MS2ST(ms), GeneralSequencerTmrCallback, this); }
public:
    void StartSequence(const TChunk *PLedChunk) {
 8001fc0:	b508      	push	{r3, lr}
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:75
        chSysLock();
 8001fc2:	2320      	movs	r3, #32
 8001fc4:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:78
        IPStartChunk = PLedChunk;   // Save first chunk
        IPCurrentChunk = PLedChunk;
        IProcessSequenceI();
 8001fc8:	6803      	ldr	r3, [r0, #0]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:76
    BaseSequencer_t() : IPStartChunk(nullptr), IPCurrentChunk(nullptr) {}
    void SetupDelay(uint32_t ms) { chVTSetI(&ITmr, MS2ST(ms), GeneralSequencerTmrCallback, this); }
public:
    void StartSequence(const TChunk *PLedChunk) {
        chSysLock();
        IPStartChunk = PLedChunk;   // Save first chunk
 8001fca:	6181      	str	r1, [r0, #24]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:77
        IPCurrentChunk = PLedChunk;
 8001fcc:	61c1      	str	r1, [r0, #28]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:78
        IProcessSequenceI();
 8001fce:	689b      	ldr	r3, [r3, #8]
 8001fd0:	4798      	blx	r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/ChunkTypes.h:79
        chSysUnlock();
 8001fd2:	2300      	movs	r3, #0
 8001fd4:	f383 8811 	msr	BASEPRI, r3
 8001fd8:	bd08      	pop	{r3, pc}
 8001fda:	0000      	movs	r0, r0
 8001fdc:	0000      	movs	r0, r0
	...

08001fe0 <App_t::ITask()>:
_ZN5App_t5ITaskEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:56
    // Main cycle
    App.ITask();
}

__attribute__ ((__noreturn__))
void App_t::ITask() {
 8001fe0:	b583      	push	{r0, r1, r7, lr}
 8001fe2:	4606      	mov	r6, r0
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:58
    while(true) {
        uint32_t EvtMsk = chEvtWaitAny(ALL_EVENTS);
 8001fe4:	f04f 30ff 	mov.w	r0, #4294967295
 8001fe8:	f7fe f97a 	bl	80002e0 <chEvtWaitAny>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:60
#if 1 // ==== Keys ====
        if(EvtMsk & EVTMSK_KEYS) {
 8001fec:	0783      	lsls	r3, r0, #30
 8001fee:	d5f9      	bpl.n	8001fe4 <App_t::ITask()+0x4>
_ZN9CircBuf_tI12KeyEvtInfo_tLm7EE3GetEPS0_():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:33 (discriminator 1)
protected:
    uint32_t IFullSlotsCount=0;
    T IBuf[Sz], *PRead=IBuf, *PWrite=IBuf;
public:
    uint8_t Get(T *p) {
        if(IFullSlotsCount == 0) return FAILURE;
 8001ff0:	4918      	ldr	r1, [pc, #96]	; (8002054 <App_t::ITask()+0x74>)
 8001ff2:	698a      	ldr	r2, [r1, #24]
 8001ff4:	4608      	mov	r0, r1
 8001ff6:	2a00      	cmp	r2, #0
 8001ff8:	d0f4      	beq.n	8001fe4 <App_t::ITask()+0x4>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:34
        memcpy(p, PRead, sizeof(T));
 8001ffa:	6c8c      	ldr	r4, [r1, #72]	; 0x48
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:35
        if(++PRead > (IBuf + Sz - 1)) PRead = IBuf;     // Circulate buffer
 8001ffc:	f101 0e40 	add.w	lr, r1, #64	; 0x40
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:34
    uint32_t IFullSlotsCount=0;
    T IBuf[Sz], *PRead=IBuf, *PWrite=IBuf;
public:
    uint8_t Get(T *p) {
        if(IFullSlotsCount == 0) return FAILURE;
        memcpy(p, PRead, sizeof(T));
 8002000:	7827      	ldrb	r7, [r4, #0]
 8002002:	7863      	ldrb	r3, [r4, #1]
 8002004:	78a5      	ldrb	r5, [r4, #2]
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:35
        if(++PRead > (IBuf + Sz - 1)) PRead = IBuf;     // Circulate buffer
 8002006:	3406      	adds	r4, #6
 8002008:	4574      	cmp	r4, lr
 800200a:	bf88      	it	hi
 800200c:	f101 001c 	addhi.w	r0, r1, #28
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:36
        IFullSlotsCount--;
 8002010:	f102 32ff 	add.w	r2, r2, #4294967295
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:35
    T IBuf[Sz], *PRead=IBuf, *PWrite=IBuf;
public:
    uint8_t Get(T *p) {
        if(IFullSlotsCount == 0) return FAILURE;
        memcpy(p, PRead, sizeof(T));
        if(++PRead > (IBuf + Sz - 1)) PRead = IBuf;     // Circulate buffer
 8002014:	bf8c      	ite	hi
 8002016:	6488      	strhi	r0, [r1, #72]	; 0x48
 8002018:	648c      	strls	r4, [r1, #72]	; 0x48
D:\Nute\MagicThings\Salem\Box_fw\Debug/../kl_lib/kl_buf.h:36
        IFullSlotsCount--;
 800201a:	618a      	str	r2, [r1, #24]
_ZN5App_t5ITaskEv():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:63
            KeyEvtInfo_t EInfo;
            while(Keys.EvtBuf.Get(&EInfo) == OK) {
                Uart.Printf("\rEinfo: %u, %u, %u", EInfo.Type, EInfo.KeysCnt, EInfo.KeyID[0]);
 800201c:	480e      	ldr	r0, [pc, #56]	; (8002058 <App_t::ITask()+0x78>)
 800201e:	9500      	str	r5, [sp, #0]
 8002020:	490e      	ldr	r1, [pc, #56]	; (800205c <App_t::ITask()+0x7c>)
 8002022:	463a      	mov	r2, r7
 8002024:	f7ff fc64 	bl	80018f0 <CmdUart_t::Printf(char const*, ...)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:64
                if(EInfo.Type == kePress or EInfo.Type == keRepeat) {
 8002028:	f017 0ffb 	tst.w	r7, #251	; 0xfb
 800202c:	d1e0      	bne.n	8001ff0 <App_t::ITask()+0x10>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:65
                    Beeper.StartSequence(bsqButton);
 800202e:	480c      	ldr	r0, [pc, #48]	; (8002060 <App_t::ITask()+0x80>)
 8002030:	490c      	ldr	r1, [pc, #48]	; (8002064 <App_t::ITask()+0x84>)
 8002032:	f7ff ffc5 	bl	8001fc0 <BaseSequencer_t<BeepChunk_t>::StartSequence(BeepChunk_t const*)>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.cpp:66
                    switch(EInfo.KeyID[0]) {
 8002036:	2d02      	cmp	r5, #2
 8002038:	d001      	beq.n	800203e <App_t::ITask()+0x5e>
 800203a:	2d03      	cmp	r5, #3
 800203c:	d1d8      	bne.n	8001ff0 <App_t::ITask()+0x10>
_ZN5App_t9SignalEvtEm():
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.h:26
private:
    BoxState_t State;
public:
    Thread *PThread;
    void SignalEvt(eventmask_t Evt) {
        chSysLock();
 800203e:	2320      	movs	r3, #32
 8002040:	f383 8811 	msr	BASEPRI, r3
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.h:27
        chEvtSignalI(PThread, Evt);
 8002044:	2104      	movs	r1, #4
 8002046:	6870      	ldr	r0, [r6, #4]
 8002048:	f7fe f92a 	bl	80002a0 <chEvtSignalI>
D:\Nute\MagicThings\Salem\Box_fw\Debug/../main.h:28
        chSysUnlock();
 800204c:	2300      	movs	r3, #0
 800204e:	f383 8811 	msr	BASEPRI, r3
 8002052:	e7cd      	b.n	8001ff0 <App_t::ITask()+0x10>
 8002054:	2000098c 	.word	0x2000098c
 8002058:	200009dc 	.word	0x200009dc
 800205c:	08002a70 	.word	0x08002a70
 8002060:	2000169c 	.word	0x2000169c
 8002064:	08002ac0 	.word	0x08002ac0
	...

08002070 <memset>:
memset():
 8002070:	b4f0      	push	{r4, r5, r6, r7}
 8002072:	0784      	lsls	r4, r0, #30
 8002074:	d043      	beq.n	80020fe <memset+0x8e>
 8002076:	1e54      	subs	r4, r2, #1
 8002078:	2a00      	cmp	r2, #0
 800207a:	d03e      	beq.n	80020fa <memset+0x8a>
 800207c:	b2cd      	uxtb	r5, r1
 800207e:	4603      	mov	r3, r0
 8002080:	e003      	b.n	800208a <memset+0x1a>
 8002082:	1e62      	subs	r2, r4, #1
 8002084:	2c00      	cmp	r4, #0
 8002086:	d038      	beq.n	80020fa <memset+0x8a>
 8002088:	4614      	mov	r4, r2
 800208a:	f803 5b01 	strb.w	r5, [r3], #1
 800208e:	079a      	lsls	r2, r3, #30
 8002090:	d1f7      	bne.n	8002082 <memset+0x12>
 8002092:	2c03      	cmp	r4, #3
 8002094:	d92a      	bls.n	80020ec <memset+0x7c>
 8002096:	b2cd      	uxtb	r5, r1
 8002098:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800209c:	2c0f      	cmp	r4, #15
 800209e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80020a2:	d915      	bls.n	80020d0 <memset+0x60>
 80020a4:	f1a4 0710 	sub.w	r7, r4, #16
 80020a8:	093f      	lsrs	r7, r7, #4
 80020aa:	f103 0610 	add.w	r6, r3, #16
 80020ae:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 80020b2:	461a      	mov	r2, r3
 80020b4:	6015      	str	r5, [r2, #0]
 80020b6:	6055      	str	r5, [r2, #4]
 80020b8:	6095      	str	r5, [r2, #8]
 80020ba:	60d5      	str	r5, [r2, #12]
 80020bc:	3210      	adds	r2, #16
 80020be:	42b2      	cmp	r2, r6
 80020c0:	d1f8      	bne.n	80020b4 <memset+0x44>
 80020c2:	f004 040f 	and.w	r4, r4, #15
 80020c6:	3701      	adds	r7, #1
 80020c8:	2c03      	cmp	r4, #3
 80020ca:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 80020ce:	d90d      	bls.n	80020ec <memset+0x7c>
 80020d0:	461e      	mov	r6, r3
 80020d2:	4622      	mov	r2, r4
 80020d4:	3a04      	subs	r2, #4
 80020d6:	2a03      	cmp	r2, #3
 80020d8:	f846 5b04 	str.w	r5, [r6], #4
 80020dc:	d8fa      	bhi.n	80020d4 <memset+0x64>
 80020de:	1f22      	subs	r2, r4, #4
 80020e0:	f022 0203 	bic.w	r2, r2, #3
 80020e4:	3204      	adds	r2, #4
 80020e6:	4413      	add	r3, r2
 80020e8:	f004 0403 	and.w	r4, r4, #3
 80020ec:	b12c      	cbz	r4, 80020fa <memset+0x8a>
 80020ee:	b2c9      	uxtb	r1, r1
 80020f0:	441c      	add	r4, r3
 80020f2:	f803 1b01 	strb.w	r1, [r3], #1
 80020f6:	42a3      	cmp	r3, r4
 80020f8:	d1fb      	bne.n	80020f2 <memset+0x82>
 80020fa:	bcf0      	pop	{r4, r5, r6, r7}
 80020fc:	4770      	bx	lr
 80020fe:	4614      	mov	r4, r2
 8002100:	4603      	mov	r3, r0
 8002102:	e7c6      	b.n	8002092 <memset+0x22>
	...
$d():
 8002110:	08060403 	.word	0x08060403
 8002114:	2018100c 	.word	0x2018100c
 8002118:	00000030 	.word	0x00000030
 800211c:	00000000 	.word	0x00000000
 8002120:	03020100 	.word	0x03020100
 8002124:	08070604 	.word	0x08070604
 8002128:	00000009 	.word	0x00000009
 800212c:	03020100 	.word	0x03020100
 8002130:	00000004 	.word	0x00000004
	...
 8002140:	45686322 	.word	0x45686322
 8002144:	65527476 	.word	0x65527476
 8002148:	74736967 	.word	0x74736967
 800214c:	614d7265 	.word	0x614d7265
 8002150:	28226b73 	.word	0x28226b73
 8002154:	63220029 	.word	0x63220029
 8002158:	74764568 	.word	0x74764568
 800215c:	65726e55 	.word	0x65726e55
 8002160:	74736967 	.word	0x74736967
 8002164:	28227265 	.word	0x28227265
 8002168:	63220029 	.word	0x63220029
 800216c:	74764568 	.word	0x74764568
 8002170:	6e676953 	.word	0x6e676953
 8002174:	22496c61 	.word	0x22496c61
 8002178:	22002928 	.word	0x22002928
 800217c:	76456863 	.word	0x76456863
 8002180:	6f724274 	.word	0x6f724274
 8002184:	61636461 	.word	0x61636461
 8002188:	614d7473 	.word	0x614d7473
 800218c:	22496b73 	.word	0x22496b73
 8002190:	22002928 	.word	0x22002928
 8002194:	76456863 	.word	0x76456863
 8002198:	67695374 	.word	0x67695374
 800219c:	226c616e 	.word	0x226c616e
 80021a0:	22002928 	.word	0x22002928
 80021a4:	76456863 	.word	0x76456863
 80021a8:	73694474 	.word	0x73694474
 80021ac:	63746170 	.word	0x63746170
 80021b0:	29282268 	.word	0x29282268
 80021b4:	45686300 	.word	0x45686300
 80021b8:	69447476 	.word	0x69447476
 80021bc:	74617073 	.word	0x74617073
 80021c0:	29286863 	.word	0x29286863
 80021c4:	3123202c 	.word	0x3123202c
	...

080021d0 <ch_debug>:
 80021d0:	6e69616d 11801600 08280404 1814100c     main......(.....
 80021e0:	001d1c00 0000001e 00000000 00000000     ................
 80021f0:	63536863 61655268 28497964 23202c29     chSchReadyI(), #
 8002200:	00000031 00000000 00000000 00000000     1...............
 8002210:	656c6469 00000000 00000000 00000000     idle............
 8002220:	54686322 72436468 65746165 29282249     "chThdCreateI"()
 8002230:	68632200 53646854 72507465 69726f69     ."chThdSetPriori
 8002240:	28227974 68630029 52646854 6d757365     ty"().chThdResum
 8002250:	2c292865 00312320 54686322 6c536468     e(), #1."chThdSl
 8002260:	22706565 63002928 64685468 74697845     eep"().chThdExit
 8002270:	2c292853 00312320 00000000 00000000     S(), #1.........
 8002280:	56686322 74655354 29282249 68632200     "chVTSetI"()."ch
 8002290:	65525456 49746573 00292822 54566863     VTResetI"().chVT
 80022a0:	65736552 29284974 3123202c 00000000     ResetI(), #1....
 80022b0:	616d6422 65727453 6c416d61 61636f6c     "dmaStreamAlloca
 80022c0:	28226574 64220029 7453616d 6d616572     te"()."dmaStream
 80022d0:	656c6552 22657361 64002928 7453616d     Release"().dmaSt
 80022e0:	6d616572 656c6552 28657361 23202c29     reamRelease(), #
 80022f0:	00000031 00000000 00000000 00000000     1...............

08002300 <_stm32_dma_streams>:
 8002300:	40026008 40026004 000b0000 4002601c     .`.@.`.@.....`.@
 8002310:	40026004 000c0104 40026030 40026004     .`.@....0`.@.`.@
 8002320:	000d0208 40026044 40026004 000e030c     ....D`.@.`.@....
 8002330:	40026058 40026004 000f0410 4002606c     X`.@.`.@....l`.@
 8002340:	40026004 00100514 40026080 40026004     .`.@.....`.@.`.@
 8002350:	00110618 00000000 00000000 00000000     ................

08002360 <SnsGroupMSns>:
 8002360:	00000002 00000004 00000008 00000000     ................
 8002370:	080023a0 20000864 00000000 00000000     .#..d.. ........

08002380 <SnsGroupKey>:
 8002380:	00000004 00000000 00000000 08001201     ................
 8002390:	080023c0 20000978 00000000 00000000     .#..x.. ........

080023a0 <MSnsGroupData>:
 80023a0:	40020400 00020002 40020400 00020005     ...@.......@....
 80023b0:	736e6553 0073726f 00000000 00000000     Sensors.........

080023c0 <SnsKeyGroupData>:
 80023c0:	40020000 00010008 40020000 0001000f     ...@.......@....
 80023d0:	40020400 00010006 40020400 0001000f     ...@.......@....
 80023e0:	0d004020 00000000 00000000 00000000      @..............

080023f0 <Font_6x8_Data>:
 80023f0:	00000000 7c000000 7ca28aa2 f6d67c00     .......|...|.|..
 8002400:	38007cd6 387c3e7c 7e3c1800 0c00183c     .|.8|>|8..<~<...
 8002410:	0c6cfe6c 7e3a1800 0000183a 00001818     l.l...:~:.......
 8002420:	e7e7ffff 3c00ffff 003c2424 dbdbc3ff     .......<$$<.....
 8002430:	0c00ffc3 706c5212 9e946000 06006094     .....Rlp.`...`..
 8002440:	2040fc0e 507e0600 5400fcac 54386c38     ..@ ..~P...T8l8T
 8002450:	7cfe0000 10001038 00fe7c38 fe6c2800     ...|8...8|...(l.
 8002460:	0000286c 00fa00fa fe906000 4400fe80     l(.......`.....D
 8002470:	449aaab2 06060600 28000006 286dff6d     ...D.......(m.m(
 8002480:	fe602000 08002060 080cfe0c 7c101000     . `.` .........|
 8002490:	10001038 10107c38 02021e00 10000202     8...8|..........
 80024a0:	107c107c fc3c0c00 c0000c3c c0f0fcf0     |.|...<.<.......
	...
 80024b8:	0060fa60 00c0e000 2400c0e0 247e247e     `.`........$~$~$
 80024c8:	56d42400 c6000048 c62610c8 6a926c00     .$.VH.....&..l.j
 80024d8:	00000a04 0000c0e0 827c0000 00000000     ..........|.....
 80024e8:	00007c82 387c1000 1000107c 10107c10     .|....|8|....|..
 80024f8:	06070000 10000000 10101010 06060000     ................
 8002508:	04000000 40201008 82827c00 00007c82     ...... @.|...|..
 8002518:	0002fe42 928a4600 44006292 6c929292     B....F...b.D...l
 8002528:	48281800 f40008fe 8c929292 92523c00     ..(H.........<R.
 8002538:	80000c92 c0a0908e 92926c00 60006c92     .........l...l.`
 8002548:	78949292 36360000 00000000 00003637     ...x..66....76..
 8002558:	44281000 24000082 24242424 44820000     ..(D...$$$$$...D
 8002568:	40001028 60909a80 ba827c00 7e0078aa     (..@...`.|...x.~
 8002578:	7e888888 9292fe00 7c006c92 44828282     ...~.....l.|...D
 8002588:	8282fe00 fe007c82 82929292 9090fe00     .....|..........
 8002598:	7c008090 5e929282 1010fe00 0000fe10     ...|...^........
 80025a8:	0082fe82 02020c00 fe00fc02 82442810     .............(D.
 80025b8:	0202fe00 fe000202 fe402040 2040fe00     ........@ @...@ 
 80025c8:	7c00fe10 7c828282 9090fe00 7c006090     ...|...|.....`.|
 80025d8:	7a848a82 9090fe00 64006698 4c929292     ...z.....f.d...L
 80025e8:	fe808000 fc008080 fc020202 0204f800     ................
 80025f8:	fc00f804 fc023c02 1028c600 e000c628     .....<....(.(...
 8002608:	e0100e10 a2928e00 000000c2 008282fe     ................
 8002618:	10204000 00000408 00fe8282 80402000     .@ .......... @.
 8002628:	01012040 01010101 e0c00000 04000000     @ ..............
 8002638:	1e2a2a2a 2222fe00 1c001c22 14222222     ***..."""...""".
 8002648:	22221c00 1c00fe22 102a2a2a 907e1000     .."""...***...~.
 8002658:	18000090 3e252525 2020fe00 0000001e     ....%%%>..  ....
 8002668:	0002be00 21010200 fe0000be 00221408     .......!......".
 8002678:	fe000000 3e000002 1e201820 20203e00     .......> . ..>  
 8002688:	1c00001e 1c222222 22223f00 1c001c22     ...."""..?"""...
 8002698:	3f222222 221e2200 10001020 042a2a2a     """?."." ...***.
 80026a8:	227c2000 3c000024 003e0402 02043800     . |"$..<..>..8..
 80026b8:	3c003804 3c060c06 08083600 39000036     .8.<...<.6..6..9
 80026c8:	003c0605 2a2a2600 10000032 0082827c     ..<..&**2...|...
 80026d8:	ee000000 00000000 107c8282 40804000     ..........|..@.@
 80026e8:	3c000080 3c64c464 88228822 aa558822     ...<d.d<".".".U.
 80026f8:	aa55aa55 77dd77dd 000077dd 0000ff00     U.U..w.w.w......
 8002708:	ff101010 50500000 0000ff50 ff00ff10     ......PPP.......
 8002718:	1f100000 00001f10 7f505050 df500000     ........PPP...P.
 8002728:	0000ff00 ff00ff00 5f500000 00007f40     ..........P_@...
 8002738:	f010d050 f0100000 0000f010 f0505050     P...........PPP.
 8002748:	10100000 00001f10 f0000000 10101010     ................
 8002758:	1010f010 1f101010 00001010 1010ff00     ................
 8002768:	10101010 10101010 1010ff10 ff000000     ................
 8002778:	ff005050 1010ff00 d010f000 7f005050     PP..........PP..
 8002788:	50505f40 d010d050 5f505050 50505f40     @_PPP...PPP_@_PP
 8002798:	df00ff00 50505050 50505050 df00df50     ....PPPPPPPPP...
 80027a8:	50505050 5050d050 f010f010 50501010     PPPPP.PP......PP
 80027b8:	50505f50 1f101f10 f0001010 1010f010     P_PP............
 80027c8:	f0000000 00005050 50507f00 1f101f00     ....PP....PP....
 80027d8:	ff101010 1010ff10 52d27e00 505042d2     .........~.R.BPP
 80027e8:	5050ff50 f0101010 00000000 10101f00     P.PP............
 80027f8:	ffffffff 0f0fffff 0f0f0f0f 00ffffff     ................
 8002808:	00000000 ffffff00 f0f0f0f0 7c00f0f0     ...............|
 8002818:	44829292 2a2a1c00 80001422 80027e02     ...D..**"....~..
 8002828:	3e800000 e4000082 fc12d212 4645b900     ...>..........EF
 8002838:	600000bc 00609090 2aaa1c00 000010aa     ...`..`....*....
 8002848:	00001818 00100000 0c000000 40407c02     .............|@@
 8002858:	fe1860fe 7c54c8c8 547c2828 3c3c3c00     .`....T|((|T.<<<
 8002868:	0000003c 00000000 88887e00 fe007e88     <........~...~..
 8002878:	8c929292 9292fe00 fe006c92 80808080     .........l......
 8002888:	82827e03 fe0003fe 82929292 fe10ee00     .~..............
 8002898:	9244ee10 006c9292 0804fe00 7e00fe10     ..D...l........~
 80028a8:	7e908884 2810fe00 02008244 fe80807e     ...~...(D...~...
 80028b8:	2040fe00 fe00fe40 fe101010 82827c00     ..@ @........|..
 80028c8:	fe007c82 fe808080 9090fe00 7c006090     .|...........`.|
 80028d8:	44828282 fe808000 e4008080 fc121212     ...D............
 80028e8:	fe887000 c6007088 c6281028 0202fe00     .p...p..(.(.....
 80028f8:	e00003fe fe101010 fe02fe00 fe00fe02     ................
 8002908:	ff02fe02 12fe80c0 fe000c12 fe0c1212     ................
 8002918:	1212fe00 44000c12 7c929282 7c10fe00     .......D...|...|
 8002928:	66007c82 fe909098 2a2a0400 3c001e2a     .|.f......***..<
 8002938:	8c525252 2a2a3e00 3e00142a 00302020     RRR..>***..>  0.
 8002948:	22221e03 1c00033e 102a2a2a 3e083600     .."">...***..6.>
 8002958:	14003608 142a2a22 08043e00 3e003e10     .6.."**..>...>.>
 8002968:	3e504804 14083e00 1c020022 003e2020     .HP>.>.."...  >.
 8002978:	08103e00 3e003e10 3e080808 22221c00     .>...>.>...>..""
 8002988:	3e001c22 3e202020 22223f00 1c001c22     "..>   >.?"""...
 8002998:	14222222 3e202000 39002020 003c0605     """..  >  .9..<.
 80029a8:	3e241800 36001824 00360808 02023e00     ..$>$..6..6..>..
 80029b8:	3000033e 3e080808 3e023e00 3e003e02     >..0...>.>.>.>.>
 80029c8:	3f023e02 0a3e2030 3e00040a 3e040a0a     .>.?0 >....>...>
 80029d8:	0a0a3e00 1400040a 1c2a2a22 1c083e00     .>......"**..>..
 80029e8:	12001c22 3e28282c                       "...,((>

080029f0 <vtable for Beeper_t>:
	...
 80029f8:	08001e11 08001e01 08001e41 00000000     ........A.......
	...

08002a10 <vtable for LedSmooth_t>:
	...
 8002a18:	08001ef1 08001ec1 08001f61 00000000     ........a.......
	...

08002a30 <bsqBeepBeep>:
 8002a30:	00000200 0107b700 00000036 00000000     ........6.......
 8002a40:	00000000 00360100 00000000 00000200     ......6.........
 8002a50:	0107b700 00000036 00000000 00000000     ....6...........
 8002a60:	00000300 00000000 00000000 00000000     ................
 8002a70:	6e69450d 203a6f66 202c7525 202c7525     .Einfo: %u, %u, 
 8002a80:	0d007525 656c6153 786f426d 42484120     %u..SalemBox AHB
 8002a90:	0075253d 61796941 61654620 6f72616e     =%u.Aiya Feanaro
 8002aa0:	00000021 00000000 00000000 00000000     !...............

08002ab0 <lsqFadeIn>:
 8002ab0:	00027600 0003ff00 00000000 00000000     .v..............

08002ac0 <bsqButton>:
 8002ac0:	00000100 0107b700 00000036 00000000     ........6.......
 8002ad0:	00000000 00000300 00000000              ............
